ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
7180d1a2-757d-4f14-9e3a-5e68499813e5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {
"
d6fef9c9-0138-4539-83b2-b37b38bc62f6,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {
"
ad3c961a-1f56-4a1b-8db1-1d9d5cea7891,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {
"
548e44c8-79a2-4959-b1d4-14c13120ae9d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {
"
cf6df4ff-9304-4d59-9393-f6bfa29ac3c5,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {
"
2e2ea89d-75b4-4f34-9076-2a26d1607b11,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {
"
a1b816fb-b770-4ff7-8e8c-64df9b4ec0ce,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains one unit test case for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {
"
b830ecc6-7adb-487a-9eef-ca98ce09edce,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// LagoonProcessor.java
/*
 * Copyright (c) 2001-2004, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    private static final boolean DEBUG = false;

    private final String targetURL;

    private final FileStorage targetLocation;

    private File repositoryDir;

    private File tempDir;

    private File classDir;

    private File sourceRootDir;

    private java.net.URL[] classLoaderURLs;

    private ClassLoader repositoryClassLoader;

    private final Hashtable classDict;

    private final Hashtable paramDict;

    private final Hashtable filestorageDict;

    private Sitemap sitemap;

    PrintWriter log;

    PrintWriter err;

    /**
     * Constructs and initializes a LagoonProcessor.
     *
     * @param targetURL  where to put the generated files,
     *                   must be an absolute URL or a local file path
     * @param sitemapTree  the Sitemap as an XTree
     * @param sourceDir  where the source files are
     * @param password  password to access the target storage, or
     *                  <code>null</code> if not nessesary.
     * @param log  where to write progress messages.
     * @param err  where to write error messages.
     */
    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {
        this.targetURL = targetURL;
        this.log = log;
        this.err = err;
        classDict = new Hashtable();
        paramDict = new Hashtable();
        filestorageDict = new Hashtable();
        targetLocation = createFileStorage(targetURL);
        if (targetLocation == null)
            throw new LagoonException(""Cannot find FileStorage for URL "" + targetURL);
        if (targetLocation.needPassword() && (password == null)) {
            throw new AuthenticationMissingException();
        }
        String absPath = sourceDir.getAbsolutePath();
        this.sourceRootDir = new File(absPath);
        if (!this.sourceRootDir.isDirectory())
            throw new LagoonException(""sourceDir must be an existing directory: "" + sourceDir);
        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);
        File workDir = new File(System.getProperty(""user.home""), "".lagoon"");
        if (!workDir.exists()) {
            if (!workDir.mkdir())
                throw new IOException(""Unable to create directory: "" + workDir);
        } else {
            if (!workDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + workDir);
            }
        }
        if (sitemap.getSiteName() != null) {
            repositoryDir = new File(workDir, sitemap.getSiteName());
            if (!repositoryDir.exists()) {
                if (!repositoryDir.mkdir())
                    throw new IOException(""Unable to create directory: "" + repositoryDir);
            } else {
                if (!repositoryDir.isDirectory()) {
                    throw new IOException(""Unable to create directory (a file with that name exists): "" + repositoryDir);
                }
            }
        } else {
            repositoryDir = null;
        }
        if (repositoryDir != null) {
            tempDir = new File(repositoryDir, ""temp"");
            classDir = new File(repositoryDir, ""classes"");
        } else {
            tempDir = new File(workDir, ""temp"");
        }
        if (!tempDir.exists()) {
            if (!tempDir.mkdir())
                throw new IOException(""Unable to create directory: "" + tempDir);
        } else {
            if (!tempDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + tempDir);
            }
        }
        if (classDir == null) {
            classDir = new File(tempDir, ""classes"");
        }
        if (!classDir.exists()) {
            if (!classDir.mkdir())
                throw new IOException(""Unable to create directory: "" + classDir);
        } else {
            if (!classDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + classDir);
            }
        }
        classLoaderURLs = new java.net.URL[] { classDir.toURL() };
        reloadClasses();
        sitemap.init();
        targetLocation.open(targetURL, this, password);
    }

    /**
     * Get the Sitemap.
     *
     * @return the Sitemap.
     */
    Sitemap getSitemap() {
        return sitemap;
    }

    /**
     * Get the target location.
     *
     * @return the target location.
     */
    FileStorage getTargetLocation() {
        return targetLocation;
    }

    /**
     * Perform the building of the website.
     * May be invoked multiple times.
     * Synchronous, returns when the building is complete.
     *
     * @param force force a rebuild of all files, otherwise dependency
     *        checking is used to check which files that needs rebuilding.
     *
     * @return true if successful, false if any non-fatal error occured
     * @throws IOException  if any fatal error occur
     */
    public boolean build(boolean force) throws IOException {
        boolean success = true;
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.beforeBuild(force);
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            if (!ent.build(force))
                success = false;
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.afterBuild(force);
        }
        return success;
    }

    /**
     * Dispose this object and release any resources it holds.
     * This causes the FileStorage to be closed.
     */
    public void destroy() throws IOException {
        sitemap.destroy();
        targetLocation.close();
        repositoryClassLoader = null;
        if (repositoryDir == null) {
            File[] classFiles = classDir.listFiles();
            for (int i = 0; i < classFiles.length; i++) {
                classFiles[i].delete();
            }
        }
    }

    public File getTempDir() {
        return tempDir;
    }

    public InputStream readFileFromRepository(String key) {
        return readFileFromRepository(null, key);
    }

    InputStream readFileFromRepository(String dir, String key) {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""readFileFromRepository: "" + theFile);
        try {
            return new FileInputStream(theFile);
        } catch (FileNotFoundException e) {
            return null;
        }
    }

    public OutputStream storeFileInRepository(String key) throws IOException {
        return storeFileInRepository(null, key);
    }

    OutputStream storeFileInRepository(String dir, String key) throws IOException {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        theDir.mkdir();
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""storeFileInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public Class loadClassFromRepository(String className) throws ClassNotFoundException {
        if (DEBUG)
            System.out.println(""loadClassFromRepository: "" + className);
        try {
            return Class.forName(className, true, repositoryClassLoader);
        } catch (ClassFormatError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" is malformed"");
        } catch (VerifyError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" does not verify"");
        }
    }

    public OutputStream storeClassInRepository(String className) throws IOException {
        if (classDir == null)
            return null;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""storeClassInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public void deleteClassInRepository(String className) throws IOException {
        if (classDir == null)
            return;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""deleteClassInRepository: "" + theFile);
        if (theFile.isFile() && !theFile.delete())
            throw new IOException(""Unable to delete file: "" + theFile);
    }

    public void reloadClasses() {
        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);
    }

    public Object getObjectFromRepository(String key) throws IOException {
        return getObjectFromRepository(null, key);
    }

    Object getObjectFromRepository(String dir, String key) throws IOException {
        InputStream is = readFileFromRepository(dir, key);
        if (is == null)
            return null;
        ObjectInputStream ois = new ObjectInputStream(is);
        try {
            return ois.readObject();
        } catch (ClassNotFoundException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ObjectStreamException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ClassCastException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (EOFException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } finally {
            is.close();
        }
    }

    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {
        return putObjectIntoRepository(null, key, obj);
    }

    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {
        OutputStream os = storeFileInRepository(dir, key);
        if (os == null)
            return false;
        ObjectOutputStream oos = new ObjectOutputStream(os);
        try {
            oos.writeObject(obj);
            return true;
        } finally {
            oos.close();
        }
    }

    /**
     * Create a new producer.
     *
     * @param cat  the producer category (format, transform, source,
     *             read, parse or process).
     * @param type the producer type, use """" for default.
     *
     * @return  a new Producer
     *          or <code>null</code> if it cannot be found.
     */
    Producer createProducer(String cat, String type) throws LagoonException {
        Class cls = (Class) classDict.get(cat + "":"" + type);
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/producer/"" + cat + ((type == """") ? """" : (""-"" + type));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                if (className == null)
                    throw new LagoonException(""Illegal Producer config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core."" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(cat + "" class must derive from "" + baseClassName);
                    classDict.put(cat + "":"" + type, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""Producer class cannot be found:"" + e.getMessage());
                }
                Hashtable params = new Hashtable();
                for (; ; ) {
                    String s = br.readLine();
                    if (s == null)
                        break;
                    int colon = s.indexOf(':');
                    if (colon < 1)
                        throw new LagoonException(""Illegal producer config file: "" + fileName);
                    String paramName = s.substring(0, colon).trim();
                    String paramValue = s.substring(colon + 1).trim();
                    params.put(paramName, paramValue);
                }
                br.close();
                paramDict.put(cat + "":"" + type, params);
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            Producer prod = (Producer) cls.newInstance();
            Hashtable params = (Hashtable) paramDict.get(cat + "":"" + type);
            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {
                String name = (String) e.nextElement();
                String value = (String) params.get(name);
                prod.addParam(name, value);
            }
            return prod;
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate producer class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate producer class (instantiation failed): "" + e.getMessage());
        }
    }

    /**
     * Create a new file storage
     *
     * @param url  the URL
     *
     * @return  a new FileStorage
     *          or <code>null</code> if it cannot be found.
     */
    FileStorage createFileStorage(String url) throws LagoonException {
        Class cls = null;
        String prefix;
        int colon = url.indexOf(':');
        if (colon < 1) {
            prefix = """";
            cls = (Class) filestorageDict.get("""");
        } else {
            prefix = url.substring(0, colon);
            cls = (Class) filestorageDict.get(prefix);
            if (cls == null) {
                cls = (Class) filestorageDict.get("""");
            }
        }
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"" + ((prefix == """") ? """" : (""-"" + prefix));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null) {
                    fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"";
                    is = getClass().getResourceAsStream(fileName);
                    prefix = """";
                }
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                br.close();
                if (className == null)
                    throw new LagoonException(""Illegal FileStorage config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core.FileStorage"";
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(""file storage class must derive from "" + baseClassName);
                    filestorageDict.put(prefix, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""FileStorage class cannot be found:"" + e.getMessage());
                }
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            return (FileStorage) cls.newInstance();
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate file storage class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate file storage class (instantiation failed): "" + e.getMessage());
        }
    }

    public boolean canCheckFileHasBeenUpdated(String url) {
        return !Utils.absoluteURL(url) || url.startsWith(""part:"") || url.startsWith(""file:"") || url.startsWith(""res:"");
    }

    public File getSourceRootDir() {
        return sourceRootDir;
    }

    public String getFileURLRelativeTo(String url, String base) {
        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {
            return url;
        } else {
            if (!Utils.pseudoAbsoluteURL(base))
                throw new IllegalArgumentException(""base must be a pseudo-absolute URL"");
            int slash = base.lastIndexOf('/');
            String baseDir = base.substring(0, slash + 1);
            return baseDir + url;
        }
    }

    public String getProperty(String key) {
        return sitemap.getProperty(key);
    }
}
","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains one unit test case for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {
"
439305da-52e2-467c-bb4e-457b1b49f75d,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Wildcard.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {
"
bd31a61e-8c7e-44ca-b189-ba610042426e,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Wildcard.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {
"
d4cd5926-074d-4c75-9c9d-3676735431d9,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Wildcard.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains one unit test case for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {
"
a4aa09a8-a76b-4bc6-a922-091a2139e4d1,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FTPFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private FTPClient ftp;

    private String url;

    private String password;

    /**
     * Default constructor.
     */
    public FTPFileStorage() {
    }

    public boolean needPassword() {
        return true;
    }

    public boolean isReentrant() {
        return false;
    }

    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {
        this.url = url;
        this.password = password;
        ftp = new FTPClient(url, password);
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
        ftp.close();
        ftp = null;
    }

    /**
     * Create a new file, or overwrite an existing file.
     *
     * @param pathname  path to the file
     */
    public OutputHandler createFile(String pathname) throws IOException {
        OutputStream os;
        try {
            os = ftp.store(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            os = ftp.store(pathname);
        }
        return new FTPOutputHandler(pathname, os);
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param pathname  path to the file
     */
    public void deleteFile(String pathname) throws java.io.IOException {
        try {
            ftp.deleteFile(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            ftp.deleteFile(pathname);
        }
    }

    class FTPOutputHandler extends OutputHandler {

        private String currentPathname;

        FTPOutputHandler(String currentPathname, OutputStream out) {
            super(out);
            this.currentPathname = currentPathname;
        }

        public void commit() throws java.io.IOException {
            out.close();
            fileModified(currentPathname);
        }

        public void discard() throws java.io.IOException {
            try {
                commit();
            } catch (FTPException e) {
                // ignore exception
            }
            ftp.deleteFile(currentPathname);
        }
    }
}
","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains one unit test case for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {
"
646515ac-1ab2-4ff8-8cb6-bf7083ca4613,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// SSHFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private String host;

    private int port;

    private String username;

    private String rootPath;

    private Runtime rt;

    private Process runSSH(String[] command) throws IOException {
        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];
        cmdline[0] = ""ssh"";
        cmdline[1] = ""-q"";
        cmdline[2] = ""-e"";
        cmdline[3] = ""none"";
        cmdline[4] = ""-l"";
        cmdline[5] = username;
        if (port > 0) {
            cmdline[6] = ""-p"";
            cmdline[7] = Integer.toString(port);
        }
        cmdline[(port > 0) ? 8 : 6] = host;
        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);
        if (DEBUG) {
            System.out.println(""Executing: "");
            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);
            System.out.println();
        }
        return rt.exec(cmdline);
    }

    /**
     * Default constructor.
     */
    public SSHFileStorage() {
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {
        if (!url.startsWith(""ssh://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.lastIndexOf('@');
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {
            this.rootPath = path;
        } else {
            this.rootPath = path.substring(0, path.length() - 1);
        }
        this.rt = Runtime.getRuntime();
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path  path to the file
     *
     * @return an OutputStream to write to
     *
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0) ? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + path });
        proc.getOutputStream().close();
        try {
            proc.waitFor();
        } catch (InterruptedException e) {
        }
    }

    class SSHOutputHandler extends OutputHandler {

        private String currentPath;

        private Process currentProc;

        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {
            super(out);
            this.currentPath = currentPath;
            this.currentProc = currentProc;
        }

        public void commit() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            fileModified(currentPath);
        }

        public void discard() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + currentPath });
            proc.getOutputStream().close();
            try {
                proc.waitFor();
            } catch (InterruptedException e) {
            }
        }
    }
}
","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains one unit test case for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {
"
1e43056c-885e-4954-838b-1f25343b7d93,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// LocalFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    private File root;

    /**
     * Default constructor.
     */
    public LocalFileStorage() {
        root = null;
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {
        root = new File(loc);
        if (root.exists()) {
            if (!root.isDirectory())
                throw new IOException(""Location exists but is not a directory"");
        } else {
            if (!root.mkdir())
                throw new IOException(""Location didn't exist and couldn't be created"");
        }
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() // throws java.io.IOException;
    {
        root = null;
    }

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path  path to the file
     *
     * @return  the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }

    /**
     * Create a new file, or overwrite an existing file.
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                if (!file.mkdir())
                    throw new IOException(""Unable to create directory: "" + file);
            oldPos = pos + 1;
        }
        File currentFile = new File(file, path.substring(oldPos));
        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            // file doesn't exist
            if (!file.exists())
                return;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        if (!file.exists())
            return;
        if (file.delete()) {
            return;
        } else {
            throw new IOException(""Unable to delete file: "" + file);
        }
    }

    static class LocalOutputHandler extends OutputHandler {

        private File currentFile;

        LocalOutputHandler(File currentFile, OutputStream out) {
            super(out);
            this.currentFile = currentFile;
        }

        public void commit() throws java.io.IOException {
            out.close();
        }

        public void discard() throws java.io.IOException {
            out.close();
            if (!currentFile.exists())
                return;
            if (currentFile.delete()) {
                return;
            } else {
                throw new IOException(""Unable to delete file: "" + currentFile);
            }
        }
    }
}
","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains one unit test case for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {
"
bcc6d784-dc9d-4d7a-b6e0-283fcadc9248,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {
"
71eda9a5-fd3b-41e6-89d3-60c6c419d7cb,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {
"
8b324503-b882-4581-a25a-32f437d610d7,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {
"
0bff606c-1bfc-490d-8c74-ab6912000abf,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {
"
d874185f-3476-4802-bb91-cf3e5cf6c832,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {
"
d0140502-4eda-4885-a301-7b87b2f67ff9,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {
"
45bb4e73-be9c-481d-9c98-d6f8db6de2b6,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Element.java
/*
 * Copyright (c) 2001, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains one unit test case for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {
"
69597f63-f843-414d-9de7-8d5ff1f76291,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Text.java
/*
 * Copyright (c) 2001-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    static final long serialVersionUID = -128692223369356277L;

    final String value;

    transient char[] charArrayCache;

    /**
     * Constructs a text node from a char[] buffer.
     *
     * @param data  a char[] buffer
     * @param start  the offset to read from in the buffer
     * @param length  the number of characters to read from the buffer
     * @param forceCopy  force copying of the data, if false a reference
     *                   to the buffer may be keept.
     */
    public Text(char[] data, int start, int length, boolean forceCopy) {
        value = new String(data, start, length);
        if (start == 0 && length == data.length && !forceCopy)
            charArrayCache = data;
    }

    /**
     * Constructs a text node from a String.
     *
     * @param value  the string
     */
    public Text(String value) {
        this.value = value;
    }

    /**
     * Get the charater content as a string
     */
    public String getValue() {
        return value;
    }

    private void obtainCharArray() {
        if (charArrayCache == null)
            charArrayCache = value.toCharArray();
    }

    /**
     * Get the charater content as a char[].
     */
    public char[] asCharArray() {
        obtainCharArray();
        return charArrayCache;
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        obtainCharArray();
        sax.characters(charArrayCache, 0, charArrayCache.length);
    }

    public boolean isWhitespaceNode() {
        for (int i = 0; i < value.length(); i++) {
            if (value.charAt(i) > ' ')
                return false;
        }
        return true;
    }
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains one unit test case for the {@link Text#asCharArray()} method.
*/
class TextTest {
"
91168312-8af6-4872-a18b-135f64fd95ff,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// SequentialTreeBuilder.java
/*
 * Copyright (c) 2002-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private static final String XML_NS = ""http://www.w3.org/XML/1998/namespace"";

    private URL baseURI;

    private Locator locator = null;

    private ElementHandler handler;

    private Element rootElement;

    private TreeBuilder subTreeBuilder;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private int inSubTree = 0;

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     *
     * @param handler   handler to invoke for each element
     */
    public SequentialTreeBuilder(ElementHandler handler) {
        this(handler, null);
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     *
     * @param handler   handler to invoke for each element
     * @param base      base URL for the document, to support xml:base.
     */
    public SequentialTreeBuilder(ElementHandler handler, URL base) {
        this.handler = handler;
        baseURI = base;
        subTreeBuilder = new TreeBuilder();
    }

    /**
     * Obtain the root Element
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getRootElement() throws IllegalStateException {
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
        subTreeBuilder.setDocumentLocator(locator);
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (rootElement == null) {
            rootElement = new Element(namespaceURI, localName, atts.getLength());
            if (locator != null) {
                rootElement.setSystemId(locator.getSystemId());
                rootElement.setLine(locator.getLineNumber());
                rootElement.setColumn(locator.getColumnNumber());
            }
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
            for (int i = 0; i < atts.getLength(); i++) {
                rootElement.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
                if (atts.getURI(i).equals(XML_NS) && atts.getLocalName(i).equals(""base"")) {
                    try {
                        URL url = new URL(rootElement.getBaseURI(), atts.getValue(i));
                        rootElement.setBaseURI(url);
                    } catch (java.net.MalformedURLException e) {
                        throw new SAXException(e);
                    }
                }
            }
            if (nsPrefix != null) {
                rootElement.setNamespaceMappings(nsPrefix, nsURI);
            }
        } else {
            inSubTree++;
            subTreeBuilder.startElement(namespaceURI, localName, qName, atts);
        }
    }

    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (inSubTree > 0) {
            subTreeBuilder.endElement(namespaceURI, localName, qName);
            if (inSubTree == 1) {
                Element el = subTreeBuilder.getTree();
                el.setParent(rootElement);
                handler.processElement(el);
                subTreeBuilder.reset();
            }
            inSubTree--;
        } else {
            // nothing to do
        }
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (rootElement == null) {
            if (nsPrefix == null) {
                nsPrefix = new Vector();
                nsURI = new Vector();
            }
            nsPrefix.addElement(prefix);
            nsURI.addElement(uri);
        } else {
            subTreeBuilder.startPrefixMapping(prefix, uri);
        }
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.characters(ch, start, length);
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.ignorableWhitespace(ch, start, length);
    }

    public void processingInstruction(String target, String data) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.processingInstruction(target, data);
    }

    public void skippedEntity(String name) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.skippedEntity(name);
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains one unit test case for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {
"
5106db7e-0814-4a95-8b08-898189b2c099,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {
"
3253e649-03b4-4fe3-b9f7-b3d429e6f04c,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains one unit test case for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {
"
f52b17ee-614d-4ec4-b81b-e521f3ec7a80,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {
"
8ebea963-a8f7-4fff-9c7f-c2b4d7079d21,/EvoSuiteBenchmark/original/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael Stï¿½ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains one unit test case for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {
"
