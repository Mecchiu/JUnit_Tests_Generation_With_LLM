[
{
    "choices": [
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\tprivate static int port;\n\n\t\tprivate static final String s1 = \"\\r\\n<a href=\\\"http://bbc.co.uk/\\\">BBC</a>\";\n\n\t\tprivate static final String s2 = \"Hello, World!\";\n\n\t\tprivate static void init() throws Exception {\n\t\t\tif (port == -1) {\n\t\t\t\tport = HttpServletResponse.HTTP_OK;\n\t\t\t\tString name = \"http.unittests.org\";\n\t\t\t\tString contextPath = \"/\";\n\t\t\t\tif (name.startsWith(\"http://www\")) {\n\t\t\t\t\tcontextPath = \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tURL url = new URL(\"http://www.\" + name + \".\" + contextPath);\n\t\t\t\tSystem.err.println(\"ServerURL: \" + url.toString());\n\t\t\t}\n\t\t}\n\n\t/**\n\t * Run all the unit tests.\n\t * @throws Exception if an error occurs.\n\t */\n\t@Test\n\tpublic void runAll() throws Exception {\n\t\tHTMLOutputStream res = new HTMLOutputStream(null);\n\t\tassertEquals(HttpServletResponse.HTTP_OK, res.getStatus());\n\n\t\tinit();\n\t\tres = res.reset();\n\t\tassertEquals(HttpServletResponse.HTTP_OK, res.getStatus());\n\n\t\tres = res.reset();\n\t\tassertEquals(HttpServletResponse.HTTP_OK, res.getStatus());\n\n\t\tres = res.reset();\n\t\tassertEquals(HttpServletResponse.HTTP_ERROR, res.getStatus());\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\tpublic HTMLOutputStreamTest() { }\n\n    /**\n     * It tests whether the output stream has the\n     * ContentLength/Type, and a valid size of 0.\n     */\n    @Test\n    public void testReset() {\n        assertEquals(\"resets error message\", \"\", reset());\n    }\n\n    /**\n     * It tests whether a valid object, of a size 0 does not throw any exception.\n     * After calling reset(), there is no need to explicitly call flush().\n     */\n    @Test\n    public void testNonReset() {\n        reset();\n        assertEquals(\"error message\", \"\", reset());\n    }\n\n    /**\n     * It tests whether a valid object, of a size 1 does not throw any exception.\n     * After calling reset(), there is no need to explicitly call flush().\n     */\n    @Test\n    public void testReset1() {\n        assertNotEquals(\"error message 1\", \"\", reset());\n    }\n\n    /**\n     * It tests whether a valid object, of a size 2 does not throw any exception.\n     * After calling reset(), there is no need to explicitly call flush().\n     */\n    @Test\n    public void testReset2() {\n        assertNotEquals(\"error message 2\", \"\", reset());\n    }\n\n    public static class Inner {\n                    private PrintWriter pw = null;\n\n            protected void print(String str, int n = 100) {\n                pw.println(str);\n                pw.print(n);\n            }\n\n            //  Methods of inner class for HTMLOutputStream\n            public void print(int n) {\n//                     pw.println(n);\n            }\n\n            public void println(String str) {\n                pw.println(str);\n            }\n\n            public void println(int n) {\n                pw.println(n);\n            }\n\n            public void flush() throws IOException {\n                if (pw!= null)\n                    pw.flush();\n            }\n    }\n\n    // InnerClass\n    static class InnerException extends Exception { }\n\n    //  Base Class\n    public static class Base {\n        //  Base Constructor\n        public Base () throws Exception {\n            print(true);\n        }\n\n        //  Base Class Methods\n        public void print() throws IOException, InnerException {}\n        \n        public void print(boolean v) throws IOException, InnerException {}\n\n        //  Base Class Functions.\n        public void foostr() throws IOException, InnerException {} // inner class foostr()\n        \n        public String sostr() throws IOException, InnerException {}\n        \n        //  Base Class Test()\n        public String test() throws Exception {}\n        \n        public void test(Base b) throws Exception, InnerException {}\n    }\n\n    // The subclass for the outer class.\n    protected class Outer extends Base {\n\n        protected void test() throws Exception {\n            InnerException ex = null;\n\n            //  Test\n            try {\n                OuterClass.test();\n            }\n            catch (InnerException err) {\n                ex = err;\n            }\n            catch (Exception e) {\n                // Ignore\n            }\n            InnerUtils.check(ex);\n        }\n    }\n\n    //  HTMLOutputStream (super class)\n    public class HTMLOutputStreamTest_Super extends HTMLOutputStream {\n        public HTMLOutputStreamTest_Super() { super(); }\n \n        //  Base Class Method\n        public void test() throws Exception {\n            InnerException ex = null;\n\n            //  Test\n            try {\n                HTMLOutputStreamTest.this.test();\n            }\n            catch (InnerException err) {\n                ex = err;\n            }\n            catch (Exception e) {\n                // Ignore\n            }\n            InnerUtils.check(ex);\n        }\n    }\n\tprotected class HTMLOutputStreamTest_Sub extends HTMLOutputStreamTest {\n\t\tprotected void test() throws Exception {\n\t\t\ttry {\n\t\t\t\tHTMLOutputStreamTest.this.test();\n\t\t\t}\n\t\t\tcatch (InnerException err) {\n\t\t\t\t// Exception already handled\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\tInnerUtils.check(e);\n\t\t}\n\t}\n}\n\n/**\n\n* Inner class with an inner method with an exception.\n* @author James Stauffer\n*/\nclass Inner {\n\t\n\tpublic void test() throws Exception {\n\t\ttry {\n\t\t\tInnerClass.foostr();\n\t\t}\n\t\tcatch (Exception err) {\n\t\t\tInnerUtils.check(err);\n\t\t}\n\t}\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\t\n    private final String contentType = \"text/html\";\n    /*\tprivate final ServletRequest request = mock(ServletRequest.class);\n\t\tprivate final ServletResponse response = mock(ServletResponse.class);*/\n\n    private final static String ENCODING = \"UTF-8\";\n\n    private int counter = 0;\n    \n    /**\n* Constructors\n*\n* @param tc test conditions\n* @throws  Exception\n*/\n    public HTMLOutputStreamTest(String tc) throws Exception {\n\tcounter = 0;\n\treset();\n    }\n\n    boolean assertTrue(String cond, String msg) {\n\tassertTrue(\"Fail. \" + cond + \" \" + msg, new Boolean(new Boolean(cond)).equals(true));\n\treturn cond.equals(\"false\"); // to satisfy the static verifier\n    }\n\n    /**\n    * Gets a TestCase object.\n    * All methods should run in the scope of this object.\n    * For this test program to be complete, \n    * you would subclass this object and implement the following \n    * getClassName() method in order to get a test case name.\n    */\n    private class ObjectTestCase extends TestCase {\n        public ObjectTestCase(String testName) {\n            super(testName);\n            //\t// Set up the test data\n            // This is an example of a set up call to work with\n            //\t//  this class. You can easily subclass this.\n            //\t// You may or may not have to do anything here!\n            //\tthis.setUp();\n\n\t\t/*\n            //  Inherited tests are run with an assertEquals/assertNotEquals\n\n            //  This assertEquals has a test case value: a value passed to this method must be the same or\n            //     different value in the case\n            this.assertEquals(\"The value to be asserted\", \"test data\", getTestCaseValue());\n            //  This  value must be the same and different value in the case.\n            this.assertNotEquals(\"The value to be not asserted\", \"test data\", getTestCaseValue());\n\t\t*/\n\n \t}\n\n\t\tpublic void init() throws Exception {\n        }\n\n        public void tearDown() throws Exception {\n            response.reset();\n            request = null;\n \t}    \n    }\n    protected String getTestCaseName(){\n\treturn \"HTMLOutputStreamTestCase\";\n    }\n \n    /**\n    * @return This test case's name.\n    */\n    public String getTestCaseName() {\n\treturn \"HTMLOutputStreamTestCase: \"+ getTestCaseValue();\n    }\n    \n    /**\n    * @javadoc Example\n\t* @return An example of an empty set to add a test suite.\n\t*/\n    public static void main(String args[]) {\n    \tString[] tests = new String[0];\n    \tString[] javafile = new String[0];\n    \tString[] javafile = new String[0];\n    \tClass[] classes = null;\n    \tjavafile = getArgValues(\"args\");\n    \tjavafile = getArgValues(\"javaFile\");\n    \tclasses = getArgValues(\"classes\");\n\n    \tfor(int i = 0 ; i < classes.length ; i++) {\n    \t\tSystem.out.println(\"Testing \" + classes[i].getCanonicalName());\n    \t\tfor (int j = 0 ; j < classes.length ; j++) {\n    \t\t\tif (classes[j] == classes[i]) {\n\t            System.out.println(\"      \" + i +\": Test case for \" + classes[i]);\n\t            return;\t\t\n    \t\t    }\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(\"       No known classes\");\n    }    \n\n    public void testCumulate() throws Exception{\n\treset();\n    \n\tfor(int i = 1 ; i < 25 ; i++) {\n\t    for(int j = i ; j > 1 ; j--) {\n\t\t// the rest of the tests will be run in this set\n\t\t// the first one will fail if the outputStream is different  \n\t\tif(binary) {\n\t\t    if(classes.length > 0) {\n\t\t\tSystem.out.println(\"   \" + classes[i]); \n\t\t    }\n\t\t    else {\n\t\t\tSystem.out.println(\"   No classes specified\");\n\t\t    }\n    \t\t\tfail(\"Fail. classes[i] cannot be null\");\n    \t\t}\n\t    }\n\t    System.out.println(\"    \" + i + \"   \" + getTestCaseName() + \" \" + binary + \" \" + j + \" classes=\" + classes.length);\n\t    if(classes.length > 0) {\n\t      \tfor(int c = i ; c <= classes.length ; c++) {\n\t\t\tif(c > i) {\n\t\t\t    System.out.println(\"    \" + c + \"   \" + classes[c].getCanonicalName()); \n\t\t\t\tClass ct = classes[c];\t\n\t      \t        byte output[] = new byte[300];\n\t\t\t    if(classes.length == 1) {\n\t\t\t\tSystem.out.println(\"    \" + classes[1].getCanonicalName() + \" is class\"); \n\t\t\t\tinput  = new byte[300];\n\t\t\t\tfor(int j = 0 ; j < output.length ; j++) {\n\t\t\t\t    out[j] = 0; //  The input buffer is filled by this test\n\t\t\t\t    for(int k = 10 ; k > j ; k--) {\n\t\t\t\t        input[j] = input[j - k];\n\t\t\t\t    }\n\t\t\t\t    input = output;\n\t\t\t\t",
            "finish_reason": "length"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\tHTMLOutputStream(HttpServletResponse response) throws Exception {\n    this.response = response;\n    this.baos = new ByteArrayOutputStream(4096);\n\t\t}\n\n\t\tpublic String toString()\n\t{\n           throw new UnsupportedOperationException(\n           \"No html output from this servlet is supported in HttpServletResponse\");\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\t/**\n* Constructor for HTMLOutputStreamTest.\n*\n* @param t the test\n*/\n    private HTMLOutputStreamTest(Object t) {\n    }\n\n    /**\n* Test the reset method.\n* The stream should return the original contents of the output after it has been reset.\n*/\n    @Test\n    public void testReset() throws Exception {\n\n\t\t//  Create instances of class we are going to test.\n\t\tHTMLOutputStream h2b = new HTMLOutputStream(null);\n\t\tHTMLOutputStream h2p = new HTMLOutputStream(null);\n\t\tHTMLOutputStream h2b2 = new HTMLOutputStream(null);\n\t\t\n\t\t//  Perform a reset to the second output stream.\n\t\th2b.print(\"<b></b>\");\n\t\th2b.println(\"<p></p>\");\n\t\th2p.print(\"<p>1</p>\");\n\t\th2p.print(\"<p>2</p>\");\n\t\th2b2.print(\"<b></b>\");\n\t\th2b2.print(\"<p>3</p>\");\n\t\th2b2.print(\"<p>4</p>\");\n\t\th2b2.println(\"<p></p>\");\n\t\t\n\t\t//  Retrieve the output after reset.\n\t\tString contents = h2b2.reset();\n\t\tString contents2 = h2b.reset();\n\n\t\t//  Assert that the outputs are the same.\n\t\tassertEquals(\"<b></b>\", contents);\n\t\tassertEquals(\"<b></b>\", contents2);\n\t\tassertEquals(\"1\", h2b2.getString());\n\t\tassertEquals(\"2\", h2b2.getString());\n\t\tassertEquals(\"3\", h2b2.getString());\n\t\tassertEquals(\"4\", h2b2.getString());\n\t\tassertEquals(\"<p></p>\", h2b2.getPW().getBuffer().toString());\n\t\tassertEquals(\"<p>1</p>\", h2b2.getPW().getBuffer().toString());\n\t\tassertEquals(\"<p>2</p>\", h2b2.getPW().getBuffer().toString());\n\t\tassertEquals(\"<p>3</p>\", h2b2.getPW().getBuffer().toString());\n\t\tassertEquals(\"<p>4</p>\", h2b2.getPW().getBuffer().toString());\n\n\t\t//  Clean up.\n\t\th2b2.print(\"<p></p>\");\n\t\th2b2.println(\"<p>5</p>\");\n\t\th2b2.flush();\n\t\th2b2.close();\n\n\t\t//  Check that the second output stream is not open.\n\t\tassertFalse(\"Both output streams are open\", h2b2.isOpen());\n\n\t\ttry {\n\t\t\t//  Check that the second output stream can be reopened.\n\t\t\th2b2.close();\n\t\t} catch (IOException exc) {\n\t\t\tassertTrue(\"Both closed streams can be reopened\", h2p.isOpen());\n\t\t}\n\n\t\t//  Check that the contents after reset are the same.\n\t\tassertEquals(\"<b></b>\", contents);\n\t\tassertEquals(\"<b></b>\", contents2);\n\n\t\t// Check that the contents after two reset are equal\n\t\t// to the contents of the first output stream.\n\t\tassertEquals(\"<b></b>\", contents);\n\t\tassertEquals(\"<b></b>\", contents2);\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\tprivate HTMLOutputStream tester;\n\n\t\t/**\n\t\t* Constructor for {@link HTMLOutputStreamTest}.\n\t\t*\n\t\t* @see HTMLOutputStreamTest#HTMLOutputStreamTest(java.lang.String)\n\t\t*/\n\t\tpublic HTMLOutputStreamTest(String name) {\n\t\t\tsuper(name);\n\t\t}\n\n\t\t/**\n\t\t* Tests that reset() works.\n\t\t*/\n\t\t@Test public void testReset() {\n\t\t\tHTMLOutputStream tester = new HTMLOutputStream(null);\n\t\t}\n\n\n}\n\n",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\tHTMLOutputStream hos;\n\n    /**\n     * Constructor.\n     * Builds a test stream to print to.\n     */\n    public HTMLOutputStreamTest(){\n        hos = new HTMLOutputStream(null);\n    }\n\n    /**\n     * Set the response for the test to test the content\n     * of the buffered stream.\n     */\n    @Test\n    public void test() throws IOException {\n        //  Read a file\n        byte[] bytes = FileUtils.read(new File(\"Input\"));\n        //  Do something with the file\n        hos.print(bytes);\n        //  Test reset()\n        hos.reset();\n        assertTrue(\"failed to reset stream\", hos.getSize()>0);\n    }\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\t\n    // Initialize instance variables\n    private HttpServletResponse response = null;\n    private HTTPResponse response_copy = null; // copy for comparison\n    private BufferedOutputStream bos = null;\n    private BufferedOutputStream bos2 = null;\n    private InputStream istream = null;\n    private DataSource dsource = null;\n\n    /**\n     * Test constructors.\n     */\n    @Test\n    public void testConstructors() throws Exception {\n        TestString t1 = new TestString(new String[]{\"one\", \"two\"});\n        TestString t2 = new TestString(new String[]{\"c\", \"d\"});\n        HTMLOutputStream t3 = new HTMLOutputStream(100, response_copy);\n\n        assertTrue(t1.toString() + \" does not match: \" + t2.toString(), t1.equals(t2));\n\n        assertTrue(t1.toString() + \" does not match: \" + t3.toString(), t1.equals(t3));\n    }\n\n    /**\n     * Test string representation.\n     */\n    @Test\n    public void testStringRepresentation() throws Exception {\n        HTMLOutputStream t = new HTMLOutputStream(200, null);\n        assertEquals(response.getStatus(), 200, \"String representation for 200 is incorrect.\");\n        String s = t.toString();\n        assertTrue(s.startsWith(\"<HTML>\"));\n        assertTrue(s.endsWith(\"</HTML>\"));\n        assertTrue(s.equals(t.toString()));\n        assertTrue(s.startsWith(\"<HTML text-align=\\\"left\\\">\"));\n        assertTrue(s.endsWith(\"</HTML text-align=\\\"left\\\">\"));\n        assertTrue(s.equals(t.toString()));\n    }\n\n    /**\n     * Test equals and hashcode.\n     */\n    @Test\n    public void testGettersAndSetters() throws Exception {\n        // Initialize instance variables\n        HTMLOutputStream t1 = new HTMLOutputStream(200, null);\n        HTMLOutputStream t2 = new HTMLOutputStream(200, null);\n\n        assertTrue(t1.equals(t2), \"T1 does not make sense for unequal objects.\");\n\n        t1.setContentEncoding(\"deflate\");\n        assertTrue(t1.equals(t2), \"T1 does not make sense for unequal objects.\");\n\n        for (int i = 0; i < 100; i++) {\n            t2.write(\"<POST CONTENT>\".getBytes());\n            if (i % 2 == 0) {\n                t1.write(\"<POST CONTENT>\".getBytes());\n            }\n            if (i % 2 == 1) {\n                t2.append(\"<POST CONTENT>\".getBytes());\n            }\n        }\n\n        assertEquals(t2.toString(), t1.toString(), \"T2 does not make sense for unequal objects.\");\n    }\n\n    /**\n     * Unit tests for the {@link HTMLOutputStream#setResponse(HttpServletResponse, String)  }method.\n     */\n    @Test\n    public void testSetResponse() throws ClientProtocolException, IOException {\n    \tURL url = new URL(\"http://localhost:8080/\", \"\", \"\");\n        Response res = bserver.getResponse(url);\n        InputStream in = new NullOutputStream ();\n        HTTPClientFactory.setResponseContentTypeAndBody(res, \"text/html\", in);\n\n        HTMLOutputStream t = new HTMLOutputStream(res);\n        t.setResponse(response, \"<html>Response:</html>\");\n        String expected = \"<html>Response: Response: Response: <html>Response: Response: </html>\";\n    \tassertEquals(expected, t.toString());\n    }\n\n    /**\n     * Unit test for the {@link HTMLOutputStream#setDataSource(javax.servlet.ServletResponse, org.jsmpp.bean.DataSource)} method.\n     */\n    @Test\n    public void testSetDataSource() throws URISyntaxException,\n            IllegalComponentStateException, IOException {\n        DataSource ds;\n        URL url = new URL(\"http://localhost:8080/\", \"\", \"\");\n        response = bserver.getResponse(url);\n\n        InputStream input;\n        for (int i = 0; i < 5; i++) {\n            InputStream bais = null;\n            if (\"javax.xml.bind.SAX\".equals(response.getContentType())) {\n                bais = new BufferedReader(new XMLReader(dataSource), 1024);\n            } else if (\"javax.xml.bind.BIND\".equals(response.getContentType())) {\n                InputStream stream = dataSource;\n                bais = new BufferedReader(new InputStreamReader(stream), 1024);\n            } else if (\"org.jsmpp.bean.DataSource\".equals(response.getContentType())) {\n                InputStream stream = dataSource;\n            } else {\n                // Error, unknown Content type\n                continue;\n            }\n\n            bais.mark(500); // Reset buffer to keep from being garbage collected\n\n            tbcs.clear();\n            bais.readLine();\n\n            // Use DataSource to set BCS\n            dscs.setDataSource(bais);\n            dscs.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n            ds = dscs;\n            break;\n        }\n\n        assertTrue(\"Unable to set DataSource.\", ds",
            "finish_reason": "length"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\t\n\t/**\n\t* Constructs an instance of this class.\n\t*/\n\tpublic HTMLOutputStreamTest() {\n\t}\n\t\n\t/**\n\t * test the constructor with initial values set\n\t*/\n\t@Test\n\tpublic void test(Servlet servlet) throws Exception {\n\t\t//  Define the test case\n\t}\n\n\t/**\n\t* Tests the reset() method.\n\t*/\n\t@Test\n\tpublic void testReset() throws Exception {\n\t\t//  Get the test object before modification\n\t\tHTMLOutputStream out = new HTMLOutputStream(null);\n\t\tout.reset();\n\t\tString content = out.toString();\n\t\tout.flush();\n\n\t\t\t//  modify the test object\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\tPrintWriter pw = new PrintWriter(bos);\n\t\tpw.print(content);\n\t\tpw.flush();\n\n\t\tassertEquals(\"The content is equal to the contents of the baos\", \n\t\t\t\tcontent, bos.toString());\n\t}\n}\n\n",
            "finish_reason": "stop"
        },
        {
            "text": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos!= null)? \", baos\" : \"\") + ((pw!= null)? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n\n// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {\n\t\tHTMLOutputStream s;\n\n\t\tpublic HTMLOutputStreamTest(InputStream input) throws IOException, UnsupportedEncodingException {\n\t\t\ts = new HTMLOutputStream(HttpServletResponse.class, HttpServletResponse.ISO_8859_1);\n\t\t}\n\t@Test\n\tpublic final void testInstance() {\n\t\ts = new HTMLOutputStream(HttpServletResponse.class, HttpServletResponse.ISO_8859_1);\n\t\tassertNotSame(s, null);\n\t\ts.setResponse(response);\n\t}\n\t@Test\n\tpublic final void testInstance2() {\n\t\ts = new HTMLOutputStream(HttpServletResponse.class, HttpServletResponse.ISO_8859_1, true);\n\t\tassertNotSame(s, null);\n\t}\n\t@Test\n\tpublic final void testInstance3() {\n\t\tresponse = new SimpleServletResponse();\n\t\ts = new HTMLOutputStream(HttpServletResponse.class, HttpServletResponse.ISO_8859_1, true);\n\t\tassertSame(response, s.getResponse());\n\t}\n\t@Test\n\tpublic final void testInstance4() {\n\t\tresponse = new SimpleServletResponse();\n\t\ts = new HTMLOutputStream(HttpServletResponse.class, HttpServletResponse.ISO_8859_1, true, \"foo\");\n\t\tassertSame(response, s.getResponse());\n\t}\n\t@Test\n\tpublic final void testInstance5() {\n\t\tresponse = new SimpleServletResponse();\n\t\ts = new HTMLOutputStream(HttpServletResponse.class, HttpServletResponse.ISO_8859_1, true, \"foo\", \"bar\", \"baz\");\n\t\tassertSame(response, s.getResponse());\n\t}\n\t@Test\n\tpublic final void testInitNoInput() {\n\t\ts = new HTMLOutputStream(new HTMLOutputStream.HTMLOutputStreamErrorReply(), null);\n\t\ttry {\n\t\t\ts.setContentType(\"bar\");\n\t\t\tfail(\"Must fail, because response.getContentType() is null\");\n\t\t} catch (HttpServletResponse.InitParameterException c) {\n\t\t\tassertTrue(true);\n\t\t}\n\t}\n\t@Test\n\tpublic final void testInit() throws Exception {\n\t  String path  = this.getClass().getName() + \".testInit\";\n\t    String method = \"init\";\n\t    testMethod(method, new Object[0], path, this, HttpServletResponse.class);\n\t}\n\t@Test\n\tpublic final void testInitExistingInput() throws Exception {\n\t\tresponse = new SimpleServletResponse();\n\t\tString path  = this.getClass().getName() + \".testInit\";\n\t\tString method = \"init\";\n\t\ttestMethod(method, new Object[0], path, response, HttpServletResponse.class);\n\t}\n\t@Test\n\tpublic final void testError() throws Exception {\n\t\ts = new HTMLOutputStream(new HTMLOutputStream.HTMLOutputStreamErrorReply(), null);\n\t    try {\n\t\t    s.setContentType(\"foo\");\n\t\t    fail(\"Must fail, because bad parameter: response.getContentType() is null\");\n\t    } catch (HttpServletResponse.InitParameterException c) {\n\t\t\tassertTrue(true);\n\t    }\n\t    try {\n\t\t\ts.getResponse();\n\t\t\tfail(\"Must fail, because bad parameter: response.getContentType() is null\");\n\t\t} catch (HttpServletResponse.InitParameterException c) {\n\t\t\tassertTrue(true);\n\t    }\n\t\ttry {\n\t        s.getContentType();\n\t        fail(\"Must fail, because bad parameter: response.getContentType() is null\");\n\t    } catch (HttpServletResponse.InitParameterException c) {\n\t\t\tassertTrue(true);\n\t    }\n\t}\n\n\t//\n\t//\n\t//\n\tprivate InputStream inputStream = null;\n\tprivate HttpServletResponse response = null;\n\tprivate byte[] b = null;\n\tprivate String contentType = null;\n\tprivate ClientProperties properties;\n\n\tprivate void testMethod(String method, Object[] params) {\n\t\tproperties = new ClientProperties.Builder().clientName(\"client\").username(\"foo\").password(\"foo\").build();\n    String path = this.getClass().getName() + \".test\" + method;\n\t    System.out.println(\"[Test] \" + path);\n\t    InputStream in = this.getClass().getResourceAsStream(path);\n\t    assertNotNull(in);\n\t    \n\t    String encoding = \"UTF-8\";\n\t    InputStream is = new BufferedInputStream(in, 1024 * 1024);\n\t    \n    \ttry {\n\t    \tif (!httpResponse.getMethod().equals(\"POST\") &&!httpResponse.getMethod().equals(\"PUT\") &&!httpResponse.getMethod().equals(\"GET\")) {\n\t\t\t\tSystem.out.println(\"FAILED, should be PUT\");\n\t\t\t\tthrow new IllegalStateException(\"Invalid HTTP method type - \" + httpResponse.getMethod());\n\t    \t}\n\t    \tif (binary) {\n\t    \t\tis = new BufferedInputStream(is, 1024 * 1024);\n\t    \t\tis.skip(4);\n\t    \t\tbyte[] b = new byte[1024];\n\t    \t\tint count;\n\t    \t\twhile ((count = is.read(b)) > 0) {\n\t    \t\t\tif (count > 0) {\n\t                    byte[] nba = new byte[count];\n\t                    System.arraycopy(b, 0, nba, 0, count);\n\t                    contentType = \"application/x-www-form-url",
            "finish_reason": "length"
        }
    ],
    "id": "3b965596-f962-48ae-ad2c-853d41be842a",
    "prompt_id": "/EvoSuiteBenchmark/original/68_biblestudy/src/main/java/bible/servlet/HTMLOutputStream.java",
    "original_code": "// HTMLOutputStream.java\n/*\n * BufferedOutputStream.java: Writes to a\n * buffer and handles ContentLength's and Types, as well as cleanup.\n * Copyright (C) 1998. All rights reserved.\n * St. Paul Software, St. Paul, MN, USA\n */\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\n\n/**\n * A container for output streams with its own buffers\n *\n * @author  Luke Samaha\n */\npublic class HTMLOutputStream {\n\n    //  Use-specific Constructors\n    public HTMLOutputStream(HttpServletResponse response) throws IOException {\n        this.response = response;\n        baos = new ByteArrayOutputStream(4096);\n        OutputStream out = baos;\n        //  Initialization routines specific to content type\n        pw = new PrintWriter(out, true);\n    }\n\n    //  Public client methods\n    public void print(String str) {\n        pw.print(str);\n    }\n\n    public void print(int n) {\n        pw.print(n);\n    }\n\n    public void println(String str) {\n        pw.println(str);\n    }\n\n    public void println(int n) {\n        pw.println(n);\n    }\n\n    public void flush() throws IOException {\n        response.setContentType(\"text/html\");\n        response.setContentLength(baos.size());\n        OutputStream os = response.getOutputStream();\n        baos.writeTo(os);\n        os.flush();\n        reset();\n    }\n\n    public int getSize() {\n        return baos.size();\n    }\n\n    public PrintWriter getPW() {\n        return pw;\n    }\n\n    /**\n     * @author James Stauffer\n     * @return String the contents of the buffer.\n     */\n    public String reset() {\n        String contents = baos.toString();\n        baos.reset();\n        return contents;\n    }\n\n    public String toString() {\n        return getClass().getName() + \": [size=\" + getSize() + \", response=\" + response + ((baos != null) ? \", baos\" : \"\") + ((pw != null) ? \", pw\" : \"\") + \"]\";\n    }\n\n    //  Private instance variables\n    private HttpServletResponse response = null;\n\n    private boolean binary = false;\n\n    private ByteArrayOutputStream baos = null;\n\n    private PrintWriter pw = null;\n}\n",
    "test_prompt": "// HTMLOutputStreamTest.java\npackage bible.servlet;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTMLOutputStream}.\n* It contains one unit test case for the {@link HTMLOutputStream#reset()} method.\n*/\nclass HTMLOutputStreamTest {",
    "time_taken": 51.45231342315674,
    "usage": {
        "prompt_tokens": 743
    }
},
{
    "choices": [
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t   \n    /**\n     * Constructor for test class Queue_0Test.\n     * @todo  change constructor name\n     */\n    Queue_0Test(){\n    }\n\t\n\t@Test public void test() {\n\t\tNode i1 = new Node();\n\t\tNode i2 = new Node();\n\t\tNode i3 = new Node();\n\t\tNode i1b = new Node();\n\t\tNode i2a = new Node();\n\t\tNode i2b = new Node();\n\t\tNode i1c = new Node();\n\t\tNode i1d = new Node();\n\t\tNode i2e = new Node();\n\t\tNode i2f = new Node();\n\t\tNode i2g = new Node();\n\t\tNode i3c = new Node();\n\t\tNode i3d = new Node();\n\t\tNode i3e = new Node();\n\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t\n\t\t/**\n\t\t* Test class for {@link Queue#dequeue()} method.\n\t\t* We are testing the functions {@link Queue#isFull()} and {@link Queue#remove()}.\n\t\t*/\n\t\t@Test\n        public void dequeue_1() {\n\t\t\tQueue queue = new Queue();\n\t\t\tObject obj = queue.remove();\n\t\t\tassertNull(obj);\n\t\t\tSystem.out.println(\"Removed object successfully\");\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test class for {@link Queue#remove()} and {@link Queue#addDelayed()}\n\t\t* methods.\n\t\t* We are testing the functions:\n\t\t* {@link Queue#clear()},\n\t\t* {@link Queue#contains()},\n\t\t* {@link Queue#peek()},\n\t\t* {@link Queue#peekDelayed()},\n\t\t*/\n\t\t@Test\n        public void queue_2() {\n\t\t\tSet set = new HashSet();\n\t\t\tQueue queue = new Queue(2",
            "finish_reason": "length"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t@Test\n\t\tpublic void test() {\n\t\t\tQueue queue = new Queue();\n\t\t\tqueue.remove(1);\n\t\t\tassertEquals(1, queue.getNumberItems());\n\t\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t\n    @Test\n    public void test_dequeue(){\n        Queue queue = new Queue(2);\n        assertEquals(\"0\", queue.dequeue().toString());\n    }\n\t\t\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\tpublic queue dequeue() {\n\t\t    queue myQueue = new queue();\n\t\t    synchronized (dequeuedObjects) {\n\t\t        dequeuedObjects.put(myQueue, new Object());\n\t\t    }\n\t\t    return myQueue;\n\t\t}\n\n    @Test\n    public void dequeue() {\n        queue deq = dequeue();\n        synchronized (dequeuedObjects) {\n            dequeuedObjects.put(deq, new Object());\n        }\n\n        assertSame(\"1st node must be Node\", deq,  deq.first);\n        assertNull(\"2nd node must be Node\", deq.last);\n  }\n}\n\n/**\n* A class whose main function is testQueue_0.java\n*/\nclass queue{ \n\n    /**\n    * Number of items in the queue\n    */\n    int nrItems;\n\n    /**\n    * Max number of items in the queue.\n    */\n    int maxNumItems;\n\n    /** \n     * Constructor\n     */\n    ",
            "finish_reason": "length"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t\n\t// Test cases\n\tstatic double check(Queue queue) {\n\t\tfor (Node node = queue.first; node!= null; node = node.next) {\n\t\t\tdouble x = getX(node);\n\t\t\tassertTrue(Math.abs(x) <= 1.0);\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// get_x() for a Node\n\tstatic double getX(Node node) {\n\t\tdouble x = 1.0 * node.value;\n\t\treturn x;\n\t}\n\t\n\t// set_x() for a Node\n\tstatic double setX(Node node, double x) {\n\t\tnode.value = x;\n\t\treturn x;\n\t}\n\t\n\t// remove_nodes() for a Queue\n\tstatic int removeNodes(Queue queue) {\n\t\tint remainingNodes = 0; \n\t\tNode first = queue.first;\n\t\twhile ((first!= null) && ( remainingNodes < 10)) {\n\t\t\t// get Node\n\t\t\tNode curr = first;\n\t\t\t// get next Node",
            "finish_reason": "length"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t\n\t@Test\n    public void testDequeue() {\n\n        Queue<String> queue = new Queue<>();\n\n        assertNull(queue.first);\n        assertNull(queue.last);\n\n        queue.enqueue(\"First\");\n        queue.enqueue(\"Second\");\n\n        assertNotNull(queue.first);\n        assertNotNull(queue.last);\n\n\n        assertEquals(\"Second\",queue.first.value);\n        assertEquals(\"First\",queue.last.value);\n\n    }\n\n    @Test\n    public void testMaximumpCapacity() {\n\n        Queue<String> queue = new Queue<>();\n\n        queue.enqueue(\"First\");\n        queue.enqueue(\"Second\");\n\n        assertEquals(10,queue.maxCapacity() - 1);\n\n    }\n\n\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t\n    /**\n     * Test\n     *\n     * @see Queue\n     * @see Queue#Queue_0Test\n     */\n    @Test\n    public void test_dequeue() {\n        \n        Queue queue = new Queue();\n        queue.dequeue(\"0\");\n        // assert that nothing was dequeued\n        System.out.println(queue);\n        \n        queue.dequeue(\"1\");\n        // assert that there was 1 uneddeu\n        System.out.println(queue);\n\t\n\t}\n\t\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\t\n    /**\n     * Checks for the maximum number of items in the queue.\n     * If it is 10 elements and it fits in the queue we should return 10.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n\t@Test\n    public void checkMaxItems() {\n        Queue q = new Queue();\n        if (q.size() >= 10) {\n            int i = q.remove(10);\n            assertTrue(\"dequeue(10) is missing\", i == 10);\n        }\n    }\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {\n\t\tprivate final static long TEST_SEED = 77823456645L;\n\t\tprivate static int COUNT = 2;\n\t\tprivate final static List<List<String[]>> EXAMPLES;\n\t\tstatic {\n\t\t\tList<List<String[]>> arrayList = new ArrayList<List<String[]>>();\n\t\t\tarrayList.add(new ArrayList<String[]>());\n\t\t\tfor (int i = 0; i < COUNT; i++) {\n\t\t\t\tarrayList.add(new ArrayList<String[]>());\n\t\t\t}\n\t\t\tArrayList<List<String[]>> tempArrayList = new ArrayList<List<String[]>>();\n\t\t\tList<List<String[]>> tempList = new ArrayList<List<String[]>>();\n\t\t\tfor (int i = 0; i < COUNT; i++) {\n\t\t\t\tArrayList<String[]> e = new ArrayList<String[]>();\n\t\t\t\tfor (int j = 0; j < COUNT; j++) {\n\t\t\t\t\te.add(\"\" + i + \" \" + j + \"  \");\n\t\t\t\t}\n\t\t\t\t",
            "finish_reason": "length"
        }
    ],
    "id": "29a7dd78-96fe-42d8-9555-806ab4eec1c1",
    "prompt_id": "/EvoSuiteBenchmark/original/68_biblestudy/src/main/java/bible/util/Queue_0Test.java",
    "original_code": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject != null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first != null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next != null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i != null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity != NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n",
    "test_prompt": "// Queue_0Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#dequeue()} method.\n*/\nclass Queue_0Test {",
    "time_taken": 13.395139217376709,
    "usage": {
        "prompt_tokens": 1807
    }
},
{
    "choices": [
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t\n  @Test\n  public void testMaxCapacityExceeded() {\n    Queue queue = new Queue();\n    assertEquals(\"The queue should not have maxCapacityExceeded.\",\n                 NO_MAXIMUM, queue.maxCapacityExceeded());\n  }\n  \n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\tpublic static final String testCase = \"TestQueue\";\n\t\t/**\n\t\t * Test maximum capacity was reached during the test.\n\t\t */\n\t\t@Test\n\t\tpublic void testMaxCapacityExceeded() {\n\t\t\tQueue queue = new Queue(5);\n\t\t\tString msg = \"Max capacity exceeded, queue \" + testCase + \". getObjects() = \" + queue.getObjects();\n\t\t\tassertTrue(queue.maxCapacityExceeded());\n\t\t\tmsg = \"Queue is not empty, queue \" + testCase + \". maxCapacity was  0 \";\n\t\t\tassertEquals(0, queue.getNumberItems());\n\t\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t/**\n\t\t* Create an instance of {@link Queue}\n\t\t*/\n\t\tpublic Queue_2Test() {\n    }\n\n    /**\n     * Run unit test case for {@link Queue#maxCapacityExceeded()} method.\n     */\n    @Test\n    public void maxCapacity_setTest() {\n        Queue q = new Queue();\n        q.maxCapacityExceeded();\n        assertTrue(\"returned null value should not be null\", q.maxCapacityExceeded()!= null);\n    }\n\n    /**\n     * Run unit test case for {@link Queue#maxCapacityExceeded()} method.\n     */\n    @Test\n    public void maxCapacity_addObject_returnedObject() {\n        Queue q = new Queue();\n        Assert.assertTrue(\"first node was not added correctly\", q.maxCapacityExceeded().equals(q.getObjects()));\n    }\n\n    /**\n     * Run unit test case for {@link Queue",
            "finish_reason": "length"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t/**\n\t\t * No unit tests on this class.\n\t\t */\n    @Test\n    public void maxCapacityExceeded() {\n        assertEquals(NO_MAXIMUM, Queue.maxCapacityExceeded());\n    }\n}\n// Queue_2Test.java",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t/**\n\t\t  *  Test method for {@link Queue#maxCapacityExceeded()}.\n\t\t  *  Tests if the queue is set up properly.\n\t\t  */\n\t\t@Test\n\t\tpublic void testMaxCapacityExceeded() {\n\t\t\t// Set up Queue\n            Queue queue = new Queue(2000);\n            Node l;\n            Node h;\n\t\t\t// insert a value to the queue and the following tests the expected outcome\n            // The node inserted value is always the last one in the queue, but if the\n            //  queue is not set up properly then its value is the first value and\n            //  we should not get a null node in some situation,\n            assertTrue(\"The queue was not set up properly.\", queue.isEmpty());\n            queue.add(10);\n            queue.add(1);\n            queue.add(2);\n            queue.add(3);\n            queue.add(4);\n            queue.add(5);\n            queue.add(6);\n            queue.add(5);",
            "finish_reason": "length"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t/**\n\t\t * Test for queue max capacity.\n\t\t */\n\t\t@Test\n        void testMaxCapacityExceeded() {\n            Queue queue = new Queue();\n            // we expect to get an infinite result\n            assertEquals(queue.maxCapacityExceeded(), NO_MAXIMUM);\n            // but one result has been gotten which means the queue\n            // is full  (and its cap is not)\n            assertEquals(queue.maxCapacityExceeded(), NO_MAXIMUM);\n            // but one result has been gotten which means the queue is full\n            queue.refreshElement(null);\n            assertEquals(queue.maxCapacityExceeded(), 0);\n            queue.maxCapacityExceeded();\n            // and one more element should have been added\n            assertEquals(queue.maxCapacityExceeded(), 1);\n\t\t}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t\n\tprivate final static String TEST_FILE_QUEUE = \"C:/Users/LaMoine/Desktop/Bible/unittestdata/Queue.java\";\n\tprivate final static String TEST_FILE_QUEUE_2 = \"C:/Users/LaMoine/Desktop/Bible/unittestdata/Queue_2.java\";\n\t\n\t@Test\n\tvoid maxCapacityExceeded_NoChange(){\n\t\tassertEquals(true, Queue_.maxCapacityExceeded());\n\t}\n\t\n\t@Test\n\tvoid maxCapacityExceeded_Replace(){\n\t\tQueue_.maxCapacityExceeded();\n\t\tQueue_.maxCapacityExceeded();\n\t}\n\t\n\t@Test\n\tvoid maxCapacityExceeded_WithChange(){\n\t\ttry {\n\t\t\tQueue_.maxCapacityExceeded();\n\t\t} catch (Exception ex) {}\n\t}\n\t\n\t@Test\n\tvoid maxCapacityExceededNoChange(){\n\t\tQueue_.maxCapacityExceeded();",
            "finish_reason": "length"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t\n\t/*\n\t * private variables\n\t */\n\tprivate static final int NUM_ITEMS = 3;\n\tprivate static final int MAX_CAPACITY = 8;\n\n\tprivate static final String TAG = \"Queue_2Test\";\n\n\t/*\n\t * public test cases\n\t */\n\t@Test\n\tpublic void testMaxCapacityExceeded() throws Exception {\n\t\tQueue queue = new Queue(MAX_CAPACITY);\n\t\tqueue.refreshElement(new Long(3L));\n\t\tSystem.out.println(\"maxCapacityExceeded\");\n\t\tassertTrue(queue.maxCapacityExceeded());\n\t}\n\n\t@Test\n\tpublic void testEmpty() throws Exception {\n\t}\n\n\t@Test\n\tpublic void testAddAndGet() throws Exception {}\n}",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\t\n\t@Test\n\tvoid testMaxCapacityExceeded() {\n\t\tSystem.out.println(\"\\n\\n*** Test maxCapacityExceeded() ***\\n\\n\");\n\t\tQueue_2 queue = new Queue(1000000);\n\t\tqueue.refreshElement((new Integer(1000000)));\n\t\tif (!queue.maxCapacityExceeded()) {\n\t\t\tfail(\"Test maxCapacityExceeded failed\");\n\t\t}\n\t}\n}\n",
            "finish_reason": "stop"
        },
        {
            "text": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject!= null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first!= null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next!= null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i!= null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity!= NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n\n// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {\n\t\tQueue_2Test() {\n\t\t}\n\n    @Test\n    void maxCapacityExceeded() {\n        // This test is a no-op because queue is inited to maxCapacity of NO_MAXIMUM\n        assertTrue(Queue_2Test.maxCapacityExceeded() == false);\n    }\n\n\t@Test\n\tvoid put() {\n\t\t// empty queue\n\t\tQueue<String> queue = new Queue<String>();\n\t\tassertEquals(\"queue.numItems\", 0, queue.getNumberItems());\n\n\t\t// store random items in queue\n\t\tint i;             // index value\n\t\tObject obj;          // object from random collection collection\n\t\tRandom generator = new Random();\n\t\ti = 0;\n\t\twhile (i < 100) {\n\t\t\tobj = generator.nextElement();\n\t\t\tqueue.add(obj.toString());\n\t\t\ti++;\n\t\t}\n\t\t// assert queue.numItems == i:\n\t    assertEquals(\"queue.numItems\", i, queue.getNumberItems());\n\t}\n\n\t@",
            "finish_reason": "length"
        }
    ],
    "id": "ccc7af86-9366-4973-8dc2-1753d49638ac",
    "prompt_id": "/EvoSuiteBenchmark/original/68_biblestudy/src/main/java/bible/util/Queue_2Test.java",
    "original_code": "// Queue.java\npackage bible.util;\n\nimport java.util.*;\n\n/**\n * Queue is a storage class to link together <b>Node</b> objects which are\n * stored in a first in first out storage system.\n *\n * @see Node\n * @version   1.0\n * @author    LaMoine Zielieke, James Stauffer\n */\npublic class Queue {\n\n    public final static int NO_MAXIMUM = -1;\n\n    /**\n     * number of items in this list\n     */\n    private int numItems;\n\n    private int maxNumItems;\n\n    private int maxCapacity;\n\n    /**\n     * first Node in list\n     */\n    private Node first;\n\n    /**\n     * last Node in list\n     */\n    private Node last;\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue() {\n        this(NO_MAXIMUM);\n    }\n\n    /**\n     * Constructor creating an empty Queue.  All variables are set to zero\n     * or null.\n     */\n    public Queue(int capacity) {\n        first = null;\n        last = null;\n        numItems = 0;\n        maxNumItems = 0;\n        maxCapacity = capacity;\n    }\n\n    /**\n     * See if the queue is empty.\n     * @return     <code>true</code> if Queue is empty;\n     *             <code>false</code> otherwise.\n     */\n    public boolean isEmpty() {\n        return (first == null);\n    }\n\n    /**\n     * Insert an object into the end of the queue\n     *\n     * @param someObject  the Object to store\n     */\n    public void enqueue(Object someObject) {\n        if (someObject != null) {\n            Node newNode = new Node(someObject);\n            synchronized (this) {\n                //System.out.println(\"+++\" + someObject);\n                if (isEmpty()) {\n                    first = newNode;\n                    last = newNode;\n                } else {\n                    //Add at end\n                    last.next = newNode;\n                    last = newNode;\n                }\n                numItems++;\n                if (numItems > maxNumItems) {\n                    maxNumItems = numItems;\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove an object from the front of the Queue\n     *\n     * @return       Object if Queue is not empty\n     *               otherwise print message to dos window\n     * @see GameQuestion\n     */\n    public synchronized Object dequeue() {\n        Object obj = null;\n        if (isEmpty()) {\n            System.out.println(\"Cannot remove when queue is empty\");\n        } else if (first == last) {\n            // first see if we only have one item in the queue\n            obj = first.value;\n            first = null;\n            last = null;\n        } else {\n            obj = first.value;\n            first = first.next;\n        }\n        numItems--;\n        return obj;\n    }\n\n    /**\n     *  Removes all nodes where Node.value.equals(object).\n     */\n    public synchronized int remove(Object object) {\n        //System.out.println(\"---\" + object);\n        int originalNumItems = numItems;\n        while ((first != null) && (first.value.equals(object))) {\n            // found it\n            first = first.next;\n            numItems--;\n        }\n        if (first == null) {\n            //All elements removed\n            last = null;\n        } else {\n            //Now it isn't in the first node\n            for (Node current = first; current.next != null; ) {\n                if (current.next.value.equals(object)) {\n                    // found it in the next Node\n                    current.next = current.next.next;\n                    numItems--;\n                    if (current.next == null) {\n                        // we are removing the last element\n                        last = current;\n                        // the for loop will be exited\n                    }\n                } else {\n                    current = current.next;\n                }\n            }\n            // of for\n        }\n        return originalNumItems - numItems;\n    }\n\n    /**\n     *  Moves element to back of que.\n     */\n    public synchronized void refreshElement(Object object) {\n        remove(object);\n        enqueue(object);\n    }\n\n    /**\n     * See how many items are in the queue.\n     *\n     * @return integer value of number of items in queue\n     */\n    public int getNumberItems() {\n        return numItems;\n    }\n\n    /**\n     * The peak number of items in the Queue.\n     *\n     * @return peak number of items in queue\n     */\n    public int getPeakNumberItems() {\n        return maxNumItems;\n    }\n\n    /**\n     * The Queue is stepped through one node at a time and the\n     * QuestionNumber is inserted into a Vector.This action copies\n     * unused question numbers from queue into temp vector.\n     *\n     * @return   Vector of unused question numbers. In this way when\n     *           a new vector of randomized numbers is created the nunbers\n     *           already in the queue will not be duplicated.  If number\n     *           396 is in the queue we do not want 396 to appear in the\n     *           new randomized vector.  This method is only called in\n     *           <b>DataBase</b>\n     * @see      Database#load\n     * @see      GameQuestion\n     */\n    public Vector getObjects() {\n        Node i;\n        Vector tempVector = new Vector(numItems, 10);\n        for (i = first; i != null; i = i.next) {\n            tempVector.addElement(i.value);\n        }\n        // end for\n        return tempVector;\n    }\n\n    // end getUnused\n    /**\n     *  Returns true if the first should be removed.\n     */\n    public boolean maxCapacityExceeded() {\n        return (numItems > (maxCapacity - 1)) && (maxCapacity != NO_MAXIMUM);\n    }\n\n    public String toString() {\n        return getClass().getName() + \":[numItems=\" + numItems + \", maxNumItems=\" + maxNumItems + \", maxCapacity=\" + maxCapacity + \", getObjects()=\" + getObjects() + \"\\r\\n]\";\n    }\n\n    /**\n     * Node objects hold the Object to be stored and the next node in our linked list.\n     * In this way we can access the next node in our <b>Queue</b>.\n     *\n     * @version   2.0\n     * @author    LaMoine Zielieke\n     */\n    class Node {\n\n        /**\n         * The next Node in the chain.\n         */\n        Node next;\n\n        /**\n         * The Object this node stores.\n         */\n        Object value;\n\n        /**\n         * @param  obj   the Object to be inserted into the node.\n         */\n        public Node(Object obj) {\n            value = obj;\n        }\n    }\n}\n",
    "test_prompt": "// Queue_2Test.java\npackage bible.util;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Queue}.\n* It contains one unit test case for the {@link Queue#maxCapacityExceeded()} method.\n*/\nclass Queue_2Test {",
    "time_taken": 13.506017923355103,
    "usage": {
        "prompt_tokens": 1811
    }
}
]