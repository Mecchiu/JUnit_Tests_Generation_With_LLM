ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
1fc93ab8-1e96-4e1d-bad1-29ecbf6b6362,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/FieldInfo_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FieldInfo.java
/**
 * FieldInfo.java 9:05:06 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    private int tagNumber;

    private String name;

    private String dataType;

    private String description;

    private String abbreviation;

    private String overrideXmlName;

    private String baseCategory;

    private String baseCategoryXmlName;

    private String unionDataType;

    private String usesEnumFromTag;

    private String comments;

    private int length;

    private boolean isNotRequiredXml;

    private String deprecatingVersion;

    private List<ComponentInfo> requiringComponents;

    private TreeMap<String, ValueInfo> validValues;

    /**
     * Returns the tagNumber
     *
     * @return the tagNumber
     */
    public int getTagNumber() {
        return tagNumber;
    }

    /**
     * Modifies the tagNumber
     *
     * @param tagNumber - the tagNumber to set
     */
    public void setTagNumber(int tagNumber) {
        this.tagNumber = tagNumber;
    }

    /**
     * Returns the fieldName
     *
     * @return the fieldName
     */
    public String getName() {
        return name;
    }

    /**
     * Modifies the fieldName
     *
     * @param name - the fieldName to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns the dataType
     *
     * @return the dataType
     */
    public String getDataType() {
        return dataType;
    }

    /**
     * Modifies the dataType
     *
     * @param dataType - the dataType to set
     */
    public void setDataType(String dataType) {
        this.dataType = dataType;
    }

    /**
     * Returns the description
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * Modifies the description
     *
     * @param description - the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * Returns the comments
     *
     * @return the comments
     */
    public String getComments() {
        return comments;
    }

    /**
     * Modifies the comments
     *
     * @param comments - the comments to set
     */
    public void setComments(String comments) {
        this.comments = comments;
    }

    /**
     * Returns the abbreviation
     *
     * @return the abbreviation
     */
    public String getAbbreviation() {
        return abbreviation;
    }

    /**
     * Modifies the abbreviation
     *
     * @param abbreviation - the abbreviation to set
     */
    public void setAbbreviation(String abbreviation) {
        this.abbreviation = abbreviation;
    }

    /**
     * Returns the overrideXmlName
     *
     * @return the overrideXmlName
     */
    public String getOverrideXmlName() {
        return overrideXmlName;
    }

    /**
     * Modifies the overrideXmlName
     *
     * @param overrideXmlName - the overrideXmlName to set
     */
    public void setOverrideXmlName(String overrideXmlName) {
        this.overrideXmlName = overrideXmlName;
    }

    /**
     * Returns the baseCategory
     *
     * @return the baseCategory
     */
    public String getBaseCategory() {
        return baseCategory;
    }

    /**
     * Modifies the baseCategory
     *
     * @param baseCategory - the baseCategory to set
     */
    public void setBaseCategory(String baseCategory) {
        this.baseCategory = baseCategory;
    }

    /**
     * Returns the baseCategoryXmlName
     *
     * @return the baseCategoryXmlName
     */
    public String getBaseCategoryXmlName() {
        return baseCategoryXmlName;
    }

    /**
     * Modifies the baseCategoryXmlName
     *
     * @param baseCategoryXmlName - the baseCategoryXmlName to set
     */
    public void setBaseCategoryXmlName(String baseCategoryXmlName) {
        this.baseCategoryXmlName = baseCategoryXmlName;
    }

    /**
     * Returns the unionDataType
     *
     * @return the unionDataType
     */
    public String getUnionDataType() {
        return unionDataType;
    }

    /**
     * Modifies the unionDataType
     *
     * @param unionDataType - the unionDataType to set
     */
    public void setUnionDataType(String unionDataType) {
        this.unionDataType = unionDataType;
    }

    /**
     * Returns the usesEnumFromTag
     *
     * @return the usesEnumFromTag
     */
    public String getUsesEnumFromTag() {
        return usesEnumFromTag;
    }

    /**
     * Modifies the usesEnumFromTag
     *
     * @param usesEnumFromTag - the usesEnumFromTag to set
     */
    public void setUsesEnumFromTag(String usesEnumFromTag) {
        this.usesEnumFromTag = usesEnumFromTag;
    }

    /**
     * Returns the length
     *
     * @return the length
     */
    public int getLength() {
        return length;
    }

    /**
     * Modifies the length
     *
     * @param length - the length to set
     */
    public void setLength(int length) {
        this.length = length;
    }

    /**
     * Returns the isNotRequiredXml
     *
     * @return the isNotRequiredXml
     */
    public boolean isNotRequiredXml() {
        return isNotRequiredXml;
    }

    /**
     * Modifies the isNotRequiredXml
     *
     * @param isNotRequiredXml - the isNotRequiredXml to set
     */
    public void setNotRequiredXml(boolean isNotRequiredXml) {
        this.isNotRequiredXml = isNotRequiredXml;
    }

    /**
     * Returns the deprecatingVersion
     *
     * @return the deprecatingVersion
     */
    public String getDeprecatingVersion() {
        return deprecatingVersion;
    }

    /**
     * Modifies the deprecatingVersion
     *
     * @param deprecatingVersion - the deprecatingVersion to set
     */
    public void setDeprecatingVersion(String deprecatingVersion) {
        this.deprecatingVersion = deprecatingVersion;
    }

    /**
     * Returns the requiringComponents
     *
     * @return the requiringComponents
     */
    public List<ComponentInfo> getRequiringComponents() {
        return requiringComponents;
    }

    /**
     * Add a requiringComponent
     *
     * @param component - a requiringComponent
     */
    public void addRequiringComponent(ComponentInfo component) {
        if (requiringComponents == null) {
            requiringComponents = new ArrayList<ComponentInfo>();
        }
        requiringComponents.add(component);
    }

    /**
     * Modifies the requiringComponents
     *
     * @param requiringComponents - the requiringComponent to set
     */
    protected void setRequiringComponents(List<ComponentInfo> requiringComponents) {
        this.requiringComponents = requiringComponents;
    }

    /**
     * Returns whether this field is required in the specified component
     *
     * @param component - a component
     * @return whether this field is required in the specified component
     */
    public boolean isRequiredInComponent(ComponentInfo component) {
        if (requiringComponents != null) {
            return requiringComponents.contains(component);
        } else {
            return false;
        }
    }

    /**
     * Returns the validValues
     *
     * @return the validValues
     */
    public List<ValueInfo> getValidValues() {
        if (validValues != null) {
            return new ArrayList<ValueInfo>(validValues.values());
        } else {
            return null;
        }
    }

    /**
     * Adds a value
     *
     * @param value - a value
     */
    public void addValidValue(ValueInfo value) {
        if (validValues == null) {
            validValues = new TreeMap<String, ValueInfo>();
        }
        validValues.put(value.getValue(), value);
    }

    /**
     * Returns whether a given value is valid
     *
     * @param value - a value
     * @return whether a given value is valid
     */
    public boolean isValidValue(String value) {
        return validValues.keySet().contains(value);
    }

    /**
     * Modifies the validValues
     *
     * @param validValues - the validValues to set
     */
    protected void setValidValues(TreeMap<String, ValueInfo> validValues) {
        this.validValues = validValues;
    }

    /**
     * Returns the validValues Map
     *
     * @return the validValues Map
     */
    protected TreeMap<String, ValueInfo> getValidValuesMap() {
        return validValues;
    }
}
","// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {","// FieldInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isRequiredInComponent(ComponentInfo)} method.
*/
class FieldInfo_0Test {
"
9925015d-bc59-4c15-89c6-17e2ee276934,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/FieldInfo_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FieldInfo.java
/**
 * FieldInfo.java 9:05:06 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a Field as defined by the FIX specification.
 *
 * @author jramoyo
 */
public class FieldInfo implements FixInfo {

    private int tagNumber;

    private String name;

    private String dataType;

    private String description;

    private String abbreviation;

    private String overrideXmlName;

    private String baseCategory;

    private String baseCategoryXmlName;

    private String unionDataType;

    private String usesEnumFromTag;

    private String comments;

    private int length;

    private boolean isNotRequiredXml;

    private String deprecatingVersion;

    private List<ComponentInfo> requiringComponents;

    private TreeMap<String, ValueInfo> validValues;

    /**
     * Returns the tagNumber
     *
     * @return the tagNumber
     */
    public int getTagNumber() {
        return tagNumber;
    }

    /**
     * Modifies the tagNumber
     *
     * @param tagNumber - the tagNumber to set
     */
    public void setTagNumber(int tagNumber) {
        this.tagNumber = tagNumber;
    }

    /**
     * Returns the fieldName
     *
     * @return the fieldName
     */
    public String getName() {
        return name;
    }

    /**
     * Modifies the fieldName
     *
     * @param name - the fieldName to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns the dataType
     *
     * @return the dataType
     */
    public String getDataType() {
        return dataType;
    }

    /**
     * Modifies the dataType
     *
     * @param dataType - the dataType to set
     */
    public void setDataType(String dataType) {
        this.dataType = dataType;
    }

    /**
     * Returns the description
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * Modifies the description
     *
     * @param description - the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * Returns the comments
     *
     * @return the comments
     */
    public String getComments() {
        return comments;
    }

    /**
     * Modifies the comments
     *
     * @param comments - the comments to set
     */
    public void setComments(String comments) {
        this.comments = comments;
    }

    /**
     * Returns the abbreviation
     *
     * @return the abbreviation
     */
    public String getAbbreviation() {
        return abbreviation;
    }

    /**
     * Modifies the abbreviation
     *
     * @param abbreviation - the abbreviation to set
     */
    public void setAbbreviation(String abbreviation) {
        this.abbreviation = abbreviation;
    }

    /**
     * Returns the overrideXmlName
     *
     * @return the overrideXmlName
     */
    public String getOverrideXmlName() {
        return overrideXmlName;
    }

    /**
     * Modifies the overrideXmlName
     *
     * @param overrideXmlName - the overrideXmlName to set
     */
    public void setOverrideXmlName(String overrideXmlName) {
        this.overrideXmlName = overrideXmlName;
    }

    /**
     * Returns the baseCategory
     *
     * @return the baseCategory
     */
    public String getBaseCategory() {
        return baseCategory;
    }

    /**
     * Modifies the baseCategory
     *
     * @param baseCategory - the baseCategory to set
     */
    public void setBaseCategory(String baseCategory) {
        this.baseCategory = baseCategory;
    }

    /**
     * Returns the baseCategoryXmlName
     *
     * @return the baseCategoryXmlName
     */
    public String getBaseCategoryXmlName() {
        return baseCategoryXmlName;
    }

    /**
     * Modifies the baseCategoryXmlName
     *
     * @param baseCategoryXmlName - the baseCategoryXmlName to set
     */
    public void setBaseCategoryXmlName(String baseCategoryXmlName) {
        this.baseCategoryXmlName = baseCategoryXmlName;
    }

    /**
     * Returns the unionDataType
     *
     * @return the unionDataType
     */
    public String getUnionDataType() {
        return unionDataType;
    }

    /**
     * Modifies the unionDataType
     *
     * @param unionDataType - the unionDataType to set
     */
    public void setUnionDataType(String unionDataType) {
        this.unionDataType = unionDataType;
    }

    /**
     * Returns the usesEnumFromTag
     *
     * @return the usesEnumFromTag
     */
    public String getUsesEnumFromTag() {
        return usesEnumFromTag;
    }

    /**
     * Modifies the usesEnumFromTag
     *
     * @param usesEnumFromTag - the usesEnumFromTag to set
     */
    public void setUsesEnumFromTag(String usesEnumFromTag) {
        this.usesEnumFromTag = usesEnumFromTag;
    }

    /**
     * Returns the length
     *
     * @return the length
     */
    public int getLength() {
        return length;
    }

    /**
     * Modifies the length
     *
     * @param length - the length to set
     */
    public void setLength(int length) {
        this.length = length;
    }

    /**
     * Returns the isNotRequiredXml
     *
     * @return the isNotRequiredXml
     */
    public boolean isNotRequiredXml() {
        return isNotRequiredXml;
    }

    /**
     * Modifies the isNotRequiredXml
     *
     * @param isNotRequiredXml - the isNotRequiredXml to set
     */
    public void setNotRequiredXml(boolean isNotRequiredXml) {
        this.isNotRequiredXml = isNotRequiredXml;
    }

    /**
     * Returns the deprecatingVersion
     *
     * @return the deprecatingVersion
     */
    public String getDeprecatingVersion() {
        return deprecatingVersion;
    }

    /**
     * Modifies the deprecatingVersion
     *
     * @param deprecatingVersion - the deprecatingVersion to set
     */
    public void setDeprecatingVersion(String deprecatingVersion) {
        this.deprecatingVersion = deprecatingVersion;
    }

    /**
     * Returns the requiringComponents
     *
     * @return the requiringComponents
     */
    public List<ComponentInfo> getRequiringComponents() {
        return requiringComponents;
    }

    /**
     * Add a requiringComponent
     *
     * @param component - a requiringComponent
     */
    public void addRequiringComponent(ComponentInfo component) {
        if (requiringComponents == null) {
            requiringComponents = new ArrayList<ComponentInfo>();
        }
        requiringComponents.add(component);
    }

    /**
     * Modifies the requiringComponents
     *
     * @param requiringComponents - the requiringComponent to set
     */
    protected void setRequiringComponents(List<ComponentInfo> requiringComponents) {
        this.requiringComponents = requiringComponents;
    }

    /**
     * Returns whether this field is required in the specified component
     *
     * @param component - a component
     * @return whether this field is required in the specified component
     */
    public boolean isRequiredInComponent(ComponentInfo component) {
        if (requiringComponents != null) {
            return requiringComponents.contains(component);
        } else {
            return false;
        }
    }

    /**
     * Returns the validValues
     *
     * @return the validValues
     */
    public List<ValueInfo> getValidValues() {
        if (validValues != null) {
            return new ArrayList<ValueInfo>(validValues.values());
        } else {
            return null;
        }
    }

    /**
     * Adds a value
     *
     * @param value - a value
     */
    public void addValidValue(ValueInfo value) {
        if (validValues == null) {
            validValues = new TreeMap<String, ValueInfo>();
        }
        validValues.put(value.getValue(), value);
    }

    /**
     * Returns whether a given value is valid
     *
     * @param value - a value
     * @return whether a given value is valid
     */
    public boolean isValidValue(String value) {
        return validValues.keySet().contains(value);
    }

    /**
     * Modifies the validValues
     *
     * @param validValues - the validValues to set
     */
    protected void setValidValues(TreeMap<String, ValueInfo> validValues) {
        this.validValues = validValues;
    }

    /**
     * Returns the validValues Map
     *
     * @return the validValues Map
     */
    protected TreeMap<String, ValueInfo> getValidValuesMap() {
        return validValues;
    }
}
","// FieldInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isValidValue(String)} method.
*/
class FieldInfo_1Test {","// FieldInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FieldInfo}.
* It contains one unit test case for the {@link FieldInfo#isValidValue(String)} method.
*/
class FieldInfo_1Test {
"
2749957e-1d07-4518-8c03-0617d83283af,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DictionaryInfo.java
/**
 * DictionaryInfo.java 11:33:45 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
        this.version = version;
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields() {
        if (fieldsByTagNumber != null) {
            return new ArrayList<FieldInfo>(fieldsByTagNumber.values());
        }
        return null;
    }

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field) {
        if (fieldsByTagNumber == null) {
            fieldsByTagNumber = new TreeMap<Integer, FieldInfo>();
            fieldsByName = new TreeMap<String, FieldInfo>();
        }
        fieldsByTagNumber.put(field.getTagNumber(), field);
        fieldsByName.put(field.getName(), field);
    }

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents() {
        if (componentsByName != null) {
            return new ArrayList<ComponentInfo>(componentsByName.values());
        }
        return null;
    }

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component) {
        if (componentsByName == null) {
            componentsByName = new TreeMap<String, ComponentInfo>();
            componentsById = new TreeMap<Integer, ComponentInfo>();
        }
        componentsByName.put(component.getName(), component);
        componentsById.put(component.getId(), component);
    }

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group) {
        fieldsByTagNumber.put(field.getTagNumber(), group);
        fieldsByName.put(field.getName(), group);
    }

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }

    public List<MessageInfo> getMessages() {
        return new ArrayList<MessageInfo>(messagesById.values());
    }

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message) {
        if (messagesByName == null) {
            messagesByName = new TreeMap<String, MessageInfo>();
            messagesById = new TreeMap<Integer, MessageInfo>();
        }
        messagesById.put(message.getId(), message);
        messagesByName.put(message.getName(), message);
    }

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount() {
        loadCount++;
    }

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded() {
        return loadCount == 5;
    }
}
","// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {","// DictionaryInfo_0Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(int)} method.
*/
class DictionaryInfo_0Test {
"
fdfef43b-3567-4d8c-8367-ccdffb53e817,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DictionaryInfo.java
/**
 * DictionaryInfo.java 11:33:45 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
        this.version = version;
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields() {
        if (fieldsByTagNumber != null) {
            return new ArrayList<FieldInfo>(fieldsByTagNumber.values());
        }
        return null;
    }

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field) {
        if (fieldsByTagNumber == null) {
            fieldsByTagNumber = new TreeMap<Integer, FieldInfo>();
            fieldsByName = new TreeMap<String, FieldInfo>();
        }
        fieldsByTagNumber.put(field.getTagNumber(), field);
        fieldsByName.put(field.getName(), field);
    }

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents() {
        if (componentsByName != null) {
            return new ArrayList<ComponentInfo>(componentsByName.values());
        }
        return null;
    }

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component) {
        if (componentsByName == null) {
            componentsByName = new TreeMap<String, ComponentInfo>();
            componentsById = new TreeMap<Integer, ComponentInfo>();
        }
        componentsByName.put(component.getName(), component);
        componentsById.put(component.getId(), component);
    }

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group) {
        fieldsByTagNumber.put(field.getTagNumber(), group);
        fieldsByName.put(field.getName(), group);
    }

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }

    public List<MessageInfo> getMessages() {
        return new ArrayList<MessageInfo>(messagesById.values());
    }

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message) {
        if (messagesByName == null) {
            messagesByName = new TreeMap<String, MessageInfo>();
            messagesById = new TreeMap<Integer, MessageInfo>();
        }
        messagesById.put(message.getId(), message);
        messagesByName.put(message.getName(), message);
    }

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount() {
        loadCount++;
    }

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded() {
        return loadCount == 5;
    }
}
","// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {","// DictionaryInfo_1Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getField(String)} method.
*/
class DictionaryInfo_1Test {
"
6daa5619-1c26-4ce4-925d-f4f46b84026d,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DictionaryInfo.java
/**
 * DictionaryInfo.java 11:33:45 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
        this.version = version;
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields() {
        if (fieldsByTagNumber != null) {
            return new ArrayList<FieldInfo>(fieldsByTagNumber.values());
        }
        return null;
    }

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field) {
        if (fieldsByTagNumber == null) {
            fieldsByTagNumber = new TreeMap<Integer, FieldInfo>();
            fieldsByName = new TreeMap<String, FieldInfo>();
        }
        fieldsByTagNumber.put(field.getTagNumber(), field);
        fieldsByName.put(field.getName(), field);
    }

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents() {
        if (componentsByName != null) {
            return new ArrayList<ComponentInfo>(componentsByName.values());
        }
        return null;
    }

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component) {
        if (componentsByName == null) {
            componentsByName = new TreeMap<String, ComponentInfo>();
            componentsById = new TreeMap<Integer, ComponentInfo>();
        }
        componentsByName.put(component.getName(), component);
        componentsById.put(component.getId(), component);
    }

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group) {
        fieldsByTagNumber.put(field.getTagNumber(), group);
        fieldsByName.put(field.getName(), group);
    }

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }

    public List<MessageInfo> getMessages() {
        return new ArrayList<MessageInfo>(messagesById.values());
    }

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message) {
        if (messagesByName == null) {
            messagesByName = new TreeMap<String, MessageInfo>();
            messagesById = new TreeMap<Integer, MessageInfo>();
        }
        messagesById.put(message.getId(), message);
        messagesByName.put(message.getName(), message);
    }

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount() {
        loadCount++;
    }

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded() {
        return loadCount == 5;
    }
}
","// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {","// DictionaryInfo_2Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(int)} method.
*/
class DictionaryInfo_2Test {
"
b512380e-887a-41d2-ad79-278ab3ff38b8,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DictionaryInfo.java
/**
 * DictionaryInfo.java 11:33:45 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
        this.version = version;
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields() {
        if (fieldsByTagNumber != null) {
            return new ArrayList<FieldInfo>(fieldsByTagNumber.values());
        }
        return null;
    }

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field) {
        if (fieldsByTagNumber == null) {
            fieldsByTagNumber = new TreeMap<Integer, FieldInfo>();
            fieldsByName = new TreeMap<String, FieldInfo>();
        }
        fieldsByTagNumber.put(field.getTagNumber(), field);
        fieldsByName.put(field.getName(), field);
    }

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents() {
        if (componentsByName != null) {
            return new ArrayList<ComponentInfo>(componentsByName.values());
        }
        return null;
    }

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component) {
        if (componentsByName == null) {
            componentsByName = new TreeMap<String, ComponentInfo>();
            componentsById = new TreeMap<Integer, ComponentInfo>();
        }
        componentsByName.put(component.getName(), component);
        componentsById.put(component.getId(), component);
    }

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group) {
        fieldsByTagNumber.put(field.getTagNumber(), group);
        fieldsByName.put(field.getName(), group);
    }

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }

    public List<MessageInfo> getMessages() {
        return new ArrayList<MessageInfo>(messagesById.values());
    }

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message) {
        if (messagesByName == null) {
            messagesByName = new TreeMap<String, MessageInfo>();
            messagesById = new TreeMap<Integer, MessageInfo>();
        }
        messagesById.put(message.getId(), message);
        messagesByName.put(message.getName(), message);
    }

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount() {
        loadCount++;
    }

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded() {
        return loadCount == 5;
    }
}
","// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {","// DictionaryInfo_3Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getComponent(String)} method.
*/
class DictionaryInfo_3Test {
"
cf2cff48-72a0-4f8c-bad6-a95efcdfa730,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_4Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DictionaryInfo.java
/**
 * DictionaryInfo.java 11:33:45 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
        this.version = version;
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields() {
        if (fieldsByTagNumber != null) {
            return new ArrayList<FieldInfo>(fieldsByTagNumber.values());
        }
        return null;
    }

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field) {
        if (fieldsByTagNumber == null) {
            fieldsByTagNumber = new TreeMap<Integer, FieldInfo>();
            fieldsByName = new TreeMap<String, FieldInfo>();
        }
        fieldsByTagNumber.put(field.getTagNumber(), field);
        fieldsByName.put(field.getName(), field);
    }

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents() {
        if (componentsByName != null) {
            return new ArrayList<ComponentInfo>(componentsByName.values());
        }
        return null;
    }

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component) {
        if (componentsByName == null) {
            componentsByName = new TreeMap<String, ComponentInfo>();
            componentsById = new TreeMap<Integer, ComponentInfo>();
        }
        componentsByName.put(component.getName(), component);
        componentsById.put(component.getId(), component);
    }

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group) {
        fieldsByTagNumber.put(field.getTagNumber(), group);
        fieldsByName.put(field.getName(), group);
    }

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }

    public List<MessageInfo> getMessages() {
        return new ArrayList<MessageInfo>(messagesById.values());
    }

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message) {
        if (messagesByName == null) {
            messagesByName = new TreeMap<String, MessageInfo>();
            messagesById = new TreeMap<Integer, MessageInfo>();
        }
        messagesById.put(message.getId(), message);
        messagesByName.put(message.getName(), message);
    }

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount() {
        loadCount++;
    }

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded() {
        return loadCount == 5;
    }
}
","// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {","// DictionaryInfo_4Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(int)} method.
*/
class DictionaryInfo_4Test {
"
8b5c312d-bb32-4db5-b59f-849a3d40fefa,/EvoSuiteBenchmark/original/74_fixsuite/src/main/java/org/fixsuite/message/info/DictionaryInfo_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DictionaryInfo.java
/**
 * DictionaryInfo.java 11:33:45 PM Apr 21, 2008
 *
 * <PRE>
 * Copyright (c) 2008, Jan Amoyo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     - Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     - Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS';
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * </PRE>
 */
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;

/**
 * Represents a FIX version specification. DictionaryInfo acts as a central
 * storage for all items defined in a version.
 *
 * @author jramoyo
 */
public class DictionaryInfo {

    private String version;

    private int loadCount;

    // Default collection
    private TreeMap<String, MessageInfo> messagesByName;

    private TreeMap<Integer, MessageInfo> messagesById;

    // Default collection
    private TreeMap<Integer, FieldInfo> fieldsByTagNumber;

    private TreeMap<String, FieldInfo> fieldsByName;

    // Default collection
    private TreeMap<String, ComponentInfo> componentsByName;

    private TreeMap<Integer, ComponentInfo> componentsById;

    /**
     * Creates a new DictionaryInfo
     *
     * @param version - a version
     */
    public DictionaryInfo(String version) {
        this.version = version;
    }

    /**
     * Returns the fields
     *
     * @return the fields
     */
    public List<FieldInfo> getFields() {
        if (fieldsByTagNumber != null) {
            return new ArrayList<FieldInfo>(fieldsByTagNumber.values());
        }
        return null;
    }

    /**
     * Returns a field given a tagNumber
     *
     * @param tagNumber - a tagNumber
     * @return a field given a tagNumber
     */
    public FieldInfo getField(int tagNumber) {
        if (fieldsByTagNumber != null) {
            return fieldsByTagNumber.get(tagNumber);
        }
        return null;
    }

    /**
     * Returns a field given a name
     *
     * @param name - a name
     * @return a field given a name
     */
    public FieldInfo getField(String name) {
        if (fieldsByName != null) {
            return fieldsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a field
     *
     * @param field - a field
     */
    public void addField(FieldInfo field) {
        if (fieldsByTagNumber == null) {
            fieldsByTagNumber = new TreeMap<Integer, FieldInfo>();
            fieldsByName = new TreeMap<String, FieldInfo>();
        }
        fieldsByTagNumber.put(field.getTagNumber(), field);
        fieldsByName.put(field.getName(), field);
    }

    /**
     * Returns the components
     *
     * @return the components
     */
    public List<ComponentInfo> getComponents() {
        if (componentsByName != null) {
            return new ArrayList<ComponentInfo>(componentsByName.values());
        }
        return null;
    }

    /**
     * Returns a component given an id
     *
     * @param id - an id
     * @return a component given an id
     */
    public ComponentInfo getComponent(int id) {
        if (componentsById != null) {
            return componentsById.get(id);
        }
        return null;
    }

    /**
     * Returns a component given a name
     *
     * @param name - a name
     * @return a component given a name
     */
    public ComponentInfo getComponent(String name) {
        if (componentsByName != null) {
            return componentsByName.get(name);
        }
        return null;
    }

    /**
     * Adds a component
     *
     * @param component
     */
    public void addComponent(ComponentInfo component) {
        if (componentsByName == null) {
            componentsByName = new TreeMap<String, ComponentInfo>();
            componentsById = new TreeMap<Integer, ComponentInfo>();
        }
        componentsByName.put(component.getName(), component);
        componentsById.put(component.getId(), component);
    }

    /**
     * Replace the field by a group. This is used by FPL parsers which cannot
     * tell if a field is a group just from Fields.xml
     *
     * @param field - a field
     * @param group - a group
     */
    public void replaceAsGroup(FieldInfo field, GroupInfo group) {
        fieldsByTagNumber.put(field.getTagNumber(), group);
        fieldsByName.put(field.getName(), group);
    }

    /**
     * Returns a message given an id
     *
     * @param id - an id
     * @return a message given an id
     */
    public MessageInfo getMessage(int id) {
        if (messagesById != null) {
            return messagesById.get(id);
        } else {
            return null;
        }
    }

    /**
     * Returns a message given a name
     *
     * @param name - a name
     * @return a message given a name
     */
    public MessageInfo getMessage(String name) {
        if (messagesByName != null) {
            return messagesByName.get(name);
        } else {
            return null;
        }
    }

    public List<MessageInfo> getMessages() {
        return new ArrayList<MessageInfo>(messagesById.values());
    }

    /**
     * Adds a message
     *
     * @param message - a message
     */
    public void addMessage(MessageInfo message) {
        if (messagesByName == null) {
            messagesByName = new TreeMap<String, MessageInfo>();
            messagesById = new TreeMap<Integer, MessageInfo>();
        }
        messagesById.put(message.getId(), message);
        messagesByName.put(message.getName(), message);
    }

    /**
     * Returns the version
     *
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * Modifies the version
     *
     * @param version - the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * Increments the loadCount
     */
    public void incrementLoadCount() {
        loadCount++;
    }

    /**
     * Returns whether the dictionary is loaded
     *
     * @return whether the dictionary is loaded
     */
    public boolean isLoaded() {
        return loadCount == 5;
    }
}
","// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {","// DictionaryInfo_5Test.java
package org.fixsuite.message.info;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DictionaryInfo}.
* It contains one unit test case for the {@link DictionaryInfo#getMessage(String)} method.
*/
class DictionaryInfo_5Test {
"
