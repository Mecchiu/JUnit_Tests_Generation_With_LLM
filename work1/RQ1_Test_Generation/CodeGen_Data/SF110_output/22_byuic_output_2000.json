[
{
    "choices": [
        {
            "finish_reason": "ERROR - CUDA error: device-side assert triggered\nCUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1.",
            "text": ""
        }
    ],
    "id": "c94d152e-2bae-4543-b616-ffe99b3a3c11",
    "prompt_id": "/EvoSuiteBenchmark/original/22_byuic/src/main/java/org/mozilla/javascript/Decompiler.java",
    "original_code": "// Decompiler.java\n/* ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License\n * Version 1.1 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License\n * at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * See the License for the specific language governing rights and\n * limitations under the License.\n *\n * The Original Code is org/mozilla/javascript/Decompiler.java,\n * a component of the Rhino Library ( http://www.mozilla.org/rhino/ )\n * This file is a modification of the Original Code developed\n * for YUI Compressor.\n *\n * The Initial Developer of the Original Code is Mozilla Foundation\n *\n * Copyright (c) 2009 Mozilla Foundation. All Rights Reserved.\n *\n * Contributor(s):  Yahoo! Inc. 2009\n *\n * ***** END LICENSE BLOCK ***** */\npackage org.mozilla.javascript;\n\n/**\n * The following class save decompilation information about the source.\n * Source information is returned from the parser as a String\n * associated with function nodes and with the toplevel script.  When\n * saved in the constant pool of a class, this string will be UTF-8\n * encoded, and token values will occupy a single byte.\n *\n * Source is saved (mostly) as token numbers.  The tokens saved pretty\n * much correspond to the token stream of a 'canonical' representation\n * of the input program, as directed by the parser.  (There were a few\n * cases where tokens could have been left out where decompiler could\n * easily reconstruct them, but I left them in for clarity).  (I also\n * looked adding source collection to TokenStream instead, where I\n * could have limited the changes to a few lines in getToken... but\n * this wouldn't have saved any space in the resulting source\n * representation, and would have meant that I'd have to duplicate\n * parser logic in the decompiler to disambiguate situations where\n * newlines are important.)  The function decompile expands the\n * tokens back into their string representations, using simple\n * lookahead to correct spacing and indentation.\n *\n * Assignments are saved as two-token pairs (Token.ASSIGN, op). Number tokens\n * are stored inline, as a NUMBER token, a character representing the type, and\n * either 1 or 4 characters representing the bit-encoding of the number.  String\n * types NAME, STRING and OBJECT are currently stored as a token type,\n * followed by a character giving the length of the string (assumed to\n * be less than 2^16), followed by the characters of the string\n * inlined into the source string.  Changing this to some reference to\n * to the string in the compiled class' constant pool would probably\n * save a lot of space... but would require some method of deriving\n * the final constant pool entry from information available at parse\n * time.\n */\npublic class Decompiler {\n\n    /**\n     * Flag to indicate that the decompilation should omit the\n     * function header and trailing brace.\n     */\n    public static final int ONLY_BODY_FLAG = 1 << 0;\n\n    /**\n     * Flag to indicate that the decompilation generates toSource result.\n     */\n    public static final int TO_SOURCE_FLAG = 1 << 1;\n\n    /**\n     * Decompilation property to specify initial ident value.\n     */\n    public static final int INITIAL_INDENT_PROP = 1;\n\n    /**\n     * Decompilation property to specify default identation offset.\n     */\n    public static final int INDENT_GAP_PROP = 2;\n\n    /**\n     * Decompilation property to specify identation offset for case labels.\n     */\n    public static final int CASE_GAP_PROP = 3;\n\n    // Marker to denote the last RC of function so it can be distinguished from\n    // the last RC of object literals in case of function expressions\n    private static final int FUNCTION_END = Token.LAST_TOKEN + 1;\n\n    String getEncodedSource() {\n        return sourceToString(0);\n    }\n\n    int getCurrentOffset() {\n        return sourceTop;\n    }\n\n    int markFunctionStart(int functionType) {\n        int savedOffset = getCurrentOffset();\n        addToken(Token.FUNCTION);\n        append((char) functionType);\n        return savedOffset;\n    }\n\n    int markFunctionEnd(int functionStart) {\n        int offset = getCurrentOffset();\n        append((char) FUNCTION_END);\n        return offset;\n    }\n\n    void addToken(int token) {\n        if (!(0 <= token && token <= Token.LAST_TOKEN))\n            throw new IllegalArgumentException();\n        append((char) token);\n    }\n\n    void addEOL(int token) {\n        if (!(0 <= token && token <= Token.LAST_TOKEN))\n            throw new IllegalArgumentException();\n        append((char) token);\n        append((char) Token.EOL);\n    }\n\n    void addName(String str) {\n        addToken(Token.NAME);\n        appendString(str);\n    }\n\n    void addString(String str) {\n        addToken(Token.STRING);\n        appendString(str);\n    }\n\n    void addRegexp(String regexp, String flags) {\n        addToken(Token.REGEXP);\n        appendString('/' + regexp + '/' + flags);\n    }\n\n    void addJScriptConditionalComment(String str) {\n        addToken(Token.CONDCOMMENT);\n        appendString(str);\n    }\n\n    void addPreservedComment(String str) {\n        addToken(Token.KEEPCOMMENT);\n        appendString(str);\n    }\n\n    void addNumber(double n) {\n        addToken(Token.NUMBER);\n        /* encode the number in the source stream.\n         * Save as NUMBER type (char | char char char char)\n         * where type is\n         * 'D' - double, 'S' - short, 'J' - long.\n\n         * We need to retain float vs. integer type info to keep the\n         * behavior of liveconnect type-guessing the same after\n         * decompilation.  (Liveconnect tries to present 1.0 to Java\n         * as a float/double)\n         * OPT: This is no longer true. We could compress the format.\n\n         * This may not be the most space-efficient encoding;\n         * the chars created below may take up to 3 bytes in\n         * constant pool UTF-8 encoding, so a Double could take\n         * up to 12 bytes.\n         */\n        long lbits = (long) n;\n        if (lbits != n) {\n            // if it's floating point, save as a Double bit pattern.\n            // (12/15/97 our scanner only returns Double for f.p.)\n            lbits = Double.doubleToLongBits(n);\n            append('D');\n            append((char) (lbits >> 48));\n            append((char) (lbits >> 32));\n            append((char) (lbits >> 16));\n            append((char) lbits);\n        } else {\n            // we can ignore negative values, bc they're already prefixed\n            // by NEG\n            if (lbits < 0)\n                Kit.codeBug();\n            // will it fit in a char?\n            // this gives a short encoding for integer values up to 2^16.\n            if (lbits <= Character.MAX_VALUE) {\n                append('S');\n                append((char) lbits);\n            } else {\n                // Integral, but won't fit in a char. Store as a long.\n                append('J');\n                append((char) (lbits >> 48));\n                append((char) (lbits >> 32));\n                append((char) (lbits >> 16));\n                append((char) lbits);\n            }\n        }\n    }\n\n    private void appendString(String str) {\n        int L = str.length();\n        int lengthEncodingSize = 1;\n        if (L >= 0x8000) {\n            lengthEncodingSize = 2;\n        }\n        int nextTop = sourceTop + lengthEncodingSize + L;\n        if (nextTop > sourceBuffer.length) {\n            increaseSourceCapacity(nextTop);\n        }\n        if (L >= 0x8000) {\n            // Use 2 chars to encode strings exceeding 32K, were the highest\n            // bit in the first char indicates presence of the next byte\n            sourceBuffer[sourceTop] = (char) (0x8000 | (L >>> 16));\n            ++sourceTop;\n        }\n        sourceBuffer[sourceTop] = (char) L;\n        ++sourceTop;\n        str.getChars(0, L, sourceBuffer, sourceTop);\n        sourceTop = nextTop;\n    }\n\n    private void append(char c) {\n        if (sourceTop == sourceBuffer.length) {\n            increaseSourceCapacity(sourceTop + 1);\n        }\n        sourceBuffer[sourceTop] = c;\n        ++sourceTop;\n    }\n\n    private void increaseSourceCapacity(int minimalCapacity) {\n        // Call this only when capacity increase is must\n        if (minimalCapacity <= sourceBuffer.length)\n            Kit.codeBug();\n        int newCapacity = sourceBuffer.length * 2;\n        if (newCapacity < minimalCapacity) {\n            newCapacity = minimalCapacity;\n        }\n        char[] tmp = new char[newCapacity];\n        System.arraycopy(sourceBuffer, 0, tmp, 0, sourceTop);\n        sourceBuffer = tmp;\n    }\n\n    private String sourceToString(int offset) {\n        if (offset < 0 || sourceTop < offset)\n            Kit.codeBug();\n        return new String(sourceBuffer, offset, sourceTop - offset);\n    }\n\n    /**\n     * Decompile the source information associated with this js\n     * function/script back into a string.  For the most part, this\n     * just means translating tokens back to their string\n     * representations; there's a little bit of lookahead logic to\n     * decide the proper spacing/indentation.  Most of the work in\n     * mapping the original source to the prettyprinted decompiled\n     * version is done by the parser.\n     *\n     * @param source encoded source tree presentation\n     *\n     * @param flags flags to select output format\n     *\n     * @param properties indentation properties\n     */\n    public static String decompile(String source, int flags, UintMap properties) {\n        int length = source.length();\n        if (length == 0) {\n            return \"\";\n        }\n        int indent = properties.getInt(INITIAL_INDENT_PROP, 0);\n        if (indent < 0)\n            throw new IllegalArgumentException();\n        int indentGap = properties.getInt(INDENT_GAP_PROP, 4);\n        if (indentGap < 0)\n            throw new IllegalArgumentException();\n        int caseGap = properties.getInt(CASE_GAP_PROP, 2);\n        if (caseGap < 0)\n            throw new IllegalArgumentException();\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n        // Spew tokens in source, for debugging.\n        // as TYPE number char\n        if (printSource) {\n            System.err.println(\"length:\" + length);\n            for (int i = 0; i < length; ++i) {\n                // Note that tokenToName will fail unless Context.printTrees\n                // is true.\n                String tokenname = null;\n                if (Token.printNames) {\n                    tokenname = Token.name(source.charAt(i));\n                }\n                if (tokenname == null) {\n                    tokenname = \"---\";\n                }\n                String pad = tokenname.length() > 7 ? \"\\t\" : \"\\t\\t\";\n                System.err.println(tokenname + pad + (int) source.charAt(i) + \"\\t'\" + ScriptRuntime.escapeString(source.substring(i, i + 1)) + \"'\");\n            }\n            System.err.println();\n        }\n        int braceNesting = 0;\n        boolean afterFirstEOL = false;\n        int i = 0;\n        int topFunctionType;\n        if (source.charAt(i) == Token.SCRIPT) {\n            ++i;\n            topFunctionType = -1;\n        } else {\n            topFunctionType = source.charAt(i + 1);\n        }\n        if (!toSource) {\n            // add an initial newline to exactly match js.\n            result.append('\\n');\n            for (int j = 0; j < indent; j++) result.append(' ');\n        } else {\n            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {\n                result.append('(');\n            }\n        }\n        while (i < length) {\n            switch(source.charAt(i)) {\n                case Token.GET:\n                case Token.SET:\n                    result.append(source.charAt(i) == Token.GET ? \"get \" : \"set \");\n                    ++i;\n                    i = printSourceString(source, i + 1, false, result);\n                    // Now increment one more to get past the FUNCTION token\n                    ++i;\n                    break;\n                case Token.NAME:\n                case // re-wrapped in '/'s in parser...\n                Token.REGEXP:\n                    i = printSourceString(source, i + 1, false, result);\n                    continue;\n                case Token.STRING:\n                    i = printSourceString(source, i + 1, true, result);\n                    continue;\n                case Token.NUMBER:\n                    i = printSourceNumber(source, i + 1, result);\n                    continue;\n                case Token.TRUE:\n                    result.append(\"true\");\n                    break;\n                case Token.FALSE:\n                    result.append(\"false\");\n                    break;\n                case Token.NULL:\n                    result.append(\"null\");\n                    break;\n                case Token.THIS:\n                    result.append(\"this\");\n                    break;\n                case Token.FUNCTION:\n                    // skip function type\n                    ++i;\n                    result.append(\"function \");\n                    break;\n                case FUNCTION_END:\n                    // Do nothing\n                    break;\n                case Token.COMMA:\n                    result.append(\", \");\n                    break;\n                case Token.LC:\n                    ++braceNesting;\n                    if (Token.EOL == getNext(source, length, i))\n                        indent += indentGap;\n                    result.append('{');\n                    break;\n                case Token.RC:\n                    {\n                        --braceNesting;\n                        /* don't print the closing RC if it closes the\n                 * toplevel function and we're called from\n                 * decompileFunctionBody.\n                 */\n                        if (justFunctionBody && braceNesting == 0)\n                            break;\n                        result.append('}');\n                        switch(getNext(source, length, i)) {\n                            case Token.EOL:\n                            case FUNCTION_END:\n                                indent -= indentGap;\n                                break;\n                            case Token.WHILE:\n                            case Token.ELSE:\n                                indent -= indentGap;\n                                result.append(' ');\n                                break;\n                        }\n                        break;\n                    }\n                case Token.LP:\n                    result.append('(');\n                    break;\n                case Token.RP:\n                    result.append(')');\n                    if (Token.LC == getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.LB:\n                    result.append('[');\n                    break;\n                case Token.RB:\n                    result.append(']');\n                    break;\n                case Token.EOL:\n                    {\n                        if (toSource)\n                            break;\n                        boolean newLine = true;\n                        if (!afterFirstEOL) {\n                            afterFirstEOL = true;\n                            if (justFunctionBody) {\n                                /* throw away just added 'function name(...) {'\n                         * and restore the original indent\n                         */\n                                result.setLength(0);\n                                indent -= indentGap;\n                                newLine = false;\n                            }\n                        }\n                        if (newLine) {\n                            result.append('\\n');\n                        }\n                        /* add indent if any tokens remain,\n                 * less setback if next token is\n                 * a label, case or default.\n                 */\n                        if (i + 1 < length) {\n                            int less = 0;\n                            int nextToken = source.charAt(i + 1);\n                            if (nextToken == Token.CASE || nextToken == Token.DEFAULT) {\n                                less = indentGap - caseGap;\n                            } else if (nextToken == Token.RC) {\n                                less = indentGap;\n                            } else /* elaborate check against label... skip past a\n                     * following inlined NAME and look for a COLON.\n                     */\n                            if (nextToken == Token.NAME) {\n                                int afterName = getSourceStringEnd(source, i + 2);\n                                if (source.charAt(afterName) == Token.COLON)\n                                    less = indentGap;\n                            }\n                            for (; less < indent; less++) result.append(' ');\n                        }\n                        break;\n                    }\n                case Token.DOT:\n                    result.append('.');\n                    break;\n                case Token.NEW:\n                    result.append(\"new \");\n                    break;\n                case Token.DELPROP:\n                    result.append(\"delete \");\n                    break;\n                case Token.IF:\n                    result.append(\"if \");\n                    break;\n                case Token.ELSE:\n                    result.append(\"else \");\n                    break;\n                case Token.FOR:\n                    result.append(\"for \");\n                    break;\n                case Token.IN:\n                    result.append(\" in \");\n                    break;\n                case Token.WITH:\n                    result.append(\"with \");\n                    break;\n                case Token.WHILE:\n                    result.append(\"while \");\n                    break;\n                case Token.DO:\n                    result.append(\"do \");\n                    break;\n                case Token.TRY:\n                    result.append(\"try \");\n                    break;\n                case Token.CATCH:\n                    result.append(\"catch \");\n                    break;\n                case Token.FINALLY:\n                    result.append(\"finally \");\n                    break;\n                case Token.THROW:\n                    result.append(\"throw \");\n                    break;\n                case Token.SWITCH:\n                    result.append(\"switch \");\n                    break;\n                case Token.BREAK:\n                    result.append(\"break\");\n                    if (Token.NAME == getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.CONTINUE:\n                    result.append(\"continue\");\n                    if (Token.NAME == getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.CASE:\n                    result.append(\"case \");\n                    break;\n                case Token.DEFAULT:\n                    result.append(\"default\");\n                    break;\n                case Token.RETURN:\n                    result.append(\"return\");\n                    if (Token.SEMI != getNext(source, length, i))\n                        result.append(' ');\n                    break;\n                case Token.VAR:\n                    result.append(\"var \");\n                    break;\n                case Token.LET:\n                    result.append(\"let \");\n                    break;\n                case Token.SEMI:\n                    result.append(';');\n                    if (Token.EOL != getNext(source, length, i)) {\n                        // separators in FOR\n                        result.append(' ');\n                    }\n                    break;\n                case Token.ASSIGN:\n                    result.append(\" = \");\n                    break;\n                case Token.ASSIGN_ADD:\n                    result.append(\" += \");\n                    break;\n                case Token.ASSIGN_SUB:\n                    result.append(\" -= \");\n                    break;\n                case Token.ASSIGN_MUL:\n                    result.append(\" *= \");\n                    break;\n                case Token.ASSIGN_DIV:\n                    result.append(\" /= \");\n                    break;\n                case Token.ASSIGN_MOD:\n                    result.append(\" %= \");\n                    break;\n                case Token.ASSIGN_BITOR:\n                    result.append(\" |= \");\n                    break;\n                case Token.ASSIGN_BITXOR:\n                    result.append(\" ^= \");\n                    break;\n                case Token.ASSIGN_BITAND:\n                    result.append(\" &= \");\n                    break;\n                case Token.ASSIGN_LSH:\n                    result.append(\" <<= \");\n                    break;\n                case Token.ASSIGN_RSH:\n                    result.append(\" >>= \");\n                    break;\n                case Token.ASSIGN_URSH:\n                    result.append(\" >>>= \");\n                    break;\n                case Token.HOOK:\n                    result.append(\" ? \");\n                    break;\n                case Token.OBJECTLIT:\n                    // pun OBJECTLIT to mean colon in objlit property\n                    // initialization.\n                    // This needs to be distinct from COLON in the general case\n                    // to distinguish from the colon in a ternary... which needs\n                    // different spacing.\n                    result.append(':');\n                    break;\n                case Token.COLON:\n                    if (Token.EOL == getNext(source, length, i))\n                        // it's the end of a label\n                        result.append(':');\n                    else\n                        // it's the middle part of a ternary\n                        result.append(\" : \");\n                    break;\n                case Token.OR:\n                    result.append(\" || \");\n                    break;\n                case Token.AND:\n                    result.append(\" && \");\n                    break;\n                case Token.BITOR:\n                    result.append(\" | \");\n                    break;\n                case Token.BITXOR:\n                    result.append(\" ^ \");\n                    break;\n                case Token.BITAND:\n                    result.append(\" & \");\n                    break;\n                case Token.SHEQ:\n                    result.append(\" === \");\n                    break;\n                case Token.SHNE:\n                    result.append(\" !== \");\n                    break;\n                case Token.EQ:\n                    result.append(\" == \");\n                    break;\n                case Token.NE:\n                    result.append(\" != \");\n                    break;\n                case Token.LE:\n                    result.append(\" <= \");\n                    break;\n                case Token.LT:\n                    result.append(\" < \");\n                    break;\n                case Token.GE:\n                    result.append(\" >= \");\n                    break;\n                case Token.GT:\n                    result.append(\" > \");\n                    break;\n                case Token.INSTANCEOF:\n                    result.append(\" instanceof \");\n                    break;\n                case Token.LSH:\n                    result.append(\" << \");\n                    break;\n                case Token.RSH:\n                    result.append(\" >> \");\n                    break;\n                case Token.URSH:\n                    result.append(\" >>> \");\n                    break;\n                case Token.TYPEOF:\n                    result.append(\"typeof \");\n                    break;\n                case Token.VOID:\n                    result.append(\"void \");\n                    break;\n                case Token.CONST:\n                    result.append(\"const \");\n                    break;\n                case Token.YIELD:\n                    result.append(\"yield \");\n                    break;\n                case Token.NOT:\n                    result.append('!');\n                    break;\n                case Token.BITNOT:\n                    result.append('~');\n                    break;\n                case Token.POS:\n                    result.append('+');\n                    break;\n                case Token.NEG:\n                    result.append('-');\n                    break;\n                case Token.INC:\n                    result.append(\"++\");\n                    break;\n                case Token.DEC:\n                    result.append(\"--\");\n                    break;\n                case Token.ADD:\n                    result.append(\" + \");\n                    break;\n                case Token.SUB:\n                    result.append(\" - \");\n                    break;\n                case Token.MUL:\n                    result.append(\" * \");\n                    break;\n                case Token.DIV:\n                    result.append(\" / \");\n                    break;\n                case Token.MOD:\n                    result.append(\" % \");\n                    break;\n                case Token.COLONCOLON:\n                    result.append(\"::\");\n                    break;\n                case Token.DOTDOT:\n                    result.append(\"..\");\n                    break;\n                case Token.DOTQUERY:\n                    result.append(\".(\");\n                    break;\n                case Token.XMLATTR:\n                    result.append('@');\n                    break;\n                default:\n                    // If we don't know how to decompile it, raise an exception.\n                    throw new RuntimeException(\"Token: \" + Token.name(source.charAt(i)));\n            }\n            ++i;\n        }\n        if (!toSource) {\n            // add that trailing newline if it's an outermost function.\n            if (!justFunctionBody)\n                result.append('\\n');\n        } else {\n            if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {\n                result.append(')');\n            }\n        }\n        return result.toString();\n    }\n\n    private static int getNext(String source, int length, int i) {\n        return (i + 1 < length) ? source.charAt(i + 1) : Token.EOF;\n    }\n\n    private static int getSourceStringEnd(String source, int offset) {\n        return printSourceString(source, offset, false, null);\n    }\n\n    private static int printSourceString(String source, int offset, boolean asQuotedString, StringBuffer sb) {\n        int length = source.charAt(offset);\n        ++offset;\n        if ((0x8000 & length) != 0) {\n            length = ((0x7FFF & length) << 16) | source.charAt(offset);\n            ++offset;\n        }\n        if (sb != null) {\n            String str = source.substring(offset, offset + length);\n            if (!asQuotedString) {\n                sb.append(str);\n            } else {\n                sb.append('\"');\n                sb.append(ScriptRuntime.escapeString(str));\n                sb.append('\"');\n            }\n        }\n        return offset + length;\n    }\n\n    private static int printSourceNumber(String source, int offset, StringBuffer sb) {\n        double number = 0.0;\n        char type = source.charAt(offset);\n        ++offset;\n        if (type == 'S') {\n            if (sb != null) {\n                int ival = source.charAt(offset);\n                number = ival;\n            }\n            ++offset;\n        } else if (type == 'J' || type == 'D') {\n            if (sb != null) {\n                long lbits;\n                lbits = (long) source.charAt(offset) << 48;\n                lbits |= (long) source.charAt(offset + 1) << 32;\n                lbits |= (long) source.charAt(offset + 2) << 16;\n                lbits |= source.charAt(offset + 3);\n                if (type == 'J') {\n                    number = lbits;\n                } else {\n                    number = Double.longBitsToDouble(lbits);\n                }\n            }\n            offset += 4;\n        } else {\n            // Bad source\n            throw new RuntimeException();\n        }\n        if (sb != null) {\n            sb.append(ScriptRuntime.numberToString(number, 10));\n        }\n        return offset;\n    }\n\n    private char[] sourceBuffer = new char[128];\n\n    // Per script/function source buffer top: parent source does not include a\n    // nested functions source and uses function index as a reference instead.\n    private int sourceTop;\n\n    // whether to do a debug print of the source information, when decompiling.\n    private static final boolean printSource = false;\n}\n",
    "test_prompt": "// DecompilerTest.java\npackage org.mozilla.javascript;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Decompiler}.\n* It contains one unit test case for the {@link Decompiler#decompile(String, int, UintMap)} method.\n*/\nclass DecompilerTest {",
    "time_taken": -1
}
]