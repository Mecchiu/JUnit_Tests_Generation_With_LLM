ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
c767a0a9-50ff-43ee-8eda-ee60decdec2d,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_0Test.java,19.295870542526245,stop,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {","// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {
// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) ||!identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}

// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {
		

	public ASTNode_0Test() {
	}
	
	
	/**
	 * Test equality and the value.
	 * Compare a node for equals using the {@link #compareTo(java.lang.Object)} method.
	 */
	@Test
	public void testEq() {
		ASTNode nodeToTest = new ASTNode_0().toString();
		assertEquals(nodeToTest, nodeToTest);
	}
	public static ArrayList<ASTNode> createTreeArr_0() {
		ArrayList<ASTNode> ntree = new ArrayList();
		ArrayList<String> list = new ArrayList();
		list.add(""Node1"");
		list.add(""Node2"");
		list.add(""Node3"");
		list.add(""Node4"");
		for (int i = 0; i < list.size(); ++i) {
			ASTNode a = new ASTNode_0();
			a.createTree(list.get(i));
			ndtree.add(a);
		}
		return ntree;
	}

}
"
05f104bd-9ed2-45e0-b3b7-5d810166e759,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_1Test.java,19.308168649673462,stop,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {","// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {
// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) ||!identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}

// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {
		/**
		 * @param args command line arguments
		 */
    public static void main(String[] args) {
        junit.textui.TestRunner.run(ASTRNode_1Test.class);
    }
    /* Test for Tree Structure - getTree(String file) {
*/


}
/* class ASTNode_1Test{

	public void showASTC(ASTCNode node){
		ListNode m = new ListNode();
		m.tree = node.tree;
		for(int i=0;i<node.children.size();i++){
			ASTCNode n1 = node.children.get(i);
			m.children.add( n1);
		}
		System.out.println(m.tree);

	}	
} */"
e8a6f1ff-9ab4-44b4-89cb-89df70e2446b,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_2Test.java,19.36852788925171,stop,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {","// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {
// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) ||!identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}

// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains one unit test case for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {
		/**
		 * main method with parameters.
		 */
    @Test
    public void createTreeTest(){
        ASTNode tree = new ASTNode_2(null);
        DefaultMutableTreeNode node = tree.createTree();
        assertEquals(""CreateTree"", ""CREATE: "", node);
		assertEquals(""Node.lengthEquals"", true, node.length()==1);
    }
}
"
0d95c0ba-6ca2-40a9-90a2-abb1b222a88f,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAParser.java,49.930525064468384,stop,"// JMCAParser.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;

public class JMCAParser implements Parser {

    String intermediateFile = ""default.xml"";

    /**
     * parse implements parse for Parser
     * precondition is the intermediatFile is set
     * @param rdr Reader
     * @return ASTNode
     */
    public ASTNode parse(Reader rdr) {
        JavaParser parser = new JavaParser(rdr);
        Writer wtr = null;
        try {
            parser.CompilationUnit();
            wtr = new FileWriter(new File(intermediateFile));
            parser.dump(wtr);
            System.out.println(""Java Parser Version 1.1:  Java program parsed successfully."");
            wtr.close();
            SaxProcessor saxP = new SaxProcessor(new FileInputStream(new File(intermediateFile)));
            saxP.showFile();
            return saxP.getRootNode();
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println(""Java Parser Version 1.1:  Encountered errors during parse."");
            return null;
        } catch (IOException ie) {
            System.out.println(""IO Error from parse : "" + ie.getMessage());
            return null;
        } catch (Error ex) {
            return null;
        } finally {
            try {
                if (wtr != null)
                    wtr.close();
            } catch (IOException ie) {
                System.err.println(""Error while closing intermediate file "" + intermediateFile);
                System.err.println(ie.getMessage());
            }
        }
        //           return null;
    }
}
","// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains one unit test case for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {","// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains one unit test case for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {
// JMCAParser.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;

public class JMCAParser implements Parser {

    String intermediateFile = ""default.xml"";

    /**
     * parse implements parse for Parser
     * precondition is the intermediatFile is set
     * @param rdr Reader
     * @return ASTNode
     */
    public ASTNode parse(Reader rdr) {
        JavaParser parser = new JavaParser(rdr);
        Writer wtr = null;
        try {
            parser.CompilationUnit();
            wtr = new FileWriter(new File(intermediateFile));
            parser.dump(wtr);
            System.out.println(""Java Parser Version 1.1:  Java program parsed successfully."");
            wtr.close();
            SaxProcessor saxP = new SaxProcessor(new FileInputStream(new File(intermediateFile)));
            saxP.showFile();
            return saxP.getRootNode();
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println(""Java Parser Version 1.1:  Encountered errors during parse."");
            return null;
        } catch (IOException ie) {
            System.out.println(""IO Error from parse : "" + ie.getMessage());
            return null;
        } catch (Error ex) {
            return null;
        } finally {
            try {
                if (wtr!= null)
                    wtr.close();
            } catch (IOException ie) {
                System.err.println(""Error while closing intermediate file "" + intermediateFile);
                System.err.println(ie.getMessage());
            }
        }
        //           return null;
    }
}

// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains one unit test case for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {
		@Test
    public void testStringProcessing() {

        StringBuilder sb = new StringBuilder();
        sb.append(""<?xml version=\""1.0\"" encoding=\""utf-8\""?>"");
        sb.append(""<a:nodes><a:node nodeType=\""a:Text\"">value</a:node></a:nodes>"");

        JSONParser parser = new JSONParser(sb);
        ParserResult result = parser.parse();
        assertTrue(((JSONFileTree) result.getTree()).isComplete());
        assertTrue(result.isSuccess());

				
			}
		@Test
    public void testFileParsing() {

        StringBuilder sb = new StringBuilder();
        sb.append(""<?xml version=\""1.0\"" encoding=\""utf-8\""?>"");
        sb.append(""<a:nodes>"");
        sb.append(""<a:node nodeType=\""a:FileNode\"">"");
        sb.append(""<a:file>"");
        sb.append(""<?xml version=\""1.0\"" encoding=\""utf-8\""?>"");
        sb.append(""</a:file></a:node>"");
        parser.parse(new ByteArrayReader(sb.toString().getBytes()));
        sb.setLength(0);
        sb.append(""</a:node>"");
        sb.append(""</a:nodes>"");
        
        JSONParser parser = new JSONParser(sb);
        ParserResult result = parser.parse(new ByteArrayReader(""TestString.xml"".getBytes()));
        assertTrue(result.isSuccess());
		}

	@Test
    public void testStringParsing() throws IOException {
	    
        String s = ""String"";

        StringBuilder sb = new StringBuilder();

        sb.append(s);
        
        parser.parse(new ByteArrayReader(sb.toString().getBytes()));

        //				sb.insert(0, s);
        // System.out.println(new String((byte[])sb.toArray()[0]));
        // File f = new File(""C:\\Users\\John\\Documents\\java"");
        // System.out.println(f.exists());
        // assertTrue(f.exists());
        //
        // FileInputStream fis = new FileInputStream(f);
        // System.out.println(fis.available());
        // // assertTrue(fis.available() > 0);

        // System.out.println();
    }


	@Test
    public void testArray() throws IOException {
	    
        String s = ""[0,1]"";
        
        ByteArrayReader br = new ByteArrayReader(s.getBytes());
        ArrayArrayBuilder arrayBuilder = new ArrayArrayBuilder();
        int i = arrayBuilder.build(br);
        assertTrue(i > 0);
        
    }
	
	@Test
    public void testArrayBuild() throws IOException {
	    
        String s = ""[0,1]"";
	    
        ByteArrayReader br = new ByteArrayReader(s.getBytes());
	    ArrayArrayBuilder arrayBuilder = new ArrayArrayBuilder();
	    int i = arrayBuilder.build(br, 1);
	    assertEquals(2, i);
    }
	
	@Test
    public void testArrayBuilder() throws IOException {

        StringBuilder sb = new StringBuilder();
        sb.append(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
        sb.append(""<a:nodes><a:node nodeType=\""a:Text\"">value</a:node></a:nodes>"");
	
        ByteArrayReader br = new ByteArrayReader(sb.toString().getBytes());
        
		// parser.parse(new ByteArrayReader(s.getBytes()));
		    parser.parse(br);
		
        File file = new File(""C:\\Users\\John\\Documents\\java"");
        
        System.out.println(file.exists());
        assertTrue(file.exists());

		assertTrue(((JSONFileTree) br.getTree()).isComplete());
    }
	
	@Test
    public void testArrayGet() throws IOException {
	    

		System.out.println();
        ByteArrayReader br = new ByteArrayReader(
                ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
        ArrayArrayBuilder arrayBuilder = new ArrayArrayBuilder();
        // arrayBuilder.Build(this);

        // parser.parse(new ByteArrayReader(sb.getBytes()));
		    parser.parse(br);

        File f = new File(""C:\\Users\\John\\Documents\\java"");
        System.out.println(f.exists());
        assertTrue(f.exists());

		assertTrue(Arrays.equals((Object[]) arrayBuilder.getArray(0), (Object[]) new java.util.ArrayList(Arrays.asList(""value""))));

		
		/*
			//assertTrue(((JSONArrayTree)br.getTree())
			.getElementAt(0).equals(""value""));
			*/

	}

}
"
37776375-9545-4492-8d8d-a7396da0ca9d,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/UILayoutDisplayAnalyzer.java,28.925032377243042,stop,"// UILayoutDisplayAnalyzer.java
package com.soops.CEN4010.JMCA;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Description: UILayoutDisplayAnalyzer implements a dummy Analyzer
 *    use for UI layout  </p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class UILayoutDisplayAnalyzer implements Analyzer {

    String filename = null;

    /**
     * store the file name for formatted display purposes
     * @param file String
     */
    public void setFileName(String file) {
        filename = file;
    }

    /**
     * no operational implementation of Analyzer
     * @param dummy ASTNode not used for dummy output
     * @return display string
     */
    public String analyze(ASTNode dummy) {
        StringBuffer output = new StringBuffer();
        //FAKE OUTPUT FOR PROTOTYPE
        output = new StringBuffer(""\nFile:  "");
        output.append(filename);
        output.append(""\n"");
        output.append(""Class: CohesionTest\n\n"");
        output.append(""Method Name                             Cohesion Level\n"");
        output.append(""--------------------------------------------------------------\n"");
        output.append(""deposit                                 Functional\n"");
        output.append(""withdraw                                Sequential\n"");
        output.append(""addCD                                   Communicational\n"");
        output.append(""formDet                                 Iterative\n"");
        output.append(""checkBookIn                             Conditional\n"");
        output.append(""readInput                               Coincidental\n"");
        return output.toString();
    }
}
","// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains one unit test case for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {","// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains one unit test case for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
/**
		 * Test the method {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} for output of dummy output form
		 * @juso
		 */
		@Test public void testAnalyzingTheDummyOutput() {
			System.out.println(""testAnalyzingTheDummyOutput is finished."");
		}
}"
c5728af1-8d83-4f63-9dff-46973144782f,/EvoSuiteBenchmark/original/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAAnalyzer.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// JMCAAnalyzer.java
package com.soops.CEN4010.JMCA;

import java.util.*;

/**
 * <p>Title: JMCAAnalyzer </p>
 *
 * <p>Description: implements Analyzer</p>
 *
 * Group2 for CEN4010 at FSU - Fall 2005
 */
public class JMCAAnalyzer implements Analyzer {

    private String fileName = """";

    private StringBuilder output = new StringBuilder();

    private java.util.HashSet<String> classList = null;

    private static final boolean DEVELOPMENT = false;

    /**
     * Analyze the ASTree and return a formatted string
     * @param root ASTNode
     * @return String
     */
    public String analyze(ASTNode root) {
        if (root == null) {
            output.append(""File did not parse correctly"");
            return output.toString();
        }
        setHeader();
        //  for each class
        for (ASTNode node : root.list) {
            analyzeClass(node);
        }
        return output.toString();
    }

    /**
     * top level analyzer for each class <br>
     * calls analyzeMethod for each method
     * @param node ASTNode
     */
    private void analyzeClass(ASTNode node) {
        // list of class variables
        classList = new HashSet<String>();
        java.util.ArrayList<ASTNode> methodList = new ArrayList<ASTNode>();
        // print class header
        output.append(""\nClass: "" + node.getIdentity() + ""\n\n"");
        output.append(""Method Name                             Cohesion Level\n"");
        output.append(""--------------------------------------------------------------\n"");
        // save each class variable in classList
        for (ASTNode childNode : node.list) {
            if (childNode.getType().equals(""ClassVariableDeclaration"")) {
                classList.add(childNode.getIdentity());
            }
        }
        //  do for each method
        for (ASTNode childNode : node.list) {
            if (childNode.getType().equals(""MethodDeclaration"")) {
                analyzeMethod(childNode);
            }
        }
    }

    // end method analyzeClass
    /**
     * called for each method
     * @param node ASTNode
     */
    private void analyzeMethod(ASTNode node) {
        output.append(node.getIdentity());
        /**
         * list of all statements
         */
        ArrayList<StatementDS> statementList = new ArrayList<StatementDS>();
        /**
         * analyze all statements and add them to the statementList
         */
        statements(node, statementList, false, false);
        /**
         * HashMap of all modified variables
         */
        HashMap<String, StatementElement> modifiedVariables = new HashMap<String, StatementElement>();
        // build semantics for each statement
        for (StatementDS tmpDS : statementList) {
            if (classList.contains(tmpDS.getLVal().getElementName())) {
                tmpDS.getLVal().setType(StatementElement.variableType.ClassVariable);
            }
            if (tmpDS.getType() != null) {
                if (tmpDS.getType().equals(StatementDS.statementType.Assignment) || tmpDS.getType().equals(StatementDS.statementType.PostInc) || tmpDS.getType().equals(StatementDS.statementType.PreInc)) {
                    tmpDS.getLVal().setModified(true);
                    modifiedVariables.put(tmpDS.getLVal().getElementName(), tmpDS.getLVal());
                }
            }
            // set for selection
            tmpDS.getLVal().setInSelection(tmpDS.isInSelection());
            // set for iteration
            tmpDS.getLVal().setInIteration(tmpDS.isInIteration());
            // add modified variables to the chain of variables affecting this element
            ArrayList<StatementElement> rVals = tmpDS.getRVals();
            for (StatementElement rval : rVals) {
                StatementElement tmpEl = modifiedVariables.get(rval.getElementName());
                if (tmpEl != null && !tmpEl.getElementName().equals(tmpDS.getLVal().getElementName())) {
                    tmpDS.getLVal().addModifier(tmpEl);
                } else if (!rval.getElementName().equals(tmpDS.getLVal().getElementName())) {
                    tmpDS.getLVal().addModifier(rval);
                }
                if (rval.hasBeenModified()) {
                    tmpDS.getLVal().addModifier(rval);
                    modifiedVariables.put(rval.getElementName(), rval);
                }
            }
        }
        int modifiedClassVariables = 0;
        int classVariableWithModifiers = 0;
        int modifiedLocVariables = 0;
        boolean iterative = false;
        boolean selective = false;
        String cohesionLevel = """";
        boolean firstModifiedClassVariableWithModifers = true;
        ArrayList<String> classVarModifiers = new ArrayList<String>();
        // do for every Statement
        for (StatementElement el : modifiedVariables.values()) {
            if (el.hasBeenModified()) {
                // class variables
                if (el.getType() != null && el.getType().equals(StatementElement.variableType.ClassVariable)) {
                    // selection
                    if (el.isInSelection()) {
                        selective = true;
                    }
                    // iteration
                    if (el.isInIteration()) {
                        iterative = true;
                    }
                    if (el.getModifiers().size() > 0) {
                        ++classVariableWithModifiers;
                        if (firstModifiedClassVariableWithModifers) {
                            createArrayListOfModifiers(el, classVarModifiers);
                            firstModifiedClassVariableWithModifers = false;
                        } else {
                            ArrayList<String> tmpList = new ArrayList<String>();
                            createArrayListOfModifiers(el, tmpList);
                            ArrayList<String> unionSet = new ArrayList<String>();
                            // get the union of modifed variables
                            for (String var : classVarModifiers) {
                                for (String tmpEl : tmpList) {
                                    if (var.equals(tmpEl)) {
                                        unionSet.add(var);
                                    }
                                }
                            }
                            classVarModifiers = unionSet;
                        }
                    }
                    ++modifiedClassVariables;
                } else {
                    // end modified class variables
                    ++modifiedLocVariables;
                }
            }
        }
        String cohesionType = ""Coincidental"";
        if (modifiedClassVariables == 1 && modifiedLocVariables == 0) {
            cohesionType = ""Functional"";
        } else if (modifiedClassVariables == 1 && classVarModifiers.size() > 0) {
            cohesionType = ""Sequential"";
        } else if (modifiedClassVariables > 1 && classVarModifiers.size() > 0) {
            cohesionType = ""Communicational"";
        } else if (modifiedClassVariables == 0) {
            cohesionType = ""No Class Level Assignments"";
            //  cohesionType = ""Coincidental"";
        }
        if (iterative) {
            cohesionType = ""Iterative"";
        }
        if (selective) {
            cohesionType = ""Conditional"";
        }
        for (int i = 0; i < 60 - node.getIdentity().length() - cohesionType.length(); ++i) {
            output.append("" "");
        }
        output.append(cohesionType + ""\n"");
        // print out a toString dump for development analysis
        if (DEVELOPMENT) {
            for (StatementDS tmpDS : statementList) {
                output.append(""     "" + tmpDS.toString() + ""\n"");
            }
        }
    }

    // end method analyzeMethod
    /**
     * recursive method to create a chain of modifiers to a variable <b>
     * using this method then :   a = b + c;  d = a;  e = d; <br>
     *   e would contain both d and a as modifiers it is dependent on
     * @param stE StatementElement
     * @param list ArrayList
     */
    private void createArrayListOfModifiers(StatementElement stE, ArrayList<String> list) {
        for (StatementElement tmpEl : stE.getModifiers()) {
            list.add(tmpEl.getElementName());
            if (tmpEl.getModifiers().size() > 0) {
                createArrayListOfModifiers(tmpEl, list);
            }
        }
    }

    /**
     * recusive method to analyze statements
     * @param parentNode ASTNode
     * @param statementList ArrayList
     * @param isInSelection boolean
     * @param isInIteration boolean
     */
    private void statements(ASTNode parentNode, ArrayList<StatementDS> statementList, boolean isInSelection, boolean isInIteration) {
        for (ASTNode childNode : parentNode.list) {
            if (childNode.getType().equals(""Selection"")) {
                statements(childNode, statementList, true, isInIteration);
            } else if (childNode.getType().equals(""Iteration"")) {
                statements(childNode, statementList, isInSelection, true);
            } else if (childNode.getIdentity().equals(""StatementExpression"")) {
                StatementDS tmpDS = analyzeStatement(childNode);
                tmpDS.setInIteration(isInIteration);
                tmpDS.setInSelection(isInSelection);
                statementList.add(tmpDS);
            }
        }
    }

    /**
     * called for each statement
     * @param node ASTNode
     * @return StatementDS
     */
    private StatementDS analyzeStatement(ASTNode node) {
        StatementDS localDS = new StatementDS();
        int nodeCount = node.list.size();
        int currCtr = 0;
        int nxtCtr = nodeCount > 0 ? 1 : 0;
        // check for preDec ++ or --
        String firstVal = node.list.get(0).getIdentity();
        if (firstVal.equals(""++"") || firstVal.equals(""--"")) {
            localDS.setType(StatementDS.statementType.PreInc);
            currCtr++;
        }
        currCtr = getLVal(currCtr, node.list);
        localDS.setLVal(node.list.get(currCtr).getIdentity());
        if (currCtr + 1 == nodeCount) {
            return localDS;
        }
        // have the LVAL and there is a next
        currCtr++;
        if (node.list.get(currCtr).getIdentity().equals(""["")) {
            while (!node.list.get(currCtr).getIdentity().equals(""]"")) {
                currCtr++;
            }
            currCtr++;
        }
        if (currCtr + 1 == nodeCount) {
            return localDS;
        }
        // have the LVAL and there is a next
        String tmpVl = node.list.get(currCtr).getIdentity();
        if (tmpVl.equals(""("")) {
            localDS.setType(StatementDS.statementType.MethodCall);
            return localDS;
        }
        if (tmpVl.equals(""++"") || tmpVl.equals(""--"")) {
            localDS.setType(StatementDS.statementType.PostInc);
            return localDS;
        }
        if (tmpVl.equals(""+="") || tmpVl.equals(""="") || tmpVl.equals(""-="") || tmpVl.equals(""\\="") || tmpVl.equals(""*="")) {
            localDS.setType(StatementDS.statementType.Assignment);
            currCtr++;
        }
        getRVals(localDS, currCtr, node.list);
        return localDS;
    }

    /**
     * called from analyzeStatement - gets a list of RVals in assignment statements
     * @param locDS StatementDS
     * @param ctr int
     * @param list ArrayList
     */
    private void getRVals(StatementDS locDS, int ctr, ArrayList<ASTNode> list) {
        // reset to true for each new rval element
        boolean isFirstToken = true;
        String currVariable = null;
        int nodeCount = list.size();
        String currID = null, nextID = null;
        StatementElement currEl = null;
        while (ctr < nodeCount) {
            currID = list.get(ctr).getIdentity();
            if (ctr + 1 < nodeCount) {
                nextID = list.get(ctr + 1).getIdentity();
            } else {
                nextID = null;
            }
            if (isFirstToken) {
                currEl = new StatementElement();
                isFirstToken = false;
                if (currID.equals(""++"") || currID.equals(""--"")) {
                    currEl.setModified(true);
                }
                if (currID.equals(""("")) {
                    ctr++;
                    continue;
                }
            }
            if (nextID != null && (nextID.equals(""++"") || nextID.equals(""--""))) {
                currEl.setModified(true);
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
            }
            if (nextID != null && (nextID.equals("")""))) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                ctr++;
                continue;
            }
            if (nextID != null && nextID.equals(""."")) {
                ctr += 2;
                continue;
            }
            if (nextID == null || isOperator(nextID)) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                locDS.addRVal(currEl);
                // set for the next element
                isFirstToken = true;
                ctr++;
                continue;
            }
            if (currID.equals(""new"")) {
                currEl.setType(StatementElement.variableType.ClassInitiator);
            }
            if (nextID != null && nextID.equals(""("")) {
                if (currEl.getType() == null) {
                    currEl.setType(StatementElement.variableType.MethodCall);
                }
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
            }
            // ignore the array subscripts
            if (nextID != null && nextID.equals(""["")) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                String tmpVal = list.get(ctr).getIdentity();
                while (!tmpVal.equals(""]"")) {
                    ctr++;
                    tmpVal = list.get(ctr).getIdentity();
                }
                if (ctr == nodeCount - 1) {
                    locDS.addRVal(currEl);
                }
            }
            ctr++;
        }
        // end while loop
    }

    /**
     * helper function - checks for delimiters in a equation where delimiters <br>
     * are defined as arithmetic operands such as '+' and '-'
     * @param id String
     * @return boolean
     */
    private boolean isOperator(String id) {
        if (id == null) {
            return false;
        }
        if (id.equals(""+"") || id.equals(""-"") || id.equals(""\\"") || id.equals(""*"") || id.equals(""<<"") || id.equals("">>"") || id.equals(""%"")) {
            return true;
        }
        return false;
    }

    /**
     * gets the variable name for the lVal of an expression
     * @param ctr int
     * @param list ArrayList
     * @return int
     */
    private int getLVal(int ctr, ArrayList<ASTNode> list) {
        // do until the LVal is found
        // lval is an identity that does not have a '.' as the next identity
        // ie.   java.util.Type   in this instance Type is the LVal
        int nodeCount = list.size();
        String currID = null, nextID = null;
        while (ctr < nodeCount) {
            currID = list.get(ctr).getIdentity();
            if (ctr + 1 < nodeCount) {
                nextID = list.get(ctr + 1).getIdentity();
            } else {
                return ctr;
            }
            if (!nextID.equals(""."")) {
                return ctr;
            }
            ctr += 2;
        }
        return ctr;
    }

    /**
     * write the report header to output
     */
    private void setHeader() {
        output.append(""\nFile:  "");
        output.append(fileName);
        output.append(""\n"");
    }

    /**
     * Store the file name parsed for formatted display purposes
     * @param fileName String
     */
    public void setFileName(String fileName) {
        this.fileName = fileName;
    }
}

/**
 *  represents a variable in an expression
 */
class StatementElement {

    /**
     * marked true if this variable is modifed in the method
     */
    private boolean hasBeenModified = false;

    /**
     * represents the variable name
     */
    private String elementName = null;

    /**
     * set true if variable is within a if statement
     */
    private boolean isInSelection = false;

    /**
     * set true if variable is within an interation block
     */
    private boolean isInIteration = false;

    /**
     * list of elements that have modified this element <br>
     * a recursive descent of elements will get a chain of modifiers
     */
    private ArrayList<StatementElement> modifiers = new ArrayList<StatementElement>();

    /**
     * add a variable to the modifier list
     * @param rval StatementElement
     */
    public void addModifier(StatementElement rval) {
        modifiers.add(rval);
    }

    /**
     * return a reference to the modifier list
     * @return ArrayList
     */
    public ArrayList<StatementElement> getModifiers() {
        return modifiers;
    }

    /**
     *  enumeration of types
     */
    public static enum variableType {

        ClassVariable, LocalVariable, MethodCall, ClassInitiator
    }

    /**
     * local variableType represent the type of variable this is
     */
    variableType type = null;

    /**
     * default constructor
     */
    StatementElement() {
    }

    /**
     *  setter for the variable name
     * @param name String
     */
    StatementElement(String name) {
        setElementName(name);
    }

    /**
     * getter for the type : see enum variableType
     * @return variableType
     */
    variableType getType() {
        return type;
    }

    /**
     * setter for the variable type
     * @param t variableType
     */
    void setType(variableType t) {
        type = t;
    }

    /**
     * setter for the name
     * @param name String
     */
    void setElementName(String name) {
        elementName = name;
    }

    /**
     * getter for the boolean flag hasBeenModified
     * @return boolean
     */
    boolean hasBeenModified() {
        return hasBeenModified;
    }

    /**
     * getter for the variable name
     * @return String
     */
    String getElementName() {
        return elementName;
    }

    /**
     * setter for the boolean flag has been modified
     * @param val boolean
     */
    void setModified(boolean val) {
        hasBeenModified = val;
    }

    /**
     * override of toString provides information for debugging/development
     * @return String
     */
    public String toString() {
        String tmp = elementName;
        if (hasBeenModified) {
            tmp += "" (modified) "";
        }
        if (type != null) {
            tmp += "" ("" + type.toString() + "") "";
        }
        for (StatementElement element : modifiers) {
            tmp += element.toString();
        }
        return tmp;
    }

    /**
     * getter for the boolean flag isInSelection
     * @return boolean
     */
    boolean isInSelection() {
        return isInSelection;
    }

    /**
     * getter for the boolean flag isInIteration
     * @return boolean
     */
    boolean isInIteration() {
        return isInIteration;
    }

    /**
     * setter for isInSelection
     * @param val boolean
     */
    void setInSelection(boolean val) {
        isInSelection = val;
    }

    /**
     * setter for isInIteration
     * @param val boolean
     */
    void setInIteration(boolean val) {
        isInIteration = val;
    }
}

// end class
/**
 *   represents an expression statement <br>
 *   has Statment Elements  : one lVal and 0 . . . n rVals
 */
class StatementDS {

    private StatementElement lVal = null;

    private ArrayList<StatementElement> rValList = new ArrayList<StatementElement>();

    public static enum statementType {

        PreInc, PostInc, Assignment, MethodCall
    }

    private statementType type = null;

    private boolean isInSelection = false;

    private boolean isInIteration = false;

    statementType getType() {
        return type;
    }

    /**
     * add a rVal to the list
     * @param rv StatementElement
     */
    void addRVal(StatementElement rv) {
        rValList.add(rv);
    }

    /**
     * set statement type: see  enum statementType
     * @param t statementType
     */
    void setType(statementType t) {
        type = t;
    }

    /**
     * get a reference to the list of rVals
     * @return ArrayList
     */
    ArrayList<StatementElement> getRVals() {
        return rValList;
    }

    /**
     * override of toString contains information for debugging
     * @return String
     */
    public String toString() {
        String tmp = lVal.toString();
        tmp += "" : "" + type.toString();
        if (this.isInIteration()) {
            tmp += "" (Iteration) "";
        }
        if (this.isInSelection()) {
            tmp += "" (Selection) "";
        }
        for (StatementElement rVal : rValList) {
            tmp += "" := "" + rVal.toString();
        }
        return tmp;
    }

    /**
     * setter for the LVal
     * @param rv StatementElement
     */
    void setLVal(StatementElement rv) {
        lVal = rv;
    }

    /**
     * setter for the LVal
     * @param id String
     */
    void setLVal(String id) {
        lVal = new StatementElement(id);
    }

    /**
     * getter for the LVal
     * @return StatementElement
     */
    StatementElement getLVal() {
        return lVal;
    }

    /**
     * getter for the boolean flag isInSelection
     * @return boolean
     */
    boolean isInSelection() {
        return isInSelection;
    }

    /**
     * getter for the boolean flag isInIteration
     * @return boolean
     */
    boolean isInIteration() {
        return isInIteration;
    }

    /**
     * setter for isInSelection
     * @param val boolean
     */
    void setInSelection(boolean val) {
        isInSelection = val;
    }

    /**
     * setter for isInIteration
     * @param val boolean
     */
    void setInIteration(boolean val) {
        isInIteration = val;
    }
}
","// JMCAAnalyzerTest.java
package com.soops.CEN4010.JMCA;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAAnalyzer}.
* It contains one unit test case for the {@link JMCAAnalyzer#analyze(ASTNode)} method.
*/
class JMCAAnalyzerTest {","// JMCAAnalyzerTest.java
package com.soops.CEN4010.JMCA;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAAnalyzer}.
* It contains one unit test case for the {@link JMCAAnalyzer#analyze(ASTNode)} method.
*/
class JMCAAnalyzerTest {
"
