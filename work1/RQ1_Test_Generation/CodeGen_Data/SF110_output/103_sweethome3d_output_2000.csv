ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
9c132be1-bdfb-4c7e-89b1-baa1581b8dcb,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/URLContent.java,36.71673560142517,stop,"// URLContent.java
/*
 * URLContent.java 25 avr. 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.tools;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import com.eteks.sweethome3d.model.Content;

/**
 * URL content for files, images...
 * @author Emmanuel Puybaret
 */
public class URLContent implements Content {

    private static final long serialVersionUID = 1L;

    private URL url;

    public URLContent(URL url) {
        this.url = url;
    }

    /**
     * Returns the URL of this content.
     */
    public URL getURL() {
        return this.url;
    }

    /**
     * Returns an InputStream on the URL content.
     * @throws IOException if URL stream can't be opened.
     */
    public InputStream openStream() throws IOException {
        return this.url.openStream();
    }

    /**
     * Returns <code>true</code> if the URL stored by this content
     * references an entry in a JAR.
     */
    public boolean isJAREntry() {
        return ""jar"".equals(this.url.getProtocol());
    }

    /**
     * Returns the URL base of a JAR entry.
     * @throws IllegalStateException if the URL of this content
     *                    doesn't reference an entry in a JAR.
     */
    public URL getJAREntryURL() {
        if (!isJAREntry()) {
            throw new IllegalStateException(""Content isn't a JAR entry"");
        }
        try {
            String file = this.url.getFile();
            return new URL(file.substring(0, file.indexOf('!')));
        } catch (MalformedURLException ex) {
            throw new IllegalStateException(""Invalid URL base for JAR entry"", ex);
        }
    }

    /**
     * Returns the name of a JAR entry.
     * If the JAR entry in the URL given at creation time was encoded in application/x-www-form-urlencoded format,
     * this method will return it unchanged and not decoded.
     * @throws IllegalStateException if the URL of this content
     *                    doesn't reference an entry in a JAR URL.
     */
    public String getJAREntryName() {
        if (!isJAREntry()) {
            throw new IllegalStateException(""Content isn't a JAR entry"");
        }
        String file = this.url.getFile();
        return file.substring(file.indexOf('!') + 2);
    }

    /**
     * Returns <code>true</code> if the object in parameter is an URL content
     * that references the same URL as this object.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        } else if (obj instanceof URLContent) {
            URLContent urlContent = (URLContent) obj;
            return urlContent.url == this.url || urlContent.url.equals(this.url);
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return this.url.hashCode();
    }
}
","// URLContentTest.java
package com.eteks.sweethome3d.tools;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import com.eteks.sweethome3d.model.Content;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link URLContent}.
* It contains one unit test case for the {@link URLContent#openStream()} method.
*/
class URLContentTest {","// URLContentTest.java
package com.eteks.sweethome3d.tools;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import com.eteks.sweethome3d.model.Content;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link URLContent}.
* It contains one unit test case for the {@link URLContent#openStream()} method.
*/
class URLContentTest {
 
    /**
     * Test of the openStream method, of class URLContent.
     */
    @Test
    void testOpenStream() {
        System.out.println(""openStream"");
        URL url = null;
        try {
            url = new URL(""http://foobar.com/foobar.txt"");
        } catch (MalformedURLException e) {
            fail(""MalformedURLException expected"");
        }
        InputStream in = null;
        try {	
            in = url.openStream();		
        } catch (IOException e) {
            fail(""IOException expected"");
        }

        assertTrue(url.equals(new URL(""http://foobar.com/foobar.txt"")));
		
        assertTrue(in.read() == 0);
        try {	
            in.close();
        } catch (IOException e) {
            fail(""IOException expected"");
        }
    }
}
"
7368f1d2-94c7-445b-a5cd-cd540df613b3,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// OperatingSystem.java
/*
 * OperatingSystem.java 1 nov. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
        // Retrieve sub folders where is stored application data
        ResourceBundle resource = ResourceBundle.getBundle(OperatingSystem.class.getName());
        if (OperatingSystem.isMacOSX()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Mac OS X"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Mac OS X"");
        } else if (OperatingSystem.isWindows()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Windows"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Windows"");
        } else {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder"");
        }
        String temporarySubFolder;
        try {
            temporarySubFolder = resource.getString(""temporarySubFolder"");
            if (temporarySubFolder.trim().length() == 0) {
                temporarySubFolder = null;
            }
        } catch (MissingResourceException ex) {
            temporarySubFolder = ""work"";
        }
        try {
            temporarySubFolder = System.getProperty(""com.eteks.sweethome3d.tools.temporarySubFolder"", temporarySubFolder);
        } catch (AccessControlException ex) {
            // Don't change temporarySubFolder value
        }
        TEMPORARY_SUB_FOLDER = temporarySubFolder;
        TEMPORARY_SESSION_SUB_FOLDER = UUID.randomUUID().toString();
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux() {
        return System.getProperty(""os.name"").startsWith(""Linux"");
    }

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows() {
        return System.getProperty(""os.name"").startsWith(""Windows"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX() {
        return System.getProperty(""os.name"").startsWith(""Mac OS X"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior() {
        // Just need to test is OS version is different of 10.4 because Sweet Home 3D
        // isn't supported under Mac OS X versions previous to 10.4
        return isMacOSX() && !System.getProperty(""os.version"").startsWith(""10.4"");
    }

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException {
        File temporaryFolder;
        try {
            temporaryFolder = getDefaultTemporaryFolder(true);
        } catch (IOException ex) {
            // In case creating default temporary folder failed, use default temporary files folder
            temporaryFolder = null;
        }
        File temporaryFile = File.createTempFile(prefix, suffix, temporaryFolder);
        temporaryFile.deleteOnExit();
        return temporaryFile;
    }

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles() {
        try {
            File temporaryFolder = getDefaultTemporaryFolder(false);
            if (temporaryFolder != null) {
                for (File temporaryFile : temporaryFolder.listFiles()) {
                    temporaryFile.delete();
                }
                temporaryFolder.delete();
            }
        } catch (IOException ex) {
            // Ignore temporary folder that can't be found
        } catch (AccessControlException ex) {
        }
    }

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException {
        if (TEMPORARY_SUB_FOLDER != null) {
            File temporaryFolder = new File(getDefaultApplicationFolder(), TEMPORARY_SUB_FOLDER);
            final String versionPrefix = Home.CURRENT_VERSION + ""-"";
            final File sessionTemporaryFolder = new File(temporaryFolder, versionPrefix + TEMPORARY_SESSION_SUB_FOLDER);
            if (!sessionTemporaryFolder.exists()) {
                // Retrieve existing folders working with same Sweet Home 3D version in temporary folder
                final File[] siblingTemporaryFolders = temporaryFolder.listFiles(new FileFilter() {

                    public boolean accept(File file) {
                        return file.isDirectory() && file.getName().startsWith(versionPrefix);
                    }
                });
                // Create temporary folder
                if (!sessionTemporaryFolder.mkdirs()) {
                    throw new IOException(""Can't create temporary folder "" + sessionTemporaryFolder);
                } else {
                    sessionTemporaryFolder.deleteOnExit();
                }
                // Launch a timer that updates modification date of the temporary folder each minute
                final long updateDelay = 60000;
                new Timer(true).schedule(new TimerTask() {

                    @Override
                    public void run() {
                        // Ensure modification date is always growing in case system time was adjusted
                        sessionTemporaryFolder.setLastModified(Math.max(System.currentTimeMillis(), sessionTemporaryFolder.lastModified() + updateDelay));
                    }
                }, updateDelay, updateDelay);
                if (siblingTemporaryFolders != null && siblingTemporaryFolders.length > 0) {
                    // Launch a timer that will delete in 10 min temporary folders older than a week
                    final long deleteDelay = 10 * 60000;
                    final long age = 7 * 24 * 3600000;
                    new Timer(true).schedule(new TimerTask() {

                        @Override
                        public void run() {
                            long now = System.currentTimeMillis();
                            for (File siblingTemporaryFolder : siblingTemporaryFolders) {
                                if (siblingTemporaryFolder.exists() && now - siblingTemporaryFolder.lastModified() > age) {
                                    File[] temporaryFiles = siblingTemporaryFolder.listFiles();
                                    for (File temporaryFile : temporaryFiles) {
                                        temporaryFile.delete();
                                    }
                                    siblingTemporaryFolder.delete();
                                }
                            }
                        }
                    }, deleteDelay);
                }
            }
            return sessionTemporaryFolder;
        } else {
            return null;
        }
    }

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException {
        File userApplicationFolder;
        if (isMacOSX()) {
            userApplicationFolder = new File(MacOSXFileManager.getApplicationSupportFolder());
        } else if (isWindows()) {
            userApplicationFolder = new File(System.getProperty(""user.home""), ""Application Data"");
            // If user Application Data directory doesn't exist, use user home
            if (!userApplicationFolder.exists()) {
                userApplicationFolder = new File(System.getProperty(""user.home""));
            }
        } else {
            // Unix
            userApplicationFolder = new File(System.getProperty(""user.home""));
        }
        return new File(userApplicationFolder, EDITOR_SUB_FOLDER + File.separator + APPLICATION_SUB_FOLDER);
    }

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_0Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_0Test {","// OperatingSystem_0Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isLinux()} method.
*/
class OperatingSystem_0Test {
"
293ea9b5-6586-4e59-9f8a-ba6adff776f3,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// OperatingSystem.java
/*
 * OperatingSystem.java 1 nov. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
        // Retrieve sub folders where is stored application data
        ResourceBundle resource = ResourceBundle.getBundle(OperatingSystem.class.getName());
        if (OperatingSystem.isMacOSX()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Mac OS X"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Mac OS X"");
        } else if (OperatingSystem.isWindows()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Windows"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Windows"");
        } else {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder"");
        }
        String temporarySubFolder;
        try {
            temporarySubFolder = resource.getString(""temporarySubFolder"");
            if (temporarySubFolder.trim().length() == 0) {
                temporarySubFolder = null;
            }
        } catch (MissingResourceException ex) {
            temporarySubFolder = ""work"";
        }
        try {
            temporarySubFolder = System.getProperty(""com.eteks.sweethome3d.tools.temporarySubFolder"", temporarySubFolder);
        } catch (AccessControlException ex) {
            // Don't change temporarySubFolder value
        }
        TEMPORARY_SUB_FOLDER = temporarySubFolder;
        TEMPORARY_SESSION_SUB_FOLDER = UUID.randomUUID().toString();
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux() {
        return System.getProperty(""os.name"").startsWith(""Linux"");
    }

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows() {
        return System.getProperty(""os.name"").startsWith(""Windows"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX() {
        return System.getProperty(""os.name"").startsWith(""Mac OS X"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior() {
        // Just need to test is OS version is different of 10.4 because Sweet Home 3D
        // isn't supported under Mac OS X versions previous to 10.4
        return isMacOSX() && !System.getProperty(""os.version"").startsWith(""10.4"");
    }

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException {
        File temporaryFolder;
        try {
            temporaryFolder = getDefaultTemporaryFolder(true);
        } catch (IOException ex) {
            // In case creating default temporary folder failed, use default temporary files folder
            temporaryFolder = null;
        }
        File temporaryFile = File.createTempFile(prefix, suffix, temporaryFolder);
        temporaryFile.deleteOnExit();
        return temporaryFile;
    }

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles() {
        try {
            File temporaryFolder = getDefaultTemporaryFolder(false);
            if (temporaryFolder != null) {
                for (File temporaryFile : temporaryFolder.listFiles()) {
                    temporaryFile.delete();
                }
                temporaryFolder.delete();
            }
        } catch (IOException ex) {
            // Ignore temporary folder that can't be found
        } catch (AccessControlException ex) {
        }
    }

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException {
        if (TEMPORARY_SUB_FOLDER != null) {
            File temporaryFolder = new File(getDefaultApplicationFolder(), TEMPORARY_SUB_FOLDER);
            final String versionPrefix = Home.CURRENT_VERSION + ""-"";
            final File sessionTemporaryFolder = new File(temporaryFolder, versionPrefix + TEMPORARY_SESSION_SUB_FOLDER);
            if (!sessionTemporaryFolder.exists()) {
                // Retrieve existing folders working with same Sweet Home 3D version in temporary folder
                final File[] siblingTemporaryFolders = temporaryFolder.listFiles(new FileFilter() {

                    public boolean accept(File file) {
                        return file.isDirectory() && file.getName().startsWith(versionPrefix);
                    }
                });
                // Create temporary folder
                if (!sessionTemporaryFolder.mkdirs()) {
                    throw new IOException(""Can't create temporary folder "" + sessionTemporaryFolder);
                } else {
                    sessionTemporaryFolder.deleteOnExit();
                }
                // Launch a timer that updates modification date of the temporary folder each minute
                final long updateDelay = 60000;
                new Timer(true).schedule(new TimerTask() {

                    @Override
                    public void run() {
                        // Ensure modification date is always growing in case system time was adjusted
                        sessionTemporaryFolder.setLastModified(Math.max(System.currentTimeMillis(), sessionTemporaryFolder.lastModified() + updateDelay));
                    }
                }, updateDelay, updateDelay);
                if (siblingTemporaryFolders != null && siblingTemporaryFolders.length > 0) {
                    // Launch a timer that will delete in 10 min temporary folders older than a week
                    final long deleteDelay = 10 * 60000;
                    final long age = 7 * 24 * 3600000;
                    new Timer(true).schedule(new TimerTask() {

                        @Override
                        public void run() {
                            long now = System.currentTimeMillis();
                            for (File siblingTemporaryFolder : siblingTemporaryFolders) {
                                if (siblingTemporaryFolder.exists() && now - siblingTemporaryFolder.lastModified() > age) {
                                    File[] temporaryFiles = siblingTemporaryFolder.listFiles();
                                    for (File temporaryFile : temporaryFiles) {
                                        temporaryFile.delete();
                                    }
                                    siblingTemporaryFolder.delete();
                                }
                            }
                        }
                    }, deleteDelay);
                }
            }
            return sessionTemporaryFolder;
        } else {
            return null;
        }
    }

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException {
        File userApplicationFolder;
        if (isMacOSX()) {
            userApplicationFolder = new File(MacOSXFileManager.getApplicationSupportFolder());
        } else if (isWindows()) {
            userApplicationFolder = new File(System.getProperty(""user.home""), ""Application Data"");
            // If user Application Data directory doesn't exist, use user home
            if (!userApplicationFolder.exists()) {
                userApplicationFolder = new File(System.getProperty(""user.home""));
            }
        } else {
            // Unix
            userApplicationFolder = new File(System.getProperty(""user.home""));
        }
        return new File(userApplicationFolder, EDITOR_SUB_FOLDER + File.separator + APPLICATION_SUB_FOLDER);
    }

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_1Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isWindows()} method.
*/
class OperatingSystem_1Test {","// OperatingSystem_1Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isWindows()} method.
*/
class OperatingSystem_1Test {
"
e44018c0-d90f-402f-b7be-9e0154b97879,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_2Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// OperatingSystem.java
/*
 * OperatingSystem.java 1 nov. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
        // Retrieve sub folders where is stored application data
        ResourceBundle resource = ResourceBundle.getBundle(OperatingSystem.class.getName());
        if (OperatingSystem.isMacOSX()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Mac OS X"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Mac OS X"");
        } else if (OperatingSystem.isWindows()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Windows"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Windows"");
        } else {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder"");
        }
        String temporarySubFolder;
        try {
            temporarySubFolder = resource.getString(""temporarySubFolder"");
            if (temporarySubFolder.trim().length() == 0) {
                temporarySubFolder = null;
            }
        } catch (MissingResourceException ex) {
            temporarySubFolder = ""work"";
        }
        try {
            temporarySubFolder = System.getProperty(""com.eteks.sweethome3d.tools.temporarySubFolder"", temporarySubFolder);
        } catch (AccessControlException ex) {
            // Don't change temporarySubFolder value
        }
        TEMPORARY_SUB_FOLDER = temporarySubFolder;
        TEMPORARY_SESSION_SUB_FOLDER = UUID.randomUUID().toString();
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux() {
        return System.getProperty(""os.name"").startsWith(""Linux"");
    }

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows() {
        return System.getProperty(""os.name"").startsWith(""Windows"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX() {
        return System.getProperty(""os.name"").startsWith(""Mac OS X"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior() {
        // Just need to test is OS version is different of 10.4 because Sweet Home 3D
        // isn't supported under Mac OS X versions previous to 10.4
        return isMacOSX() && !System.getProperty(""os.version"").startsWith(""10.4"");
    }

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException {
        File temporaryFolder;
        try {
            temporaryFolder = getDefaultTemporaryFolder(true);
        } catch (IOException ex) {
            // In case creating default temporary folder failed, use default temporary files folder
            temporaryFolder = null;
        }
        File temporaryFile = File.createTempFile(prefix, suffix, temporaryFolder);
        temporaryFile.deleteOnExit();
        return temporaryFile;
    }

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles() {
        try {
            File temporaryFolder = getDefaultTemporaryFolder(false);
            if (temporaryFolder != null) {
                for (File temporaryFile : temporaryFolder.listFiles()) {
                    temporaryFile.delete();
                }
                temporaryFolder.delete();
            }
        } catch (IOException ex) {
            // Ignore temporary folder that can't be found
        } catch (AccessControlException ex) {
        }
    }

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException {
        if (TEMPORARY_SUB_FOLDER != null) {
            File temporaryFolder = new File(getDefaultApplicationFolder(), TEMPORARY_SUB_FOLDER);
            final String versionPrefix = Home.CURRENT_VERSION + ""-"";
            final File sessionTemporaryFolder = new File(temporaryFolder, versionPrefix + TEMPORARY_SESSION_SUB_FOLDER);
            if (!sessionTemporaryFolder.exists()) {
                // Retrieve existing folders working with same Sweet Home 3D version in temporary folder
                final File[] siblingTemporaryFolders = temporaryFolder.listFiles(new FileFilter() {

                    public boolean accept(File file) {
                        return file.isDirectory() && file.getName().startsWith(versionPrefix);
                    }
                });
                // Create temporary folder
                if (!sessionTemporaryFolder.mkdirs()) {
                    throw new IOException(""Can't create temporary folder "" + sessionTemporaryFolder);
                } else {
                    sessionTemporaryFolder.deleteOnExit();
                }
                // Launch a timer that updates modification date of the temporary folder each minute
                final long updateDelay = 60000;
                new Timer(true).schedule(new TimerTask() {

                    @Override
                    public void run() {
                        // Ensure modification date is always growing in case system time was adjusted
                        sessionTemporaryFolder.setLastModified(Math.max(System.currentTimeMillis(), sessionTemporaryFolder.lastModified() + updateDelay));
                    }
                }, updateDelay, updateDelay);
                if (siblingTemporaryFolders != null && siblingTemporaryFolders.length > 0) {
                    // Launch a timer that will delete in 10 min temporary folders older than a week
                    final long deleteDelay = 10 * 60000;
                    final long age = 7 * 24 * 3600000;
                    new Timer(true).schedule(new TimerTask() {

                        @Override
                        public void run() {
                            long now = System.currentTimeMillis();
                            for (File siblingTemporaryFolder : siblingTemporaryFolders) {
                                if (siblingTemporaryFolder.exists() && now - siblingTemporaryFolder.lastModified() > age) {
                                    File[] temporaryFiles = siblingTemporaryFolder.listFiles();
                                    for (File temporaryFile : temporaryFiles) {
                                        temporaryFile.delete();
                                    }
                                    siblingTemporaryFolder.delete();
                                }
                            }
                        }
                    }, deleteDelay);
                }
            }
            return sessionTemporaryFolder;
        } else {
            return null;
        }
    }

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException {
        File userApplicationFolder;
        if (isMacOSX()) {
            userApplicationFolder = new File(MacOSXFileManager.getApplicationSupportFolder());
        } else if (isWindows()) {
            userApplicationFolder = new File(System.getProperty(""user.home""), ""Application Data"");
            // If user Application Data directory doesn't exist, use user home
            if (!userApplicationFolder.exists()) {
                userApplicationFolder = new File(System.getProperty(""user.home""));
            }
        } else {
            // Unix
            userApplicationFolder = new File(System.getProperty(""user.home""));
        }
        return new File(userApplicationFolder, EDITOR_SUB_FOLDER + File.separator + APPLICATION_SUB_FOLDER);
    }

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isMacOSX()} method.
*/
class OperatingSystem_2Test {","// OperatingSystem_2Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isMacOSX()} method.
*/
class OperatingSystem_2Test {
"
11777cbe-cf5a-4f6e-9927-e2b4de8fb20a,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// OperatingSystem.java
/*
 * OperatingSystem.java 1 nov. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
        // Retrieve sub folders where is stored application data
        ResourceBundle resource = ResourceBundle.getBundle(OperatingSystem.class.getName());
        if (OperatingSystem.isMacOSX()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Mac OS X"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Mac OS X"");
        } else if (OperatingSystem.isWindows()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Windows"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Windows"");
        } else {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder"");
        }
        String temporarySubFolder;
        try {
            temporarySubFolder = resource.getString(""temporarySubFolder"");
            if (temporarySubFolder.trim().length() == 0) {
                temporarySubFolder = null;
            }
        } catch (MissingResourceException ex) {
            temporarySubFolder = ""work"";
        }
        try {
            temporarySubFolder = System.getProperty(""com.eteks.sweethome3d.tools.temporarySubFolder"", temporarySubFolder);
        } catch (AccessControlException ex) {
            // Don't change temporarySubFolder value
        }
        TEMPORARY_SUB_FOLDER = temporarySubFolder;
        TEMPORARY_SESSION_SUB_FOLDER = UUID.randomUUID().toString();
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux() {
        return System.getProperty(""os.name"").startsWith(""Linux"");
    }

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows() {
        return System.getProperty(""os.name"").startsWith(""Windows"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX() {
        return System.getProperty(""os.name"").startsWith(""Mac OS X"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior() {
        // Just need to test is OS version is different of 10.4 because Sweet Home 3D
        // isn't supported under Mac OS X versions previous to 10.4
        return isMacOSX() && !System.getProperty(""os.version"").startsWith(""10.4"");
    }

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException {
        File temporaryFolder;
        try {
            temporaryFolder = getDefaultTemporaryFolder(true);
        } catch (IOException ex) {
            // In case creating default temporary folder failed, use default temporary files folder
            temporaryFolder = null;
        }
        File temporaryFile = File.createTempFile(prefix, suffix, temporaryFolder);
        temporaryFile.deleteOnExit();
        return temporaryFile;
    }

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles() {
        try {
            File temporaryFolder = getDefaultTemporaryFolder(false);
            if (temporaryFolder != null) {
                for (File temporaryFile : temporaryFolder.listFiles()) {
                    temporaryFile.delete();
                }
                temporaryFolder.delete();
            }
        } catch (IOException ex) {
            // Ignore temporary folder that can't be found
        } catch (AccessControlException ex) {
        }
    }

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException {
        if (TEMPORARY_SUB_FOLDER != null) {
            File temporaryFolder = new File(getDefaultApplicationFolder(), TEMPORARY_SUB_FOLDER);
            final String versionPrefix = Home.CURRENT_VERSION + ""-"";
            final File sessionTemporaryFolder = new File(temporaryFolder, versionPrefix + TEMPORARY_SESSION_SUB_FOLDER);
            if (!sessionTemporaryFolder.exists()) {
                // Retrieve existing folders working with same Sweet Home 3D version in temporary folder
                final File[] siblingTemporaryFolders = temporaryFolder.listFiles(new FileFilter() {

                    public boolean accept(File file) {
                        return file.isDirectory() && file.getName().startsWith(versionPrefix);
                    }
                });
                // Create temporary folder
                if (!sessionTemporaryFolder.mkdirs()) {
                    throw new IOException(""Can't create temporary folder "" + sessionTemporaryFolder);
                } else {
                    sessionTemporaryFolder.deleteOnExit();
                }
                // Launch a timer that updates modification date of the temporary folder each minute
                final long updateDelay = 60000;
                new Timer(true).schedule(new TimerTask() {

                    @Override
                    public void run() {
                        // Ensure modification date is always growing in case system time was adjusted
                        sessionTemporaryFolder.setLastModified(Math.max(System.currentTimeMillis(), sessionTemporaryFolder.lastModified() + updateDelay));
                    }
                }, updateDelay, updateDelay);
                if (siblingTemporaryFolders != null && siblingTemporaryFolders.length > 0) {
                    // Launch a timer that will delete in 10 min temporary folders older than a week
                    final long deleteDelay = 10 * 60000;
                    final long age = 7 * 24 * 3600000;
                    new Timer(true).schedule(new TimerTask() {

                        @Override
                        public void run() {
                            long now = System.currentTimeMillis();
                            for (File siblingTemporaryFolder : siblingTemporaryFolders) {
                                if (siblingTemporaryFolder.exists() && now - siblingTemporaryFolder.lastModified() > age) {
                                    File[] temporaryFiles = siblingTemporaryFolder.listFiles();
                                    for (File temporaryFile : temporaryFiles) {
                                        temporaryFile.delete();
                                    }
                                    siblingTemporaryFolder.delete();
                                }
                            }
                        }
                    }, deleteDelay);
                }
            }
            return sessionTemporaryFolder;
        } else {
            return null;
        }
    }

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException {
        File userApplicationFolder;
        if (isMacOSX()) {
            userApplicationFolder = new File(MacOSXFileManager.getApplicationSupportFolder());
        } else if (isWindows()) {
            userApplicationFolder = new File(System.getProperty(""user.home""), ""Application Data"");
            // If user Application Data directory doesn't exist, use user home
            if (!userApplicationFolder.exists()) {
                userApplicationFolder = new File(System.getProperty(""user.home""));
            }
        } else {
            // Unix
            userApplicationFolder = new File(System.getProperty(""user.home""));
        }
        return new File(userApplicationFolder, EDITOR_SUB_FOLDER + File.separator + APPLICATION_SUB_FOLDER);
    }

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isMacOSXLeopardOrSuperior()} method.
*/
class OperatingSystem_3Test {","// OperatingSystem_3Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#isMacOSXLeopardOrSuperior()} method.
*/
class OperatingSystem_3Test {
"
d161f4e6-4e41-4238-add2-5e812a95c85c,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/tools/OperatingSystem_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// OperatingSystem.java
/*
 * OperatingSystem.java 1 nov. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;

/**
 * Tools used to test current user operating system.
 * @author Emmanuel Puybaret
 */
public class OperatingSystem {

    private static final String EDITOR_SUB_FOLDER;

    private static final String APPLICATION_SUB_FOLDER;

    private static final String TEMPORARY_SUB_FOLDER;

    private static final String TEMPORARY_SESSION_SUB_FOLDER;

    static {
        // Retrieve sub folders where is stored application data
        ResourceBundle resource = ResourceBundle.getBundle(OperatingSystem.class.getName());
        if (OperatingSystem.isMacOSX()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Mac OS X"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Mac OS X"");
        } else if (OperatingSystem.isWindows()) {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder.Windows"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder.Windows"");
        } else {
            EDITOR_SUB_FOLDER = resource.getString(""editorSubFolder"");
            APPLICATION_SUB_FOLDER = resource.getString(""applicationSubFolder"");
        }
        String temporarySubFolder;
        try {
            temporarySubFolder = resource.getString(""temporarySubFolder"");
            if (temporarySubFolder.trim().length() == 0) {
                temporarySubFolder = null;
            }
        } catch (MissingResourceException ex) {
            temporarySubFolder = ""work"";
        }
        try {
            temporarySubFolder = System.getProperty(""com.eteks.sweethome3d.tools.temporarySubFolder"", temporarySubFolder);
        } catch (AccessControlException ex) {
            // Don't change temporarySubFolder value
        }
        TEMPORARY_SUB_FOLDER = temporarySubFolder;
        TEMPORARY_SESSION_SUB_FOLDER = UUID.randomUUID().toString();
    }

    // This class contains only static methods
    private OperatingSystem() {
    }

    /**
     * Returns <code>true</code> if current operating is Linux.
     */
    public static boolean isLinux() {
        return System.getProperty(""os.name"").startsWith(""Linux"");
    }

    /**
     * Returns <code>true</code> if current operating is Windows.
     */
    public static boolean isWindows() {
        return System.getProperty(""os.name"").startsWith(""Windows"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X.
     */
    public static boolean isMacOSX() {
        return System.getProperty(""os.name"").startsWith(""Mac OS X"");
    }

    /**
     * Returns <code>true</code> if current operating is Mac OS X 10.5
     * or superior.
     */
    public static boolean isMacOSXLeopardOrSuperior() {
        // Just need to test is OS version is different of 10.4 because Sweet Home 3D
        // isn't supported under Mac OS X versions previous to 10.4
        return isMacOSX() && !System.getProperty(""os.version"").startsWith(""10.4"");
    }

    /**
     * Returns a temporary file that will be deleted when JVM will exit.
     * @throws IOException if the file couldn't be created
     */
    public static File createTemporaryFile(String prefix, String suffix) throws IOException {
        File temporaryFolder;
        try {
            temporaryFolder = getDefaultTemporaryFolder(true);
        } catch (IOException ex) {
            // In case creating default temporary folder failed, use default temporary files folder
            temporaryFolder = null;
        }
        File temporaryFile = File.createTempFile(prefix, suffix, temporaryFolder);
        temporaryFile.deleteOnExit();
        return temporaryFile;
    }

    /**
     * Deletes all the temporary files created with {@link #createTemporaryFile(String, String) createTemporaryFile}.
     */
    public static void deleteTemporaryFiles() {
        try {
            File temporaryFolder = getDefaultTemporaryFolder(false);
            if (temporaryFolder != null) {
                for (File temporaryFile : temporaryFolder.listFiles()) {
                    temporaryFile.delete();
                }
                temporaryFolder.delete();
            }
        } catch (IOException ex) {
            // Ignore temporary folder that can't be found
        } catch (AccessControlException ex) {
        }
    }

    /**
     * Returns the default folder used to store temporary files created in the program.
     */
    private synchronized static File getDefaultTemporaryFolder(boolean create) throws IOException {
        if (TEMPORARY_SUB_FOLDER != null) {
            File temporaryFolder = new File(getDefaultApplicationFolder(), TEMPORARY_SUB_FOLDER);
            final String versionPrefix = Home.CURRENT_VERSION + ""-"";
            final File sessionTemporaryFolder = new File(temporaryFolder, versionPrefix + TEMPORARY_SESSION_SUB_FOLDER);
            if (!sessionTemporaryFolder.exists()) {
                // Retrieve existing folders working with same Sweet Home 3D version in temporary folder
                final File[] siblingTemporaryFolders = temporaryFolder.listFiles(new FileFilter() {

                    public boolean accept(File file) {
                        return file.isDirectory() && file.getName().startsWith(versionPrefix);
                    }
                });
                // Create temporary folder
                if (!sessionTemporaryFolder.mkdirs()) {
                    throw new IOException(""Can't create temporary folder "" + sessionTemporaryFolder);
                } else {
                    sessionTemporaryFolder.deleteOnExit();
                }
                // Launch a timer that updates modification date of the temporary folder each minute
                final long updateDelay = 60000;
                new Timer(true).schedule(new TimerTask() {

                    @Override
                    public void run() {
                        // Ensure modification date is always growing in case system time was adjusted
                        sessionTemporaryFolder.setLastModified(Math.max(System.currentTimeMillis(), sessionTemporaryFolder.lastModified() + updateDelay));
                    }
                }, updateDelay, updateDelay);
                if (siblingTemporaryFolders != null && siblingTemporaryFolders.length > 0) {
                    // Launch a timer that will delete in 10 min temporary folders older than a week
                    final long deleteDelay = 10 * 60000;
                    final long age = 7 * 24 * 3600000;
                    new Timer(true).schedule(new TimerTask() {

                        @Override
                        public void run() {
                            long now = System.currentTimeMillis();
                            for (File siblingTemporaryFolder : siblingTemporaryFolders) {
                                if (siblingTemporaryFolder.exists() && now - siblingTemporaryFolder.lastModified() > age) {
                                    File[] temporaryFiles = siblingTemporaryFolder.listFiles();
                                    for (File temporaryFile : temporaryFiles) {
                                        temporaryFile.delete();
                                    }
                                    siblingTemporaryFolder.delete();
                                }
                            }
                        }
                    }, deleteDelay);
                }
            }
            return sessionTemporaryFolder;
        } else {
            return null;
        }
    }

    /**
     * Returns default application folder.
     */
    public static File getDefaultApplicationFolder() throws IOException {
        File userApplicationFolder;
        if (isMacOSX()) {
            userApplicationFolder = new File(MacOSXFileManager.getApplicationSupportFolder());
        } else if (isWindows()) {
            userApplicationFolder = new File(System.getProperty(""user.home""), ""Application Data"");
            // If user Application Data directory doesn't exist, use user home
            if (!userApplicationFolder.exists()) {
                userApplicationFolder = new File(System.getProperty(""user.home""));
            }
        } else {
            // Unix
            userApplicationFolder = new File(System.getProperty(""user.home""));
        }
        return new File(userApplicationFolder, EDITOR_SUB_FOLDER + File.separator + APPLICATION_SUB_FOLDER);
    }

    /**
     * File manager class that accesses to Mac OS X specifics.
     * Do not invoke methods of this class without checking first if
     * <code>os.name</code> System property is <code>Mac OS X</code>.
     * This class requires some classes of <code>com.apple.eio</code> package
     * to compile.
     */
    private static class MacOSXFileManager {

        public static String getApplicationSupportFolder() throws IOException {
            // Find application support folder (0x61737570) for user domain (-32763)
            return FileManager.findFolder((short) -32763, 0x61737570);
        }
    }
}
","// OperatingSystem_5Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_5Test {","// OperatingSystem_5Test.java
package com.eteks.sweethome3d.tools;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.security.AccessControlException;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import com.apple.eio.FileManager;
import com.eteks.sweethome3d.model.Home;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OperatingSystem}.
* It contains one unit test case for the {@link OperatingSystem#getDefaultApplicationFolder()} method.
*/
class OperatingSystem_5Test {
"
dc354dac-6a77-44ca-834d-b801183ad8fe,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/TextureChoiceComponent.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// TextureChoiceComponent.java
/*
 * TextureButton.java 05 oct. 2007
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.TransferHandler;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.HomeTexture;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceController;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * Button displaying a texture as an icon. When the user clicks
 * on this button a dialog appears to let him choose an other texture.
 */
public class TextureChoiceComponent extends JButton implements TextureChoiceView {

    private final UserPreferences preferences;

    /**
     * Creates a texture button.
     */
    public TextureChoiceComponent(final UserPreferences preferences, final TextureChoiceController controller) {
        this.preferences = preferences;
        JLabel dummyLabel = new JLabel(""Text"");
        Dimension iconDimension = dummyLabel.getPreferredSize();
        final int iconHeight = iconDimension.height;
        controller.addPropertyChangeListener(TextureChoiceController.Property.TEXTURE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                repaint();
            }
        });
        setIcon(new Icon() {

            public int getIconWidth() {
                return iconHeight;
            }

            public int getIconHeight() {
                return iconHeight;
            }

            public void paintIcon(Component c, Graphics g, int x, int y) {
                g.setColor(Color.BLACK);
                g.drawRect(x + 2, y + 2, iconHeight - 5, iconHeight - 5);
                HomeTexture texture = controller.getTexture();
                if (texture != null) {
                    Icon icon = IconManager.getInstance().getIcon(texture.getImage(), iconHeight - 6, TextureChoiceComponent.this);
                    if (icon.getIconWidth() != icon.getIconHeight()) {
                        Graphics2D g2D = (Graphics2D) g;
                        AffineTransform previousTransform = g2D.getTransform();
                        g2D.translate(x + 3, y + 3);
                        g2D.scale((float) icon.getIconHeight() / icon.getIconWidth(), 1);
                        icon.paintIcon(c, g2D, 0, 0);
                        g2D.setTransform(previousTransform);
                    } else {
                        icon.paintIcon(c, g, x + 3, y + 3);
                    }
                }
            }
        });
        // Add a listener to update texture
        addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                final TexturePanel texturePanel = new TexturePanel(preferences, controller);
                texturePanel.displayView(TextureChoiceComponent.this);
            }
        });
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected texture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteSelectedCatalogTexture() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(TextureChoiceComponent.class, ""confirmDeleteSelectedCatalogTexture.message"");
        String title = this.preferences.getLocalizedString(TextureChoiceComponent.class, ""confirmDeleteSelectedCatalogTexture.title"");
        String delete = this.preferences.getLocalizedString(TextureChoiceComponent.class, ""confirmDeleteSelectedCatalogTexture.delete"");
        String cancel = this.preferences.getLocalizedString(TextureChoiceComponent.class, ""confirmDeleteSelectedCatalogTexture.cancel"");
        return JOptionPane.showOptionDialog(KeyboardFocusManager.getCurrentKeyboardFocusManager().getActiveWindow(), message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * A panel that displays available textures in a list to let user make choose one.
     */
    private static class TexturePanel extends JPanel {

        private static final int PREVIEW_ICON_HEIGHT = 64;

        private TextureChoiceController controller;

        private TextureImage previewTexture;

        private JLabel chosenTextureLabel;

        private JLabel texturePreviewLabel;

        private JLabel availableTexturesLabel;

        private JList availableTexturesList;

        private JButton importTextureButton;

        private JButton modifyTextureButton;

        private JButton deleteTextureButton;

        public TexturePanel(UserPreferences preferences, TextureChoiceController controller) {
            super(new GridBagLayout());
            this.controller = controller;
            createComponents(preferences, controller);
            setMnemonics(preferences);
            layoutComponents();
        }

        /**
         * Creates and initializes components.
         */
        private void createComponents(final UserPreferences preferences, final TextureChoiceController controller) {
            this.availableTexturesLabel = new JLabel(SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""availableTexturesLabel.text""));
            this.availableTexturesList = new JList(createListModel(preferences.getTexturesCatalog()));
            this.availableTexturesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
            this.availableTexturesList.setCellRenderer(new TextureListCellRenderer());
            this.availableTexturesList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

                public void valueChanged(ListSelectionEvent ev) {
                    CatalogTexture selectedTexture = (CatalogTexture) availableTexturesList.getSelectedValue();
                    setPreviewTexture(selectedTexture);
                    if (modifyTextureButton != null) {
                        modifyTextureButton.setEnabled(selectedTexture != null && selectedTexture.isModifiable());
                    }
                    if (deleteTextureButton != null) {
                        deleteTextureButton.setEnabled(selectedTexture != null && selectedTexture.isModifiable());
                    }
                }
            });
            this.chosenTextureLabel = new JLabel(preferences.getLocalizedString(TextureChoiceComponent.class, ""chosenTextureLabel.text""));
            this.texturePreviewLabel = new JLabel() {

                private int lastIconWidth;

                @Override
                protected void paintComponent(Graphics g) {
                    // If icon width changed after its loading
                    Icon icon = getIcon();
                    if (icon != null && icon.getIconWidth() != this.lastIconWidth) {
                        // Revalidate label to layout again texture panel
                        this.lastIconWidth = icon.getIconWidth();
                        revalidate();
                    } else {
                        super.paintComponent(g);
                    }
                }

                @Override
                public void setIcon(Icon icon) {
                    if (icon != null) {
                        this.lastIconWidth = icon.getIconWidth();
                    }
                    super.setIcon(icon);
                }
            };
            // Update edited texture in texture panel
            setPreviewTexture(controller.getTexture());
            try {
                String importTextureButtonText = SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""importTextureButton.text"");
                this.texturePreviewLabel.setBorder(SwingTools.getDropableComponentBorder());
                // Add to label a transfer handler to let user drag and drop a file on it
                this.texturePreviewLabel.setTransferHandler(new TransferHandler() {

                    @Override
                    public boolean canImport(JComponent comp, DataFlavor[] flavors) {
                        return Arrays.asList(flavors).contains(DataFlavor.javaFileListFlavor);
                    }

                    @Override
                    public boolean importData(JComponent comp, Transferable transferedFiles) {
                        try {
                            List<File> files = (List<File>) transferedFiles.getTransferData(DataFlavor.javaFileListFlavor);
                            final String textureName = files.get(0).getAbsolutePath();
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    controller.importTexture(textureName);
                                }
                            });
                            return true;
                        } catch (UnsupportedFlavorException ex) {
                            return false;
                        } catch (IOException ex) {
                            return false;
                        }
                    }
                });
                this.importTextureButton = new JButton(importTextureButtonText);
                this.importTextureButton.addActionListener(new ActionListener() {

                    public void actionPerformed(ActionEvent ev) {
                        controller.importTexture();
                    }
                });
                this.modifyTextureButton = new JButton(SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""modifyTextureButton.text""));
                this.modifyTextureButton.setEnabled(false);
                this.modifyTextureButton.addActionListener(new ActionListener() {

                    public void actionPerformed(ActionEvent ev) {
                        controller.modifyTexture((CatalogTexture) availableTexturesList.getSelectedValue());
                    }
                });
                this.deleteTextureButton = new JButton(SwingTools.getLocalizedLabelText(preferences, TextureChoiceComponent.class, ""deleteTextureButton.text""));
                this.deleteTextureButton.setEnabled(false);
                this.deleteTextureButton.addActionListener(new ActionListener() {

                    public void actionPerformed(ActionEvent ev) {
                        controller.deleteTexture((CatalogTexture) availableTexturesList.getSelectedValue());
                    }
                });
                preferences.getTexturesCatalog().addTexturesListener(new TexturesCatalogListener(this));
            } catch (IllegalArgumentException ex) {
                // Do not support import texture if importTextureText isn't defined
                this.texturePreviewLabel.setBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED));
            }
        }

        /**
         * Renderer used to display the textures in list.
         */
        private static class TextureListCellRenderer extends DefaultListCellRenderer {

            private Font defaultFont;

            private Font modifiablePieceFont;

            @Override
            public Component getListCellRendererComponent(final JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                // Initialize fonts if not done
                if (this.defaultFont == null) {
                    this.defaultFont = getFont();
                    this.modifiablePieceFont = new Font(this.defaultFont.getFontName(), Font.ITALIC, this.defaultFont.getSize());
                }
                final CatalogTexture texture = (CatalogTexture) value;
                value = texture.getName();
                value = texture.getCategory().getName() + "" - "" + value;
                Component component = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                setIcon(new Icon() {

                    public int getIconWidth() {
                        return 16;
                    }

                    public int getIconHeight() {
                        return 16;
                    }

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                        Icon icon = IconManager.getInstance().getIcon(texture.getImage(), getIconHeight(), list);
                        if (icon.getIconWidth() != icon.getIconHeight()) {
                            Graphics2D g2D = (Graphics2D) g;
                            AffineTransform previousTransform = g2D.getTransform();
                            g2D.translate(x, y);
                            g2D.scale((float) icon.getIconHeight() / icon.getIconWidth(), 1);
                            icon.paintIcon(c, g2D, 0, 0);
                            g2D.setTransform(previousTransform);
                        } else {
                            icon.paintIcon(c, g, x, y);
                        }
                    }
                });
                setFont(texture.isModifiable() ? this.modifiablePieceFont : this.defaultFont);
                return component;
            }
        }

        /**
         * Catalog listener that updates textures list each time a texture
         * is deleted or added in textures catalog. This listener is bound to this component
         * with a weak reference to avoid strong link between catalog and this component.
         */
        private static class TexturesCatalogListener implements CollectionListener<CatalogTexture> {

            private WeakReference<TexturePanel> texturePanel;

            public TexturesCatalogListener(TexturePanel texturePanel) {
                this.texturePanel = new WeakReference<TexturePanel>(texturePanel);
            }

            public void collectionChanged(CollectionEvent<CatalogTexture> ev) {
                // If controller was garbage collected, remove this listener from catalog
                final TexturePanel texturePanel = this.texturePanel.get();
                if (texturePanel == null) {
                    ((TexturesCatalog) ev.getSource()).removeTexturesListener(this);
                } else {
                    texturePanel.availableTexturesList.setModel(texturePanel.createListModel((TexturesCatalog) ev.getSource()));
                    switch(ev.getType()) {
                        case ADD:
                            texturePanel.availableTexturesList.setSelectedValue(ev.getItem(), true);
                            break;
                        case DELETE:
                            texturePanel.availableTexturesList.clearSelection();
                            break;
                    }
                }
            }
        }

        /**
         * Sets components mnemonics and label / component associations.
         */
        private void setMnemonics(UserPreferences preferences) {
            if (!OperatingSystem.isMacOSX()) {
                this.availableTexturesLabel.setDisplayedMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""availableTexturesLabel.mnemonic"")).getKeyCode());
                this.availableTexturesLabel.setLabelFor(this.availableTexturesList);
                if (this.importTextureButton != null) {
                    this.importTextureButton.setMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""importTextureButton.mnemonic"")).getKeyCode());
                    this.modifyTextureButton.setMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""modifyTextureButton.mnemonic"")).getKeyCode());
                    this.deleteTextureButton.setMnemonic(KeyStroke.getKeyStroke(preferences.getLocalizedString(TextureChoiceComponent.class, ""deleteTextureButton.mnemonic"")).getKeyCode());
                }
            }
        }

        /**
         * Layouts components in panel with their labels.
         */
        private void layoutComponents() {
            // First row
            add(this.availableTexturesLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 5, 15), 0, 0));
            add(this.chosenTextureLabel, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            // Second row
            add(new JScrollPane(this.availableTexturesList), new GridBagConstraints(0, 1, 1, 2, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0, 0, 5, 15), 50, 0));
            SwingTools.installFocusBorder(this.availableTexturesList);
            add(this.texturePreviewLabel, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            if (this.importTextureButton != null) {
                // Third row
                JPanel buttonsPanel = new JPanel(new GridLayout(3, 1, 2, 2));
                buttonsPanel.add(this.importTextureButton);
                buttonsPanel.add(this.modifyTextureButton);
                buttonsPanel.add(this.deleteTextureButton);
                add(buttonsPanel, new GridBagConstraints(1, 2, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            }
        }

        /**
         * Returns the chosen texture.
         */
        public TextureImage getPreviewTexture() {
            return this.previewTexture;
        }

        /**
         * Sets the chosen texture.
         */
        public void setPreviewTexture(TextureImage previewTexture) {
            this.previewTexture = previewTexture;
            if (previewTexture != null) {
                this.texturePreviewLabel.setIcon(IconManager.getInstance().getIcon(previewTexture.getImage(), PREVIEW_ICON_HEIGHT, this.texturePreviewLabel));
            } else {
                // Preview a dummy empty icon
                this.texturePreviewLabel.setIcon(new Icon() {

                    public int getIconHeight() {
                        return PREVIEW_ICON_HEIGHT;
                    }

                    public int getIconWidth() {
                        return PREVIEW_ICON_HEIGHT;
                    }

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                    }
                });
            }
            // Update selection in texture list
            this.availableTexturesList.setSelectedValue(previewTexture, true);
            if (this.availableTexturesList.getSelectedValue() != previewTexture) {
                int selectedIndex = this.availableTexturesList.getSelectedIndex();
                this.availableTexturesList.removeSelectionInterval(selectedIndex, selectedIndex);
            }
        }

        /**
         * Returns a list model from textures catalog.
         */
        private AbstractListModel createListModel(TexturesCatalog texturesCatalog) {
            final CatalogTexture[] textures = getTextures(texturesCatalog);
            return new AbstractListModel() {

                public Object getElementAt(int index) {
                    return textures[index];
                }

                public int getSize() {
                    return textures.length;
                }
            };
        }

        /**
         * Returns the array of textures in catalog.
         */
        private CatalogTexture[] getTextures(TexturesCatalog texturesCatalog) {
            List<CatalogTexture> textures = new ArrayList<CatalogTexture>();
            for (TexturesCategory category : texturesCatalog.getCategories()) {
                for (CatalogTexture texture : category.getTextures()) {
                    textures.add(texture);
                }
            }
            return textures.toArray(new CatalogTexture[textures.size()]);
        }

        public void displayView(View textureChoiceComponent) {
            // Show panel in a resizable modal dialog
            final JOptionPane optionPane = new JOptionPane(this, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION);
            JComponent parentComponent = SwingUtilities.getRootPane((JComponent) textureChoiceComponent);
            if (parentComponent != null) {
                optionPane.setComponentOrientation(parentComponent.getComponentOrientation());
            }
            final JDialog dialog = optionPane.createDialog(parentComponent, controller.getDialogTitle());
            dialog.applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
            dialog.setResizable(true);
            // Pack again because resize decorations may have changed dialog preferred size
            dialog.pack();
            dialog.setMinimumSize(getPreferredSize());
            // Add a listener that transfer focus to focusable field of texture panel when dialog is shown
            dialog.addComponentListener(new ComponentAdapter() {

                @Override
                public void componentShown(ComponentEvent ev) {
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent(TexturePanel.this);
                    dialog.removeComponentListener(this);
                }
            });
            this.availableTexturesList.addMouseListener(new MouseAdapter() {

                @Override
                public void mouseClicked(MouseEvent ev) {
                    // Close on double clicks in texture list
                    if (ev.getClickCount() == 2) {
                        optionPane.setValue(JOptionPane.OK_OPTION);
                        availableTexturesList.removeMouseListener(this);
                    }
                }
            });
            dialog.setVisible(true);
            dialog.dispose();
            if (Integer.valueOf(JOptionPane.OK_OPTION).equals(optionPane.getValue())) {
                TextureImage selectedTexture = getPreviewTexture();
                if (selectedTexture instanceof HomeTexture || selectedTexture == null) {
                    this.controller.setTexture((HomeTexture) selectedTexture);
                } else {
                    this.controller.setTexture(new HomeTexture(selectedTexture));
                }
            }
        }
    }
}
","// TextureChoiceComponentTest.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.TransferHandler;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.HomeTexture;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceController;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureChoiceComponent}.
* It contains one unit test case for the {@link TextureChoiceComponent#confirmDeleteSelectedCatalogTexture()} method.
*/
class TextureChoiceComponentTest {","// TextureChoiceComponentTest.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.DefaultListCellRenderer;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.TransferHandler;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.HomeTexture;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceController;
import com.eteks.sweethome3d.viewcontroller.TextureChoiceView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureChoiceComponent}.
* It contains one unit test case for the {@link TextureChoiceComponent#confirmDeleteSelectedCatalogTexture()} method.
*/
class TextureChoiceComponentTest {
"
3558191d-1fc1-495f-80a9-885de355e7e3,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/SwingTools_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// SwingTools.java
/*
 * SwingTools.java 21 oct. 2008
 *
 * Sweet Home 3D, Copyright (c) 2008 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.RGBImageFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;
import javax.jnlp.UnavailableServiceException;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.AbstractBorder;
import javax.swing.border.Border;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;

/**
 * Gathers some useful tools for Swing.
 * @author Emmanuel Puybaret
 */
public class SwingTools {

    // Borders for focused views
    private static Border unfocusedViewBorder;

    private static Border focusedViewBorder;

    private SwingTools() {
        // This class contains only tools
    }

    /**
     * Updates the border of <code>component</code> with an empty border
     * changed to a colored border when it will gain focus.
     * If the <code>component</code> component is the child of a <code>JViewPort</code>
     * instance this border will be installed on its scroll pane parent.
     */
    public static void installFocusBorder(JComponent component) {
        if (unfocusedViewBorder == null) {
            Border unfocusedViewInteriorBorder = new AbstractBorder() {

                private Color topLeftColor;

                private Color botomRightColor;

                private Insets insets = new Insets(1, 1, 1, 1);

                {
                    if (OperatingSystem.isMacOSX()) {
                        this.topLeftColor = Color.GRAY;
                        this.botomRightColor = Color.LIGHT_GRAY;
                    } else {
                        this.topLeftColor = UIManager.getColor(""TextField.darkShadow"");
                        this.botomRightColor = UIManager.getColor(""TextField.shadow"");
                    }
                }

                public Insets getBorderInsets(Component c) {
                    return this.insets;
                }

                public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
                    Color previousColor = g.getColor();
                    Rectangle rect = getInteriorRectangle(c, x, y, width, height);
                    g.setColor(topLeftColor);
                    g.drawLine(rect.x - 1, rect.y - 1, rect.x + rect.width, rect.y - 1);
                    g.drawLine(rect.x - 1, rect.y - 1, rect.x - 1, rect.y + rect.height);
                    g.setColor(botomRightColor);
                    g.drawLine(rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height);
                    g.drawLine(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height);
                    g.setColor(previousColor);
                }
            };
            if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
                unfocusedViewBorder = BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(UIManager.getColor(""Panel.background""), 2), unfocusedViewInteriorBorder);
                focusedViewBorder = new AbstractBorder() {

                    private Insets insets = new Insets(3, 3, 3, 3);

                    public Insets getBorderInsets(Component c) {
                        return this.insets;
                    }

                    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
                        Color previousColor = g.getColor();
                        // Paint a gradient paint around component
                        Rectangle rect = getInteriorRectangle(c, x, y, width, height);
                        g.setColor(Color.GRAY);
                        g.drawLine(rect.x - 1, rect.y - 1, rect.x + rect.width, rect.y - 1);
                        g.drawLine(rect.x - 1, rect.y - 1, rect.x - 1, rect.y + rect.height);
                        g.setColor(Color.LIGHT_GRAY);
                        g.drawLine(rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height);
                        g.drawLine(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height);
                        Color focusColor = UIManager.getColor(""Focus.color"");
                        int transparencyOutline = 128;
                        int transparencyInline = 180;
                        if (focusColor == null) {
                            focusColor = UIManager.getColor(""textHighlight"");
                            transparencyOutline = 128;
                            transparencyInline = 255;
                        }
                        g.setColor(new Color(focusColor.getRed(), focusColor.getGreen(), focusColor.getBlue(), transparencyOutline));
                        g.drawRoundRect(rect.x - 3, rect.y - 3, rect.width + 5, rect.height + 5, 6, 6);
                        g.drawRect(rect.x - 1, rect.y - 1, rect.width + 1, rect.height + 1);
                        g.setColor(new Color(focusColor.getRed(), focusColor.getGreen(), focusColor.getBlue(), transparencyInline));
                        g.drawRoundRect(rect.x - 2, rect.y - 2, rect.width + 3, rect.height + 3, 4, 4);
                        // Draw corners
                        g.setColor(UIManager.getColor(""Panel.background""));
                        g.drawLine(rect.x - 3, rect.y - 3, rect.x - 2, rect.y - 3);
                        g.drawLine(rect.x - 3, rect.y - 2, rect.x - 3, rect.y - 2);
                        g.drawLine(rect.x + rect.width + 1, rect.y - 3, rect.x + rect.width + 2, rect.y - 3);
                        g.drawLine(rect.x + rect.width + 2, rect.y - 2, rect.x + rect.width + 2, rect.y - 2);
                        g.drawLine(rect.x - 3, rect.y + rect.height + 2, rect.x - 2, rect.y + rect.height + 2);
                        g.drawLine(rect.x - 3, rect.y + rect.height + 1, rect.x - 3, rect.y + rect.height + 1);
                        g.drawLine(rect.x + rect.width + 1, rect.y + rect.height + 2, rect.x + rect.width + 2, rect.y + rect.height + 2);
                        g.drawLine(rect.x + rect.width + 2, rect.y + rect.height + 1, rect.x + rect.width + 2, rect.y + rect.height + 1);
                        g.setColor(previousColor);
                    }
                };
            } else {
                if (OperatingSystem.isMacOSX()) {
                    unfocusedViewBorder = BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(UIManager.getColor(""Panel.background""), 1), unfocusedViewInteriorBorder);
                } else {
                    unfocusedViewBorder = BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(1, 1, 1, 1), unfocusedViewInteriorBorder);
                }
                focusedViewBorder = BorderFactory.createLineBorder(UIManager.getColor(""textHighlight""), 2);
            }
        }
        final JComponent feedbackComponent;
        if (component.getParent() instanceof JViewport && component.getParent().getParent() instanceof JScrollPane) {
            feedbackComponent = (JComponent) component.getParent().getParent();
        } else {
            feedbackComponent = component;
        }
        feedbackComponent.setBorder(unfocusedViewBorder);
        component.addFocusListener(new FocusListener() {

            public void focusLost(FocusEvent ev) {
                if (feedbackComponent.getBorder() == focusedViewBorder) {
                    feedbackComponent.setBorder(unfocusedViewBorder);
                }
            }

            public void focusGained(FocusEvent ev) {
                if (feedbackComponent.getBorder() == unfocusedViewBorder) {
                    feedbackComponent.setBorder(focusedViewBorder);
                }
            }
        });
    }

    /**
     * Updates the Swing resource bundles in use from the current Locale and class loader.
     */
    public static void updateSwingResourceLanguage() {
        updateSwingResourceLanguage(Arrays.asList(new ClassLoader[] { SwingTools.class.getClassLoader() }));
    }

    /**
     * Updates the Swing resource bundles in use from the current Locale and the class loaders of preferences.
     */
    public static void updateSwingResourceLanguage(UserPreferences preferences) {
        updateSwingResourceLanguage(preferences.getResourceClassLoaders());
    }

    /**
     * Updates the Swing resource bundles in use from the current Locale and class loaders.
     */
    private static void updateSwingResourceLanguage(List<ClassLoader> classLoaders) {
        // Read Swing localized properties because Swing doesn't update its internal strings automatically
        // when default Locale is updated (see bug http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4884480)
        updateSwingResourceBundle(""com.sun.swing.internal.plaf.metal.resources.metal"", classLoaders);
        updateSwingResourceBundle(""com.sun.swing.internal.plaf.basic.resources.basic"", classLoaders);
        if (UIManager.getLookAndFeel().getClass().getName().equals(""com.sun.java.swing.plaf.gtk.GTKLookAndFeel"")) {
            updateSwingResourceBundle(""com.sun.java.swing.plaf.gtk.resources.gtk"", classLoaders);
        } else if (UIManager.getLookAndFeel().getClass().getName().equals(""com.sun.java.swing.plaf.motif.MotifLookAndFeel"")) {
            updateSwingResourceBundle(""com.sun.java.swing.plaf.motif.resources.motif"", classLoaders);
        }
    }

    /**
     * Updates a Swing resource bundle in use from the current Locale.
     */
    private static void updateSwingResourceBundle(String swingResource, List<ClassLoader> classLoaders) {
        ResourceBundle resource = ResourceBundle.getBundle(swingResource, Locale.ENGLISH);
        try {
            Locale defaultLocale = Locale.getDefault();
            for (ClassLoader classLoader : classLoaders) {
                ResourceBundle bundle = ResourceBundle.getBundle(swingResource, defaultLocale, classLoader);
                if (defaultLocale.equals(bundle.getLocale())) {
                    resource = bundle;
                    break;
                } else if (!resource.getLocale().getLanguage().equals(bundle.getLocale().getLanguage()) && defaultLocale.getLanguage().equals(bundle.getLocale().getLanguage())) {
                    resource = bundle;
                    // Don't break in case a bundle with language + country is found with an other class loader
                }
            }
        } catch (MissingResourceException ex) {
        }
        // Update UIManager properties
        for (Enumeration<?> it = resource.getKeys(); it.hasMoreElements(); ) {
            String property = (String) it.nextElement();
            UIManager.put(property, resource.getString(property));
        }
    }

    /**
     * Returns a localized text for menus items and labels depending on the system.
     */
    public static String getLocalizedLabelText(UserPreferences preferences, Class<?> resourceClass, String resourceKey, Object... resourceParameters) {
        String localizedString = preferences.getLocalizedString(resourceClass, resourceKey, resourceParameters);
        // Under Mac OS X, remove bracketed upper case roman letter used in oriental languages to indicate mnemonic
        String language = Locale.getDefault().getLanguage();
        if (OperatingSystem.isMacOSX() && (language.equals(Locale.CHINESE.getLanguage()) || language.equals(Locale.JAPANESE.getLanguage()) || language.equals(Locale.KOREAN.getLanguage()))) {
            int openingBracketIndex = localizedString.indexOf('(');
            if (openingBracketIndex != -1) {
                int closingBracketIndex = localizedString.indexOf(')');
                if (openingBracketIndex == closingBracketIndex - 2) {
                    char c = localizedString.charAt(openingBracketIndex + 1);
                    if (c >= 'A' && c <= 'Z') {
                        localizedString = localizedString.substring(0, openingBracketIndex) + localizedString.substring(closingBracketIndex + 1);
                    }
                }
            }
        }
        return localizedString;
    }

    /**
     * Adds focus and mouse listeners to the given <code>textComponent</code> that will
     * select all its text when it gains focus by transfer.
     */
    public static void addAutoSelectionOnFocusGain(final JTextComponent textComponent) {
        // A focus and mouse listener able to select text field characters
        // when it gains focus after a focus transfer
        class SelectionOnFocusManager extends MouseAdapter implements FocusListener {

            private boolean mousePressedInTextField = false;

            private int selectionStartBeforeFocusLost = -1;

            private int selectionEndBeforeFocusLost = -1;

            @Override
            public void mousePressed(MouseEvent ev) {
                this.mousePressedInTextField = true;
                this.selectionStartBeforeFocusLost = -1;
            }

            public void focusLost(FocusEvent ev) {
                if (ev.getOppositeComponent() == null || SwingUtilities.getWindowAncestor(ev.getOppositeComponent()) != SwingUtilities.getWindowAncestor(textComponent)) {
                    // Keep selection indices when focus on text field is transfered
                    // to an other window
                    this.selectionStartBeforeFocusLost = textComponent.getSelectionStart();
                    this.selectionEndBeforeFocusLost = textComponent.getSelectionEnd();
                } else {
                    this.selectionStartBeforeFocusLost = -1;
                }
            }

            public void focusGained(FocusEvent ev) {
                if (this.selectionStartBeforeFocusLost != -1) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            // Reselect the same characters in text field
                            textComponent.setSelectionStart(selectionStartBeforeFocusLost);
                            textComponent.setSelectionEnd(selectionEndBeforeFocusLost);
                        }
                    });
                } else if (!this.mousePressedInTextField && ev.getOppositeComponent() != null && SwingUtilities.getWindowAncestor(ev.getOppositeComponent()) == SwingUtilities.getWindowAncestor(textComponent)) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            // Select all characters when text field got the focus because of a transfer
                            textComponent.selectAll();
                        }
                    });
                }
                this.mousePressedInTextField = false;
            }
        }
        ;
        SelectionOnFocusManager selectionOnFocusManager = new SelectionOnFocusManager();
        textComponent.addFocusListener(selectionOnFocusManager);
        textComponent.addMouseListener(selectionOnFocusManager);
    }

    /**
     * Forces radio buttons to be deselected even if they belong to a button group.
     */
    public static void deselectAllRadioButtons(JRadioButton... radioButtons) {
        for (JRadioButton radioButton : radioButtons) {
            ButtonGroup group = ((JToggleButton.ToggleButtonModel) radioButton.getModel()).getGroup();
            group.remove(radioButton);
            radioButton.setSelected(false);
            group.add(radioButton);
        }
    }

    /**
     * Displays <code>messageComponent</code> in a modal dialog box, giving focus to one of its components.
     */
    public static int showConfirmDialog(JComponent parentComponent, JComponent messageComponent, String title, final JComponent focusedComponent) {
        JOptionPane optionPane = new JOptionPane(messageComponent, JOptionPane.PLAIN_MESSAGE, JOptionPane.OK_CANCEL_OPTION);
        parentComponent = SwingUtilities.getRootPane(parentComponent);
        if (parentComponent != null) {
            optionPane.setComponentOrientation(parentComponent.getComponentOrientation());
        }
        final JDialog dialog = optionPane.createDialog(parentComponent, title);
        if (focusedComponent != null) {
            // Add a listener that transfer focus to focusedComponent when dialog is shown
            dialog.addComponentListener(new ComponentAdapter() {

                @Override
                public void componentShown(ComponentEvent ev) {
                    focusedComponent.requestFocusInWindow();
                    dialog.removeComponentListener(this);
                }
            });
        }
        dialog.setVisible(true);
        dialog.dispose();
        Object value = optionPane.getValue();
        if (value instanceof Integer) {
            return (Integer) value;
        } else {
            return JOptionPane.CLOSED_OPTION;
        }
    }

    /**
     * Displays <code>messageComponent</code> in a modal dialog box, giving focus to one of its components.
     */
    public static void showMessageDialog(JComponent parentComponent, JComponent messageComponent, String title, int messageType, final JComponent focusedComponent) {
        JOptionPane optionPane = new JOptionPane(messageComponent, messageType, JOptionPane.DEFAULT_OPTION);
        parentComponent = SwingUtilities.getRootPane(parentComponent);
        if (parentComponent != null) {
            optionPane.setComponentOrientation(parentComponent.getComponentOrientation());
        }
        final JDialog dialog = optionPane.createDialog(parentComponent, title);
        if (focusedComponent != null) {
            // Add a listener that transfer focus to focusedComponent when dialog is shown
            dialog.addComponentListener(new ComponentAdapter() {

                @Override
                public void componentShown(ComponentEvent ev) {
                    focusedComponent.requestFocusInWindow();
                    dialog.removeComponentListener(this);
                }
            });
        }
        dialog.setVisible(true);
        dialog.dispose();
    }

    private static Map<TextureImage, BufferedImage> patternImages;

    /**
     * Returns the image matching a given pattern.
     */
    public static BufferedImage getPatternImage(TextureImage pattern, Color backgroundColor, Color foregroundColor) {
        if (patternImages == null) {
            patternImages = new HashMap<TextureImage, BufferedImage>();
        }
        BufferedImage image = new BufferedImage((int) pattern.getWidth(), (int) pattern.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D imageGraphics = (Graphics2D) image.getGraphics();
        imageGraphics.setColor(backgroundColor);
        imageGraphics.fillRect(0, 0, image.getWidth(), image.getHeight());
        // Get pattern image from cache
        BufferedImage patternImage = patternImages.get(pattern);
        if (patternImage == null) {
            try {
                InputStream imageInput = pattern.getImage().openStream();
                patternImage = ImageIO.read(imageInput);
                imageInput.close();
                patternImages.put(pattern, patternImage);
            } catch (IOException ex) {
                throw new IllegalArgumentException(""Can't read pattern image "" + pattern.getName());
            }
        }
        // Draw the pattern image with foreground color
        final int foregroundColorRgb = foregroundColor.getRGB() & 0xFFFFFF;
        imageGraphics.drawImage(Toolkit.getDefaultToolkit().createImage(new FilteredImageSource(patternImage.getSource(), new RGBImageFilter() {

            {
                this.canFilterIndexColorModel = true;
            }

            @Override
            public int filterRGB(int x, int y, int rgba) {
                // Always use foreground color and alpha
                return (rgba & 0xFF000000) | foregroundColorRgb;
            }
        })), 0, 0, null);
        imageGraphics.dispose();
        return image;
    }

    /**
     * Returns the border of a component where a user may drop objects.
     */
    public static Border getDropableComponentBorder() {
        Border border = null;
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            border = UIManager.getBorder(""InsetBorder.aquaVariant"");
        }
        if (border == null) {
            border = BorderFactory.createLoweredBevelBorder();
        }
        return border;
    }

    /**
     * Displays the image referenced by <code>imageUrl</code> in an AWT window
     * disposed once an other AWT frame is created.
     * If the <code>imageUrl</code> is incorrect, nothing happens.
     */
    public static void showSplashScreenWindow(URL imageUrl) {
        try {
            final BufferedImage image = ImageIO.read(imageUrl);
            final Window splashScreenWindow = new Window(new Frame()) {

                @Override
                public void paint(Graphics g) {
                    g.drawImage(image, 0, 0, this);
                }
            };
            splashScreenWindow.setSize(image.getWidth(), image.getHeight());
            splashScreenWindow.setLocationRelativeTo(null);
            splashScreenWindow.setVisible(true);
            Executors.newSingleThreadExecutor().execute(new Runnable() {

                public void run() {
                    try {
                        Thread.sleep(500);
                        while (splashScreenWindow.isVisible()) {
                            // If an other frame is showing, dispose splash window
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (Frame frame : Frame.getFrames()) {
                                        if (frame.isShowing()) {
                                            splashScreenWindow.dispose();
                                        }
                                    }
                                }
                            });
                            Thread.sleep(300);
                        }
                    } catch (InterruptedException ex) {
                        EventQueue.invokeLater(new Runnable() {

                            public void run() {
                                splashScreenWindow.dispose();
                            }
                        });
                    }
                    ;
                }
            });
        } catch (IOException ex) {
            // Ignore splash screen
        }
    }

    /**
     * Returns a new panel with a border and the given <code>title</code>
     */
    public static JPanel createTitledPanel(String title) {
        JPanel titledPanel = new JPanel(new GridBagLayout());
        Border panelBorder = BorderFactory.createTitledBorder(title);
        // For systems different from Mac OS X 10.5, add an empty border
        if (!OperatingSystem.isMacOSXLeopardOrSuperior()) {
            panelBorder = BorderFactory.createCompoundBorder(panelBorder, BorderFactory.createEmptyBorder(0, 2, 2, 2));
        }
        titledPanel.setBorder(panelBorder);
        return titledPanel;
    }

    /**
     * Returns a scroll pane containing the given <code>component</code>
     * that always displays scroll bars under Mac OS X.
     */
    public static JScrollPane createScrollPane(JComponent component) {
        JScrollPane scrollPane = new JScrollPane(component);
        if (OperatingSystem.isMacOSX()) {
            scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
            scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        }
        installFocusBorder(component);
        scrollPane.setMinimumSize(new Dimension());
        return scrollPane;
    }

    /**
     * Adds a listener that will update the given popup menu to hide disabled menu items.
     */
    public static void hideDisabledMenuItems(JPopupMenu popupMenu) {
        popupMenu.addPopupMenuListener(new MenuItemsVisibilityListener());
    }

    /**
     * A popup menu listener that displays only enabled menu items.
     */
    private static class MenuItemsVisibilityListener implements PopupMenuListener {

        public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
            JPopupMenu popupMenu = (JPopupMenu) ev.getSource();
            hideDisabledMenuItems(popupMenu);
            // Ensure at least one item is visible
            boolean allItemsInvisible = true;
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                if (popupMenu.getComponent(i).isVisible()) {
                    allItemsInvisible = false;
                    break;
                }
            }
            if (allItemsInvisible) {
                popupMenu.getComponent(0).setVisible(true);
            }
        }

        /**
         * Makes useless menu items invisible.
         */
        private void hideDisabledMenuItems(JPopupMenu popupMenu) {
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                Component component = popupMenu.getComponent(i);
                if (component instanceof JMenu) {
                    boolean containsEnabledItems = containsEnabledItems((JMenu) component);
                    component.setVisible(containsEnabledItems);
                    if (containsEnabledItems) {
                        hideDisabledMenuItems(((JMenu) component).getPopupMenu());
                    }
                } else if (component instanceof JMenuItem) {
                    component.setVisible(component.isEnabled());
                }
            }
            hideUselessSeparators(popupMenu);
        }

        /**
         * Makes useless separators invisible.
         */
        private void hideUselessSeparators(JPopupMenu popupMenu) {
            boolean allMenuItemsInvisible = true;
            int lastVisibleSeparatorIndex = -1;
            for (int i = 0; i < popupMenu.getComponentCount(); i++) {
                Component component = popupMenu.getComponent(i);
                if (allMenuItemsInvisible && (component instanceof JMenuItem)) {
                    if (component.isVisible()) {
                        allMenuItemsInvisible = false;
                    }
                } else if (component instanceof JSeparator) {
                    component.setVisible(!allMenuItemsInvisible);
                    if (!allMenuItemsInvisible) {
                        lastVisibleSeparatorIndex = i;
                    }
                    allMenuItemsInvisible = true;
                }
            }
            if (lastVisibleSeparatorIndex != -1 && allMenuItemsInvisible) {
                // Check if last separator is the first visible component
                boolean allComponentsBeforeLastVisibleSeparatorInvisible = true;
                for (int i = lastVisibleSeparatorIndex - 1; i >= 0; i--) {
                    if (popupMenu.getComponent(i).isVisible()) {
                        allComponentsBeforeLastVisibleSeparatorInvisible = false;
                        break;
                    }
                }
                boolean allComponentsAfterLastVisibleSeparatorInvisible = true;
                for (int i = lastVisibleSeparatorIndex; i < popupMenu.getComponentCount(); i++) {
                    if (popupMenu.getComponent(i).isVisible()) {
                        allComponentsBeforeLastVisibleSeparatorInvisible = false;
                        break;
                    }
                }
                popupMenu.getComponent(lastVisibleSeparatorIndex).setVisible(!allComponentsBeforeLastVisibleSeparatorInvisible && !allComponentsAfterLastVisibleSeparatorInvisible);
            }
        }

        /**
         * Returns <code>true</code> if the given <code>menu</code> contains
         * at least one enabled menu item.
         */
        private boolean containsEnabledItems(JMenu menu) {
            boolean menuContainsEnabledItems = false;
            for (int i = 0; i < menu.getMenuComponentCount() && !menuContainsEnabledItems; i++) {
                Component component = menu.getMenuComponent(i);
                if (component instanceof JMenu) {
                    menuContainsEnabledItems = containsEnabledItems((JMenu) component);
                } else if (component instanceof JMenuItem) {
                    menuContainsEnabledItems = component.isEnabled();
                }
            }
            return menuContainsEnabledItems;
        }

        public void popupMenuCanceled(PopupMenuEvent ev) {
        }

        public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
        }
    }

    /**
     * Attempts to display the given <code>url</code> in a browser and returns <code>true</code>
     * if it was done successfully.
     */
    public static boolean showDocumentInBrowser(URL url) {
        return BrowserSupport.showDocumentInBrowser(url);
    }

    /**
     * Separated static class to be able to exclude JNLP library from classpath.
     */
    private static class BrowserSupport {

        public static boolean showDocumentInBrowser(URL url) {
            try {
                // Lookup the javax.jnlp.BasicService object
                BasicService basicService = (BasicService) ServiceManager.lookup(""javax.jnlp.BasicService"");
                // Ignore the basic service, if it doesn't support web browser
                if (basicService.isWebBrowserSupported()) {
                    return basicService.showDocument(url);
                }
            } catch (UnavailableServiceException ex) {
                // Too bad : service is unavailable
            } catch (LinkageError ex) {
                // JNLP classes not available in classpath
                System.err.println(""Can't show document in browser. JNLP classes not available in classpath."");
            }
            return false;
        }
    }

    /**
     * Returns the children of a component of the given class.
     */
    public static <T extends JComponent> List<T> findChildren(JComponent parent, Class<T> childrenClass) {
        List<T> children = new ArrayList<T>();
        findChildren(parent, childrenClass, children);
        return children;
    }

    private static <T extends JComponent> void findChildren(JComponent parent, Class<T> childrenClass, List<T> children) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childrenClass.isInstance(child)) {
                children.add((T) child);
            } else if (child instanceof JComponent) {
                findChildren((JComponent) child, childrenClass, children);
            }
        }
    }

    /**
     * Returns <code>true</code> if the given rectangle is fully visible at screen.
     */
    public static boolean isRectangleVisibleAtScreen(Rectangle rectangle) {
        Area devicesArea = new Area();
        GraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        for (GraphicsDevice device : environment.getScreenDevices()) {
            devicesArea.add(new Area(device.getDefaultConfiguration().getBounds()));
        }
        return devicesArea.contains(rectangle);
    }
}
","// SwingTools_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.RGBImageFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;
import javax.jnlp.UnavailableServiceException;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.AbstractBorder;
import javax.swing.border.Border;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SwingTools}.
* It contains one unit test case for the {@link SwingTools#getDropableComponentBorder()} method.
*/
class SwingTools_3Test {","// SwingTools_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Area;
import java.awt.image.BufferedImage;
import java.awt.image.FilteredImageSource;
import java.awt.image.RGBImageFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.jnlp.BasicService;
import javax.jnlp.ServiceManager;
import javax.jnlp.UnavailableServiceException;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.border.AbstractBorder;
import javax.swing.border.Border;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SwingTools}.
* It contains one unit test case for the {@link SwingTools#getDropableComponentBorder()} method.
*/
class SwingTools_3Test {
"
8d6635e3-28ea-4ceb-a270-e45c91f76356,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showOpenDialog()} method.
*/
class HomePane_0Test {","// HomePane_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showOpenDialog()} method.
*/
class HomePane_0Test {
"
8fc237d4-b5e4-41e4-9e45-bcff11b589fb,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showImportLanguageLibraryDialog()} method.
*/
class HomePane_1Test {","// HomePane_1Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showImportLanguageLibraryDialog()} method.
*/
class HomePane_1Test {
"
d0f5b2f5-5498-48fc-b287-dec8d959806a,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showImportFurnitureLibraryDialog()} method.
*/
class HomePane_3Test {","// HomePane_3Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showImportFurnitureLibraryDialog()} method.
*/
class HomePane_3Test {
"
66a1ef2d-3a9f-4989-b844-729b2b5c461e,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showImportTexturesLibraryDialog()} method.
*/
class HomePane_5Test {","// HomePane_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showImportTexturesLibraryDialog()} method.
*/
class HomePane_5Test {
"
199dae93-8dfb-4f63-91d3-63cab36d91df,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_12Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_12Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#confirmExit()} method.
*/
class HomePane_12Test {","// HomePane_12Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#confirmExit()} method.
*/
class HomePane_12Test {
"
45564dfb-c5ee-498c-b6ae-605afbe4921b,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_13Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_13Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showPrintDialog()} method.
*/
class HomePane_13Test {","// HomePane_13Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#showPrintDialog()} method.
*/
class HomePane_13Test {
"
5fa087b8-97c1-4c77-888f-cb9729702660,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/HomePane_17Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// HomePane.java
/*
 * HomePane.java 15 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;

/**
 * The MVC view that edits a home.
 * @author Emmanuel Puybaret
 */
public class HomePane extends JRootPane implements HomeView {

    private enum MenuActionType {

        FILE_MENU,
        EDIT_MENU,
        FURNITURE_MENU,
        PLAN_MENU,
        VIEW_3D_MENU,
        HELP_MENU,
        OPEN_RECENT_HOME_MENU,
        ALIGN_OR_DISTRIBUTE_MENU,
        SORT_HOME_FURNITURE_MENU,
        DISPLAY_HOME_FURNITURE_PROPERTY_MENU,
        MODIFY_TEXT_STYLE,
        GO_TO_POINT_OF_VIEW,
        SELECT_OBJECT_MENU
    }

    private static final String MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.MainPaneDividerLocation"";

    private static final String CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.CatalogPaneDividerLocation"";

    private static final String PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanPaneDividerLocation"";

    private static final String PLAN_VIEWPORT_X_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportX"";

    private static final String PLAN_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.PlanViewportY"";

    private static final String FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY = ""com.eteks.sweethome3d.SweetHome3D.FurnitureViewportY"";

    private static final String DETACHED_VIEW_VISUAL_PROPERTY = "".detachedView"";

    private static final String DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY = "".detachedViewDividerLocation"";

    private static final String DETACHED_VIEW_X_VISUAL_PROPERTY = "".detachedViewX"";

    private static final String DETACHED_VIEW_Y_VISUAL_PROPERTY = "".detachedViewY"";

    private static final String DETACHED_VIEW_WIDTH_VISUAL_PROPERTY = "".detachedViewWidth"";

    private static final String DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY = "".detachedViewHeight"";

    private static final int DEFAULT_SMALL_ICON_HEIGHT = 16;

    private final Home home;

    private final UserPreferences preferences;

    private final HomeController controller;

    private JComponent lastFocusedComponent;

    private PlanController.Mode previousPlanControllerMode;

    private TransferHandler catalogTransferHandler;

    private TransferHandler furnitureTransferHandler;

    private TransferHandler planTransferHandler;

    private boolean transferHandlerEnabled;

    private MouseInputAdapter furnitureCatalogDragAndDropListener;

    private boolean clipboardEmpty = true;

    private ActionMap menuActionMap;

    private List<Action> pluginActions;

    /**
     * Creates home view associated with its controller.
     */
    public HomePane(Home home, UserPreferences preferences, final HomeController controller) {
        this.home = home;
        this.preferences = preferences;
        this.controller = controller;
        JPopupMenu.setDefaultLightWeightPopupEnabled(false);
        ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
        createActions(home, preferences, controller);
        createMenuActions(preferences, controller);
        createPluginActions(controller instanceof HomePluginController ? ((HomePluginController) controller).getPlugins() : null);
        createTransferHandlers(home, controller);
        addHomeListener(home);
        addLevelVisibilityListener(home);
        addLanguageListener(preferences);
        addPlanControllerListener(controller.getPlanController());
        addFocusListener();
        updateFocusTraversalPolicy();
        JMenuBar homeMenuBar = createMenuBar(home, preferences, controller);
        setJMenuBar(homeMenuBar);
        Container contentPane = getContentPane();
        contentPane.add(createToolBar(home), BorderLayout.NORTH);
        contentPane.add(createMainPane(home, preferences, controller));
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            // Under Mac OS X 10.5, add some dummy labels at left and right borders
            // to avoid the tool bar to be attached on these borders
            // (segmented buttons created on this system aren't properly rendered
            // when they are aligned vertically)
            contentPane.add(new JLabel(), BorderLayout.WEST);
            contentPane.add(new JLabel(), BorderLayout.EAST);
        }
        disableMenuItemsDuringDragAndDrop(controller.getPlanController().getView(), homeMenuBar);
        // Change component orientation
        applyComponentOrientation(ComponentOrientation.getOrientation(Locale.getDefault()));
    }

    /**
     * Create the actions map of this component.
     */
    private void createActions(Home home, UserPreferences preferences, final HomeController controller) {
        createAction(ActionType.NEW_HOME, preferences, controller, ""newHome"");
        createAction(ActionType.OPEN, preferences, controller, ""open"");
        createAction(ActionType.DELETE_RECENT_HOMES, preferences, controller, ""deleteRecentHomes"");
        createAction(ActionType.CLOSE, preferences, controller, ""close"");
        createAction(ActionType.SAVE, preferences, controller, ""save"");
        createAction(ActionType.SAVE_AS, preferences, controller, ""saveAs"");
        createAction(ActionType.SAVE_AND_COMPRESS, preferences, controller, ""saveAndCompress"");
        createAction(ActionType.PAGE_SETUP, preferences, controller, ""setupPage"");
        createAction(ActionType.PRINT_PREVIEW, preferences, controller, ""previewPrint"");
        createAction(ActionType.PRINT, preferences, controller, ""print"");
        createAction(ActionType.PRINT_TO_PDF, preferences, controller, ""printToPDF"");
        createAction(ActionType.PREFERENCES, preferences, controller, ""editPreferences"");
        createAction(ActionType.EXIT, preferences, controller, ""exit"");
        createAction(ActionType.UNDO, preferences, controller, ""undo"");
        createAction(ActionType.REDO, preferences, controller, ""redo"");
        createClipboardAction(ActionType.CUT, preferences, TransferHandler.getCutAction(), true);
        createClipboardAction(ActionType.COPY, preferences, TransferHandler.getCopyAction(), true);
        createClipboardAction(ActionType.PASTE, preferences, TransferHandler.getPasteAction(), false);
        createAction(ActionType.DELETE, preferences, controller, ""delete"");
        createAction(ActionType.SELECT_ALL, preferences, controller, ""selectAll"");
        createAction(ActionType.ADD_HOME_FURNITURE, preferences, controller, ""addHomeFurniture"");
        FurnitureController furnitureController = controller.getFurnitureController();
        createAction(ActionType.DELETE_HOME_FURNITURE, preferences, furnitureController, ""deleteSelection"");
        createAction(ActionType.MODIFY_FURNITURE, preferences, controller, ""modifySelectedFurniture"");
        createAction(ActionType.GROUP_FURNITURE, preferences, furnitureController, ""groupSelectedFurniture"");
        createAction(ActionType.UNGROUP_FURNITURE, preferences, furnitureController, ""ungroupSelectedFurniture"");
        createAction(ActionType.ALIGN_FURNITURE_ON_TOP, preferences, furnitureController, ""alignSelectedFurnitureOnTop"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BOTTOM, preferences, furnitureController, ""alignSelectedFurnitureOnBottom"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT, preferences, furnitureController, ""alignSelectedFurnitureOnLeft"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT, preferences, furnitureController, ""alignSelectedFurnitureOnRight"");
        createAction(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnFrontSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnBackSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnLeftSide"");
        createAction(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, preferences, furnitureController, ""alignSelectedFurnitureOnRightSide"");
        createAction(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, preferences, furnitureController, ""alignSelectedFurnitureSideBySide"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, preferences, furnitureController, ""distributeSelectedFurnitureHorizontally"");
        createAction(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, preferences, furnitureController, ""distributeSelectedFurnitureVertically"");
        final HomeController3D homeController3D = controller.getHomeController3D();
        if (homeController3D.getView() != null) {
            createAction(ActionType.IMPORT_FURNITURE, preferences, controller, ""importFurniture"");
        }
        createAction(ActionType.IMPORT_FURNITURE_LIBRARY, preferences, controller, ""importFurnitureLibrary"");
        createAction(ActionType.IMPORT_TEXTURES_LIBRARY, preferences, controller, ""importTexturesLibrary"");
        createAction(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_NAME, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_X, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_Y, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_COLOR, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_TYPE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureSort"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        createAction(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER, preferences, furnitureController, ""toggleFurnitureSortOrder"");
        createAction(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_NAME, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.NAME);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.WIDTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DEPTH);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.HEIGHT);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_X, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.X);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_Y, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.Y);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ELEVATION);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.ANGLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.LEVEL);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_COLOR, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.COLOR);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.TEXTURE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.MOVABLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VISIBLE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
        createAction(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, preferences, furnitureController, ""toggleFurnitureVisibleProperty"", HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        PlanController planController = controller.getPlanController();
        if (planController.getView() != null) {
            ButtonGroup modeGroup = new ButtonGroup();
            createToggleAction(ActionType.SELECT, planController.getMode() == PlanController.Mode.SELECTION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.SELECTION);
            createToggleAction(ActionType.PAN, planController.getMode() == PlanController.Mode.PANNING, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.PANNING);
            createToggleAction(ActionType.CREATE_WALLS, planController.getMode() == PlanController.Mode.WALL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.WALL_CREATION);
            createToggleAction(ActionType.CREATE_ROOMS, planController.getMode() == PlanController.Mode.ROOM_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.ROOM_CREATION);
            createToggleAction(ActionType.CREATE_DIMENSION_LINES, planController.getMode() == PlanController.Mode.DIMENSION_LINE_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.DIMENSION_LINE_CREATION);
            createToggleAction(ActionType.CREATE_LABELS, planController.getMode() == PlanController.Mode.LABEL_CREATION, modeGroup, preferences, controller, ""setMode"", PlanController.Mode.LABEL_CREATION);
            createAction(ActionType.DELETE_SELECTION, preferences, planController, ""deleteSelection"");
            createAction(ActionType.LOCK_BASE_PLAN, preferences, planController, ""lockBasePlan"");
            createAction(ActionType.UNLOCK_BASE_PLAN, preferences, planController, ""unlockBasePlan"");
            createAction(ActionType.MODIFY_COMPASS, preferences, planController, ""modifyCompass"");
            createAction(ActionType.MODIFY_WALL, preferences, planController, ""modifySelectedWalls"");
            createAction(ActionType.MODIFY_ROOM, preferences, planController, ""modifySelectedRooms"");
            createAction(ActionType.MODIFY_LABEL, preferences, planController, ""modifySelectedLabels"");
            createAction(ActionType.INCREASE_TEXT_SIZE, preferences, planController, ""increaseTextSize"");
            createAction(ActionType.DECREASE_TEXT_SIZE, preferences, planController, ""decreaseTextSize"");
            // Use special toggle models for bold and italic check box menu items and tool bar buttons
            // that are selected texts in home selected items are all bold or italic
            Action toggleBoldAction = createAction(ActionType.TOGGLE_BOLD_STYLE, preferences, planController, ""toggleBoldStyle"");
            toggleBoldAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createBoldStyleToggleModel(home, preferences));
            Action toggleItalicAction = createAction(ActionType.TOGGLE_ITALIC_STYLE, preferences, planController, ""toggleItalicStyle"");
            toggleItalicAction.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, createItalicStyleToggleModel(home, preferences));
            createAction(ActionType.REVERSE_WALL_DIRECTION, preferences, planController, ""reverseSelectedWallsDirection"");
            createAction(ActionType.SPLIT_WALL, preferences, planController, ""splitSelectedWall"");
            createAction(ActionType.IMPORT_BACKGROUND_IMAGE, preferences, controller, ""importBackgroundImage"");
            createAction(ActionType.MODIFY_BACKGROUND_IMAGE, preferences, controller, ""modifyBackgroundImage"");
            createAction(ActionType.HIDE_BACKGROUND_IMAGE, preferences, controller, ""hideBackgroundImage"");
            createAction(ActionType.SHOW_BACKGROUND_IMAGE, preferences, controller, ""showBackgroundImage"");
            createAction(ActionType.DELETE_BACKGROUND_IMAGE, preferences, controller, ""deleteBackgroundImage"");
            createAction(ActionType.ADD_LEVEL, preferences, planController, ""addLevel"");
            createAction(ActionType.MODIFY_LEVEL, preferences, planController, ""modifySelectedLevel"");
            createAction(ActionType.DELETE_LEVEL, preferences, planController, ""deleteSelectedLevel"");
            createAction(ActionType.ZOOM_IN, preferences, controller, ""zoomIn"");
            createAction(ActionType.ZOOM_OUT, preferences, controller, ""zoomOut"");
            createAction(ActionType.EXPORT_TO_SVG, preferences, controller, ""exportToSVG"");
        }
        if (homeController3D.getView() != null) {
            ButtonGroup viewGroup = new ButtonGroup();
            createToggleAction(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera(), viewGroup, preferences, homeController3D, ""viewFromTop"");
            createToggleAction(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera(), viewGroup, preferences, homeController3D, ""viewFromObserver"");
            createAction(ActionType.MODIFY_OBSERVER, preferences, planController, ""modifyObserverCamera"");
            createAction(ActionType.STORE_POINT_OF_VIEW, preferences, controller, ""storeCamera"");
            getActionMap().put(ActionType.DETACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.DETACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.detachView(homeController3D.getView());
                }
            });
            getActionMap().put(ActionType.ATTACH_3D_VIEW, new ResourceAction(preferences, HomePane.class, ActionType.ATTACH_3D_VIEW.name()) {

                @Override
                public void actionPerformed(ActionEvent ev) {
                    controller.attachView(homeController3D.getView());
                }
            });
            ButtonGroup displayLevelGroup = new ButtonGroup();
            boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
            createToggleAction(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displayAllLevels"");
            createToggleAction(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible, displayLevelGroup, preferences, homeController3D, ""displaySelectedLevel"");
            createAction(ActionType.MODIFY_3D_ATTRIBUTES, preferences, homeController3D, ""modifyAttributes"");
            createAction(ActionType.CREATE_PHOTO, preferences, controller, ""createPhoto"");
            createAction(ActionType.CREATE_VIDEO, preferences, controller, ""createVideo"");
            createAction(ActionType.EXPORT_TO_OBJ, preferences, controller, ""exportToOBJ"");
        }
        createAction(ActionType.HELP, preferences, controller, ""help"");
        createAction(ActionType.ABOUT, preferences, controller, ""about"");
    }

    /**
     * Returns a new <code>ControllerAction</code> object that calls on <code>controller</code> a given
     * <code>method</code> with its <code>parameters</code>. This action is added to the action map of this component.
     */
    private Action createAction(ActionType actionType, UserPreferences preferences, Object controller, String method, Object... parameters) {
        try {
            ControllerAction action = new ControllerAction(preferences, HomePane.class, actionType.name(), controller, method, parameters);
            getActionMap().put(actionType, action);
            return action;
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * Returns a new <code>ControllerAction</code> object associated with a <code>ToggleButtonModel</code> instance
     * set as selected or not.
     */
    private Action createToggleAction(ActionType actionType, boolean selected, ButtonGroup group, UserPreferences preferences, Object controller, String method, Object... parameters) {
        Action action = createAction(actionType, preferences, controller, method, parameters);
        JToggleButton.ToggleButtonModel toggleButtonModel = new JToggleButton.ToggleButtonModel();
        toggleButtonModel.setSelected(selected);
        if (group != null) {
            toggleButtonModel.setGroup(group);
        }
        action.putValue(ResourceAction.TOGGLE_BUTTON_MODEL, toggleButtonModel);
        return action;
    }

    /**
     * Creates a <code>ReourceAction</code> object that calls
     * <code>actionPerfomed</code> method on a given
     * existing <code>clipboardAction</code> with a source equal to focused component.
     */
    private void createClipboardAction(ActionType actionType, UserPreferences preferences, final Action clipboardAction, final boolean copyAction) {
        getActionMap().put(actionType, new ResourceAction(preferences, HomePane.class, actionType.name()) {

            public void actionPerformed(ActionEvent ev) {
                if (copyAction) {
                    clipboardEmpty = false;
                }
                ev = new ActionEvent(lastFocusedComponent, ActionEvent.ACTION_PERFORMED, null);
                clipboardAction.actionPerformed(ev);
            }
        });
    }

    /**
     * Create the actions map used to create menus of this component.
     */
    private void createMenuActions(UserPreferences preferences, HomeController controller) {
        this.menuActionMap = new ActionMap();
        createMenuAction(preferences, MenuActionType.FILE_MENU);
        createMenuAction(preferences, MenuActionType.EDIT_MENU);
        createMenuAction(preferences, MenuActionType.FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.PLAN_MENU);
        createMenuAction(preferences, MenuActionType.VIEW_3D_MENU);
        createMenuAction(preferences, MenuActionType.HELP_MENU);
        createMenuAction(preferences, MenuActionType.OPEN_RECENT_HOME_MENU);
        createMenuAction(preferences, MenuActionType.SORT_HOME_FURNITURE_MENU);
        createMenuAction(preferences, MenuActionType.ALIGN_OR_DISTRIBUTE_MENU);
        createMenuAction(preferences, MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU);
        createMenuAction(preferences, MenuActionType.MODIFY_TEXT_STYLE);
        createMenuAction(preferences, MenuActionType.GO_TO_POINT_OF_VIEW);
        createMenuAction(preferences, MenuActionType.SELECT_OBJECT_MENU);
    }

    /**
     * Creates a <code>ResourceAction</code> object stored in menu action map.
     */
    private void createMenuAction(UserPreferences preferences, MenuActionType action) {
        this.menuActionMap.put(action, new ResourceAction(preferences, HomePane.class, action.name(), true));
    }

    /**
     * Creates the Swing actions matching each actions available in <code>plugins</code>.
     */
    private void createPluginActions(List<Plugin> plugins) {
        this.pluginActions = new ArrayList<Action>();
        if (plugins != null) {
            for (Plugin plugin : plugins) {
                for (final PluginAction pluginAction : plugin.getActions()) {
                    // Create a Swing action adapter to plug-in action
                    this.pluginActions.add(new ActionAdapter(pluginAction));
                }
            }
        }
    }

    /**
     * Creates components transfer handlers.
     */
    private void createTransferHandlers(Home home, HomeController controller) {
        this.catalogTransferHandler = new FurnitureCatalogTransferHandler(controller.getContentManager(), controller.getFurnitureCatalogController(), controller.getFurnitureController());
        this.furnitureTransferHandler = new FurnitureTransferHandler(home, controller.getContentManager(), controller);
        this.planTransferHandler = new PlanTransferHandler(home, controller.getContentManager(), controller);
    }

    /**
     * Adds a property change listener to <code>home</code> to update
     * View from top and View from observer toggle models according to used camera.
     */
    private void addHomeListener(final Home home) {
        home.addPropertyChangeListener(Home.Property.CAMERA, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                setToggleButtonModelSelected(ActionType.VIEW_FROM_TOP, home.getCamera() == home.getTopCamera());
                setToggleButtonModelSelected(ActionType.VIEW_FROM_OBSERVER, home.getCamera() == home.getObserverCamera());
            }
        });
    }

    /**
     * Changes the selection of the toggle model matching the given action.
     */
    private void setToggleButtonModelSelected(ActionType actionType, boolean selected) {
        ((JToggleButton.ToggleButtonModel) getActionMap().get(actionType).getValue(ResourceAction.TOGGLE_BUTTON_MODEL)).setSelected(selected);
    }

    /**
     * Adds listener to <code>home</code> to update
     * Display all levels and Display selected level toggle models
     * according their visibility.
     */
    private void addLevelVisibilityListener(final Home home) {
        home.getEnvironment().addPropertyChangeListener(HomeEnvironment.Property.ALL_LEVELS_VISIBLE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                boolean allLevelsVisible = home.getEnvironment().isAllLevelsVisible();
                setToggleButtonModelSelected(ActionType.DISPLAY_ALL_LEVELS, allLevelsVisible);
                setToggleButtonModelSelected(ActionType.DISPLAY_SELECTED_LEVEL, !allLevelsVisible);
            }
        });
    }

    /**
     * Adds a property change listener to <code>preferences</code> to update
     * actions when preferred language changes.
     */
    private void addLanguageListener(UserPreferences preferences) {
        preferences.addPropertyChangeListener(UserPreferences.Property.LANGUAGE, new LanguageChangeListener(this));
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class LanguageChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        public LanguageChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.LANGUAGE, this);
            } else {
                SwingTools.updateSwingResourceLanguage((UserPreferences) ev.getSource());
            }
        }
    }

    /**
     * Adds a property change listener to <code>planController</code> to update
     * Select and Create walls toggle models according to current mode.
     */
    private void addPlanControllerListener(final PlanController planController) {
        planController.addPropertyChangeListener(PlanController.Property.MODE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                Mode mode = planController.getMode();
                setToggleButtonModelSelected(ActionType.SELECT, mode == PlanController.Mode.SELECTION);
                setToggleButtonModelSelected(ActionType.PAN, mode == PlanController.Mode.PANNING);
                setToggleButtonModelSelected(ActionType.CREATE_WALLS, mode == PlanController.Mode.WALL_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_ROOMS, mode == PlanController.Mode.ROOM_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_DIMENSION_LINES, mode == PlanController.Mode.DIMENSION_LINE_CREATION);
                setToggleButtonModelSelected(ActionType.CREATE_LABELS, mode == PlanController.Mode.LABEL_CREATION);
            }
        });
    }

    /**
     * Adds a focus change listener to report to controller focus changes.
     */
    private void addFocusListener() {
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""currentFocusCycleRoot"", new FocusCycleRootChangeListener(this));
    }

    /**
     * Property listener bound to this component with a weak reference to avoid
     * strong link between KeyboardFocusManager and this component.
     */
    private static class FocusCycleRootChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private PropertyChangeListener focusChangeListener;

        public FocusCycleRootChangeListener(HomePane homePane) {
            this.homePane = new WeakReference<HomePane>(homePane);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from KeyboardFocusManager
            final HomePane homePane = this.homePane.get();
            if (homePane == null) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(""currentFocusCycleRoot"", this);
            } else {
                if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getOldValue())) {
                    this.focusChangeListener = null;
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                } else if (SwingUtilities.isDescendingFrom(homePane, (Component) ev.getNewValue())) {
                    this.focusChangeListener = new PropertyChangeListener() {

                        public void propertyChange(PropertyChangeEvent ev) {
                            if (homePane.lastFocusedComponent != null) {
                                // Update component which lost focused
                                JComponent lostFocusedComponent = homePane.lastFocusedComponent;
                                if (SwingUtilities.isDescendingFrom(lostFocusedComponent, SwingUtilities.getWindowAncestor(homePane))) {
                                    lostFocusedComponent.removeKeyListener(homePane.specialKeysListener);
                                    // Restore previous plan mode if plan view had focus and window is deactivated
                                    if (homePane.previousPlanControllerMode != null && (lostFocusedComponent == homePane.controller.getPlanController().getView() || ev.getNewValue() == null)) {
                                        homePane.controller.getPlanController().setMode(homePane.previousPlanControllerMode);
                                        homePane.previousPlanControllerMode = null;
                                    }
                                }
                            }
                            if (ev.getNewValue() != null) {
                                // Retrieve component which gained focused
                                Component gainedFocusedComponent = (Component) ev.getNewValue();
                                if (SwingUtilities.isDescendingFrom(gainedFocusedComponent, SwingUtilities.getWindowAncestor(homePane)) && gainedFocusedComponent instanceof JComponent) {
                                    View[] focusableViews = { homePane.controller.getFurnitureCatalogController().getView(), homePane.controller.getFurnitureController().getView(), homePane.controller.getPlanController().getView(), homePane.controller.getHomeController3D().getView() };
                                    // Notify controller that active view changed
                                    for (View view : focusableViews) {
                                        if (view != null && SwingUtilities.isDescendingFrom(gainedFocusedComponent, (JComponent) view)) {
                                            homePane.controller.focusedViewChanged(view);
                                            gainedFocusedComponent.addKeyListener(homePane.specialKeysListener);
                                            // Update the component used by clipboard actions
                                            homePane.lastFocusedComponent = (JComponent) gainedFocusedComponent;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    };
                    KeyboardFocusManager.getCurrentKeyboardFocusManager().addPropertyChangeListener(""focusOwner"", this.focusChangeListener);
                }
            }
        }
    }

    private KeyListener specialKeysListener = new KeyAdapter() {

        public void keyPressed(KeyEvent ev) {
            // Temporarily toggle plan controller mode to panning mode when space bar is pressed
            PlanController planController = controller.getPlanController();
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && (ev.getModifiers() & (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK)) == 0 && getActionMap().get(ActionType.PAN).getValue(Action.NAME) != null && planController.getMode() != PlanController.Mode.PANNING && !planController.isModificationState() && SwingUtilities.isDescendingFrom(lastFocusedComponent, HomePane.this) && !isSpaceUsedByComponent(lastFocusedComponent)) {
                previousPlanControllerMode = planController.getMode();
                planController.setMode(PlanController.Mode.PANNING);
                ev.consume();
            }
        }

        private boolean isSpaceUsedByComponent(JComponent component) {
            return component instanceof JTextComponent || component instanceof JComboBox;
        }

        public void keyReleased(KeyEvent ev) {
            if (ev.getKeyCode() == KeyEvent.VK_SPACE && previousPlanControllerMode != null) {
                controller.getPlanController().setMode(previousPlanControllerMode);
                previousPlanControllerMode = null;
                ev.consume();
            }
        }

        @Override
        public void keyTyped(KeyEvent ev) {
            // This listener manages accelerator keys that may require the use of shift key
            // depending on keyboard layout (like + - or ?)
            ActionMap actionMap = getActionMap();
            Action[] specialKeyActions = { actionMap.get(ActionType.ZOOM_IN), actionMap.get(ActionType.ZOOM_OUT), actionMap.get(ActionType.INCREASE_TEXT_SIZE), actionMap.get(ActionType.DECREASE_TEXT_SIZE), actionMap.get(ActionType.HELP) };
            int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK | KeyEvent.META_MASK;
            for (Action specialKeyAction : specialKeyActions) {
                KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction.getValue(Action.ACCELERATOR_KEY);
                if (ev.getKeyChar() == actionKeyStroke.getKeyChar() && (ev.getModifiers() & modifiersMask) == (actionKeyStroke.getModifiers() & modifiersMask) && specialKeyAction.isEnabled()) {
                    specialKeyAction.actionPerformed(new ActionEvent(HomePane.this, ActionEvent.ACTION_PERFORMED, (String) specialKeyAction.getValue(Action.ACTION_COMMAND_KEY)));
                    ev.consume();
                }
            }
        }
    };

    /**
     * Sets a focus traversal policy that ignores invisible split pane components.
     */
    private void updateFocusTraversalPolicy() {
        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {

            @Override
            protected boolean accept(Component component) {
                if (super.accept(component)) {
                    for (JSplitPane splitPane; (splitPane = (JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, component)) != null; component = splitPane) {
                        if (isChildComponentInvisible(splitPane, component)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        });
        setFocusTraversalPolicyProvider(true);
    }

    /**
     * Returns <code>true</code> if the top or the bottom component of the <code>splitPane</code>
     * is a parent of the given child component and is too small enough to show it.
     */
    private boolean isChildComponentInvisible(JSplitPane splitPane, Component childComponent) {
        return (SwingUtilities.isDescendingFrom(childComponent, splitPane.getTopComponent()) && (splitPane.getTopComponent().getWidth() == 0 || splitPane.getTopComponent().getHeight() == 0)) || (SwingUtilities.isDescendingFrom(childComponent, splitPane.getBottomComponent()) && (splitPane.getBottomComponent().getWidth() == 0 || splitPane.getBottomComponent().getHeight() == 0));
    }

    /**
     * Returns the menu bar displayed in this pane.
     */
    private JMenuBar createMenuBar(final Home home, UserPreferences preferences, final HomeController controller) {
        // Create File menu
        JMenu fileMenu = new JMenu(this.menuActionMap.get(MenuActionType.FILE_MENU));
        addActionToMenu(ActionType.NEW_HOME, fileMenu);
        addActionToMenu(ActionType.OPEN, fileMenu);
        final JMenu openRecentHomeMenu = new JMenu(this.menuActionMap.get(MenuActionType.OPEN_RECENT_HOME_MENU));
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
        openRecentHomeMenu.addMenuListener(new MenuListener() {

            public void menuSelected(MenuEvent ev) {
                updateOpenRecentHomeMenu(openRecentHomeMenu, controller);
            }

            public void menuCanceled(MenuEvent ev) {
            }

            public void menuDeselected(MenuEvent ev) {
            }
        });
        fileMenu.add(openRecentHomeMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.CLOSE, fileMenu);
        addActionToMenu(ActionType.SAVE, fileMenu);
        addActionToMenu(ActionType.SAVE_AS, fileMenu);
        addActionToMenu(ActionType.SAVE_AND_COMPRESS, fileMenu);
        fileMenu.addSeparator();
        addActionToMenu(ActionType.PAGE_SETUP, fileMenu);
        addActionToMenu(ActionType.PRINT_PREVIEW, fileMenu);
        addActionToMenu(ActionType.PRINT, fileMenu);
        // Don't add PRINT_TO_PDF, PREFERENCES and EXIT menu items under Mac OS X,
        // because PREFERENCES and EXIT items are displayed in application menu
        // and PRINT_TO_PDF is available in standard Mac OS X Print dialog
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.PRINT_TO_PDF, fileMenu);
            fileMenu.addSeparator();
            addActionToMenu(ActionType.PREFERENCES, fileMenu);
        }
        // Create Edit menu
        JMenu editMenu = new JMenu(this.menuActionMap.get(MenuActionType.EDIT_MENU));
        addActionToMenu(ActionType.UNDO, editMenu);
        addActionToMenu(ActionType.REDO, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.CUT, editMenu);
        addActionToMenu(ActionType.COPY, editMenu);
        addActionToMenu(ActionType.PASTE, editMenu);
        editMenu.addSeparator();
        addActionToMenu(ActionType.DELETE, editMenu);
        addActionToMenu(ActionType.SELECT_ALL, editMenu);
        // Create Furniture menu
        JMenu furnitureMenu = new JMenu(this.menuActionMap.get(MenuActionType.FURNITURE_MENU));
        addActionToMenu(ActionType.ADD_HOME_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.MODIFY_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.GROUP_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.UNGROUP_FURNITURE, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, furnitureMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, furnitureMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, furnitureMenu);
        furnitureMenu.addSeparator();
        addActionToMenu(ActionType.IMPORT_FURNITURE, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_FURNITURE_LIBRARY, furnitureMenu);
        addActionToMenu(ActionType.IMPORT_TEXTURES_LIBRARY, furnitureMenu);
        furnitureMenu.addSeparator();
        furnitureMenu.add(createFurnitureSortMenu(home, preferences));
        furnitureMenu.add(createFurnitureDisplayPropertyMenu(home, preferences));
        // Create Plan menu
        JMenu planMenu = new JMenu(this.menuActionMap.get(MenuActionType.PLAN_MENU));
        addToggleActionToMenu(ActionType.SELECT, true, planMenu);
        addToggleActionToMenu(ActionType.PAN, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_WALLS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_ROOMS, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_DIMENSION_LINES, true, planMenu);
        addToggleActionToMenu(ActionType.CREATE_LABELS, true, planMenu);
        planMenu.addSeparator();
        JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, false);
        if (lockUnlockBasePlanMenuItem != null) {
            planMenu.add(lockUnlockBasePlanMenuItem);
        }
        addActionToMenu(ActionType.MODIFY_COMPASS, planMenu);
        addActionToMenu(ActionType.MODIFY_WALL, planMenu);
        addActionToMenu(ActionType.REVERSE_WALL_DIRECTION, planMenu);
        addActionToMenu(ActionType.SPLIT_WALL, planMenu);
        addActionToMenu(ActionType.MODIFY_ROOM, planMenu);
        addActionToMenu(ActionType.MODIFY_LABEL, planMenu);
        planMenu.add(createTextStyleMenu(home, preferences, false));
        planMenu.addSeparator();
        JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, false);
        if (importModifyBackgroundImageMenuItem != null) {
            planMenu.add(importModifyBackgroundImageMenuItem);
        }
        JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, false);
        if (hideShowBackgroundImageMenuItem != null) {
            planMenu.add(hideShowBackgroundImageMenuItem);
        }
        addActionToMenu(ActionType.DELETE_BACKGROUND_IMAGE, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ADD_LEVEL, planMenu);
        addActionToMenu(ActionType.MODIFY_LEVEL, planMenu);
        addActionToMenu(ActionType.DELETE_LEVEL, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.ZOOM_IN, planMenu);
        addActionToMenu(ActionType.ZOOM_OUT, planMenu);
        planMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_SVG, planMenu);
        // Create 3D Preview menu
        JMenu preview3DMenu = new JMenu(this.menuActionMap.get(MenuActionType.VIEW_3D_MENU));
        addToggleActionToMenu(ActionType.VIEW_FROM_TOP, true, preview3DMenu);
        addToggleActionToMenu(ActionType.VIEW_FROM_OBSERVER, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_OBSERVER, preview3DMenu);
        addActionToMenu(ActionType.STORE_POINT_OF_VIEW, preview3DMenu);
        JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
        if (goToPointOfViewMenu != null) {
            preview3DMenu.add(goToPointOfViewMenu);
        }
        preview3DMenu.addSeparator();
        JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, false);
        if (attachDetach3DViewMenuItem != null) {
            preview3DMenu.add(attachDetach3DViewMenuItem);
        }
        addToggleActionToMenu(ActionType.DISPLAY_ALL_LEVELS, true, preview3DMenu);
        addToggleActionToMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, preview3DMenu);
        addActionToMenu(ActionType.MODIFY_3D_ATTRIBUTES, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.CREATE_PHOTO, preview3DMenu);
        addActionToMenu(ActionType.CREATE_VIDEO, preview3DMenu);
        preview3DMenu.addSeparator();
        addActionToMenu(ActionType.EXPORT_TO_OBJ, preview3DMenu);
        // Create Help menu
        JMenu helpMenu = new JMenu(this.menuActionMap.get(MenuActionType.HELP_MENU));
        addActionToMenu(ActionType.HELP, helpMenu);
        if (!OperatingSystem.isMacOSX()) {
            addActionToMenu(ActionType.ABOUT, helpMenu);
        }
        // Add menus to menu bar
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(furnitureMenu);
        if (controller.getPlanController().getView() != null) {
            menuBar.add(planMenu);
        }
        if (controller.getHomeController3D().getView() != null) {
            menuBar.add(preview3DMenu);
        }
        menuBar.add(helpMenu);
        // Add plugin actions menu items
        for (Action pluginAction : this.pluginActions) {
            String pluginMenu = (String) pluginAction.getValue(PluginAction.Property.MENU.name());
            if (pluginMenu != null) {
                boolean pluginActionAdded = false;
                for (int i = 0; i < menuBar.getMenuCount(); i++) {
                    JMenu menu = menuBar.getMenu(i);
                    if (menu.getText().equals(pluginMenu)) {
                        // Add menu item to existing menu
                        menu.addSeparator();
                        menu.add(new ResourceAction.MenuItemAction(pluginAction));
                        pluginActionAdded = true;
                        break;
                    }
                }
                if (!pluginActionAdded) {
                    // Create missing menu before last menu
                    JMenu menu = new JMenu(pluginMenu);
                    menu.add(new ResourceAction.MenuItemAction(pluginAction));
                    menuBar.add(menu, menuBar.getMenuCount() - 1);
                }
            }
        }
        // Add EXIT action at end to ensure it's the last item of file menu
        if (!OperatingSystem.isMacOSX()) {
            fileMenu.addSeparator();
            addActionToMenu(ActionType.EXIT, fileMenu);
        }
        removeUselessSeparatorsAndEmptyMenus(menuBar);
        return menuBar;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, JMenu menu) {
        addActionToMenu(actionType, false, menu);
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToMenu(ActionType actionType, boolean popup, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean radioButton, JMenu menu) {
        addToggleActionToMenu(actionType, false, radioButton, menu);
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>.
     */
    private void addToggleActionToMenu(ActionType actionType, boolean popup, boolean radioButton, JMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, popup, radioButton));
        }
    }

    /**
     * Creates a menu item for a toggle action.
     */
    private JMenuItem createToggleMenuItem(Action action, boolean popup, boolean radioButton) {
        JMenuItem menuItem;
        if (radioButton) {
            menuItem = new JRadioButtonMenuItem();
        } else {
            menuItem = new JCheckBoxMenuItem();
        }
        // Configure model
        menuItem.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
        // Configure menu item action after setting its model to avoid losing its mnemonic
        menuItem.setAction(popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action));
        return menuItem;
    }

    /**
     * Adds the given action to <code>menu</code>.
     */
    private void addActionToPopupMenu(ActionType actionType, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(new ResourceAction.PopupMenuItemAction(action));
        }
    }

    /**
     * Adds to <code>menu</code> the menu item matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToPopupMenu(ActionType actionType, boolean radioButton, JPopupMenu menu) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            menu.add(createToggleMenuItem(action, true, radioButton));
        }
    }

    /**
     * Removes the useless separators and empty menus among children of component.
     */
    private void removeUselessSeparatorsAndEmptyMenus(JComponent component) {
        for (int i = component.getComponentCount() - 1; i >= 0; i--) {
            Component child = component.getComponent(i);
            if (child instanceof JSeparator && (i == component.getComponentCount() - 1 || component.getComponent(i - 1) instanceof JSeparator)) {
                component.remove(i);
            } else if (child instanceof JMenu) {
                removeUselessSeparatorsAndEmptyMenus(((JMenu) child).getPopupMenu());
            }
            if (child instanceof JMenu && (((JMenu) child).getMenuComponentCount() == 0 || ((JMenu) child).getMenuComponentCount() == 1 && ((JMenu) child).getMenuComponent(0) instanceof JSeparator)) {
                component.remove(i);
            }
        }
        // Don't let a menu start with a separator
        if (component.getComponentCount() > 0 && component.getComponent(0) instanceof JSeparator) {
            component.remove(0);
        }
    }

    /**
     * Returns align or distribute menu.
     */
    private JMenu createAlignOrDistributeMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu alignOrDistributeMenu = new JMenu(this.menuActionMap.get(MenuActionType.ALIGN_OR_DISTRIBUTE_MENU));
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_TOP, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BOTTOM, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_FRONT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_BACK_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_LEFT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_ON_RIGHT_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.ALIGN_FURNITURE_SIDE_BY_SIDE, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_HORIZONTALLY, popup, alignOrDistributeMenu);
        addActionToMenu(ActionType.DISTRIBUTE_FURNITURE_VERTICALLY, popup, alignOrDistributeMenu);
        return alignOrDistributeMenu;
    }

    /**
     * Returns furniture sort menu.
     */
    private JMenu createFurnitureSortMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Sort submenu
        JMenu sortMenu = new JMenu(this.menuActionMap.get(MenuActionType.SORT_HOME_FURNITURE_MENU));
        // Map sort furniture properties to sort actions
        Map<HomePieceOfFurniture.SortableProperty, Action> sortActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_CATALOG_ID, sortActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_NAME, sortActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_WIDTH, sortActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_DEPTH, sortActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_HEIGHT, sortActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_X, sortActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_Y, sortActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ELEVATION, sortActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_ANGLE, sortActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_LEVEL, sortActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_COLOR, sortActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TEXTURE, sortActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_MOVABILITY, sortActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_TYPE, sortActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VISIBILITY, sortActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE, sortActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX_PERCENTAGE, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_VALUE_ADDED_TAX, sortActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.SORT_HOME_FURNITURE_BY_PRICE_VALUE_ADDED_TAX_INCLUDED, sortActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu and make them share the same radio button group
        ButtonGroup sortButtonGroup = new ButtonGroup();
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : sortActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action sortAction = entry.getValue();
            JRadioButtonMenuItem sortMenuItem = new JRadioButtonMenuItem();
            // Use a special model for sort radio button menu item that is selected if
            // home is sorted on furnitureProperty criterion
            sortMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return furnitureProperty == home.getFurnitureSortedProperty();
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            sortMenuItem.setAction(new ResourceAction.MenuItemAction(sortAction));
            sortMenu.add(sortMenuItem);
            sortButtonGroup.add(sortMenuItem);
        }
        Action sortOrderAction = getActionMap().get(ActionType.SORT_HOME_FURNITURE_BY_DESCENDING_ORDER);
        if (sortOrderAction.getValue(Action.NAME) != null) {
            sortMenu.addSeparator();
            JCheckBoxMenuItem sortOrderCheckBoxMenuItem = new JCheckBoxMenuItem();
            // Use a special model for sort order check box menu item that is selected depending on
            // home sort order property
            sortOrderCheckBoxMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.isFurnitureDescendingSorted();
                }
            });
            sortOrderCheckBoxMenuItem.setAction(new ResourceAction.MenuItemAction(sortOrderAction));
            sortMenu.add(sortOrderCheckBoxMenuItem);
        }
        return sortMenu;
    }

    /**
     * Adds to <code>actions</code> the action matching <code>actionType</code>.
     */
    private void addActionToMap(ActionType actionType, Map<HomePieceOfFurniture.SortableProperty, Action> actions, HomePieceOfFurniture.SortableProperty key) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            actions.put(key, action);
        }
    }

    /**
     * Returns furniture display property menu.
     */
    private JMenu createFurnitureDisplayPropertyMenu(final Home home, UserPreferences preferences) {
        // Create Furniture Display property submenu
        JMenu displayPropertyMenu = new JMenu(this.menuActionMap.get(MenuActionType.DISPLAY_HOME_FURNITURE_PROPERTY_MENU));
        // Map displayProperty furniture properties to displayProperty actions
        Map<HomePieceOfFurniture.SortableProperty, Action> displayPropertyActions = new LinkedHashMap<HomePieceOfFurniture.SortableProperty, Action>();
        // Use catalog id if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_CATALOG_ID, displayPropertyActions, HomePieceOfFurniture.SortableProperty.CATALOG_ID);
        }
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_NAME, displayPropertyActions, HomePieceOfFurniture.SortableProperty.NAME);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_WIDTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.WIDTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DEPTH, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DEPTH);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_HEIGHT, displayPropertyActions, HomePieceOfFurniture.SortableProperty.HEIGHT);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_X, displayPropertyActions, HomePieceOfFurniture.SortableProperty.X);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_Y, displayPropertyActions, HomePieceOfFurniture.SortableProperty.Y);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ELEVATION, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ELEVATION);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_ANGLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.ANGLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_LEVEL, displayPropertyActions, HomePieceOfFurniture.SortableProperty.LEVEL);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_COLOR, displayPropertyActions, HomePieceOfFurniture.SortableProperty.COLOR);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_TEXTURE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.TEXTURE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_MOVABLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.MOVABLE);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_DOOR_OR_WINDOW, displayPropertyActions, HomePieceOfFurniture.SortableProperty.DOOR_OR_WINDOW);
        addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VISIBLE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VISIBLE);
        // Use prices if currency isn't null
        if (preferences.getCurrency() != null) {
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX_PERCENTAGE, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX_PERCENTAGE);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_VALUE_ADDED_TAX, displayPropertyActions, HomePieceOfFurniture.SortableProperty.VALUE_ADDED_TAX);
            addActionToMap(ActionType.DISPLAY_HOME_FURNITURE_PRICE_VALUE_ADDED_TAX_INCLUDED, displayPropertyActions, HomePieceOfFurniture.SortableProperty.PRICE_VALUE_ADDED_TAX_INCLUDED);
        }
        // Add radio button menu items to sub menu
        for (Map.Entry<HomePieceOfFurniture.SortableProperty, Action> entry : displayPropertyActions.entrySet()) {
            final HomePieceOfFurniture.SortableProperty furnitureProperty = entry.getKey();
            Action displayPropertyAction = entry.getValue();
            JCheckBoxMenuItem displayPropertyMenuItem = new JCheckBoxMenuItem();
            // Use a special model for displayProperty check box menu item that is selected if
            // home furniture visible properties contains furnitureProperty
            displayPropertyMenuItem.setModel(new JToggleButton.ToggleButtonModel() {

                @Override
                public boolean isSelected() {
                    return home.getFurnitureVisibleProperties().contains(furnitureProperty);
                }
            });
            // Configure check box menu item action after setting its model to avoid losing its mnemonic
            displayPropertyMenuItem.setAction(displayPropertyAction);
            displayPropertyMenu.add(displayPropertyMenuItem);
        }
        return displayPropertyMenu;
    }

    /**
     * Returns Lock / Unlock base plan menu item.
     */
    private JMenuItem createLockUnlockBasePlanMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JMenuItem lockUnlockBasePlanMenuItem = new JMenuItem(createLockUnlockBasePlanAction(home, popup));
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanMenuItem.setAction(createLockUnlockBasePlanAction(home, popup));
                }
            });
            return lockUnlockBasePlanMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Lock / Unlock base plan menu item.
     */
    private Action createLockUnlockBasePlanAction(Home home, boolean popup) {
        ActionType actionType = home.isBasePlanLocked() ? ActionType.UNLOCK_BASE_PLAN : ActionType.LOCK_BASE_PLAN;
        Action action = getActionMap().get(actionType);
        return popup ? new ResourceAction.PopupMenuItemAction(action) : new ResourceAction.MenuItemAction(action);
    }

    /**
     * Returns Lock / Unlock base plan button.
     */
    private JComponent createLockUnlockBasePlanButton(final Home home) {
        ActionMap actionMap = getActionMap();
        final Action unlockBasePlanAction = actionMap.get(ActionType.UNLOCK_BASE_PLAN);
        final Action lockBasePlanAction = actionMap.get(ActionType.LOCK_BASE_PLAN);
        if (unlockBasePlanAction != null && unlockBasePlanAction.getValue(Action.NAME) != null && lockBasePlanAction.getValue(Action.NAME) != null) {
            final JButton lockUnlockBasePlanButton = new JButton(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
            lockUnlockBasePlanButton.setBorderPainted(false);
            lockUnlockBasePlanButton.setContentAreaFilled(false);
            lockUnlockBasePlanButton.setFocusable(false);
            // Add a listener to home on basePlanLocked property change to
            // switch action according to basePlanLocked change
            home.addPropertyChangeListener(Home.Property.BASE_PLAN_LOCKED, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    lockUnlockBasePlanButton.setAction(new ResourceAction.ToolBarAction(home.isBasePlanLocked() ? unlockBasePlanAction : lockBasePlanAction));
                }
            });
            return lockUnlockBasePlanButton;
        } else {
            return null;
        }
    }

    /**
     * Returns text style menu.
     */
    private JMenu createTextStyleMenu(final Home home, final UserPreferences preferences, boolean popup) {
        JMenu modifyTextStyleMenu = new JMenu(this.menuActionMap.get(MenuActionType.MODIFY_TEXT_STYLE));
        addActionToMenu(ActionType.INCREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        addActionToMenu(ActionType.DECREASE_TEXT_SIZE, popup, modifyTextStyleMenu);
        modifyTextStyleMenu.addSeparator();
        addToggleActionToMenu(ActionType.TOGGLE_BOLD_STYLE, popup, false, modifyTextStyleMenu);
        addToggleActionToMenu(ActionType.TOGGLE_ITALIC_STYLE, popup, false, modifyTextStyleMenu);
        return modifyTextStyleMenu;
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use bold style.
     */
    private JToggleButton.ToggleButtonModel createBoldStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all bold or not
                Boolean selectionBoldStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean bold;
                    if (item instanceof Label) {
                        bold = isItemTextBold(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        bold = isItemTextBold(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        bold = isItemTextBold(room, room.getNameStyle());
                        if (bold != isItemTextBold(room, room.getAreaStyle())) {
                            bold = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        bold = isItemTextBold(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionBoldStyle == null) {
                        selectionBoldStyle = bold;
                    } else if (bold == null || !selectionBoldStyle.equals(bold)) {
                        selectionBoldStyle = null;
                        break;
                    }
                }
                return selectionBoldStyle != null && selectionBoldStyle;
            }

            private boolean isItemTextBold(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isBold();
            }
        };
    }

    /**
     * Creates a toggle button model that is selected when all the text of the
     * selected items in <code>home</code> use italic style.
     */
    private JToggleButton.ToggleButtonModel createItalicStyleToggleModel(final Home home, final UserPreferences preferences) {
        return new JToggleButton.ToggleButtonModel() {

            {
                home.addSelectionListener(new SelectionListener() {

                    public void selectionChanged(SelectionEvent ev) {
                        fireStateChanged();
                    }
                });
            }

            @Override
            public boolean isSelected() {
                // Find if selected items are all italic or not
                Boolean selectionItalicStyle = null;
                for (Selectable item : home.getSelectedItems()) {
                    Boolean italic;
                    if (item instanceof Label) {
                        italic = isItemTextItalic(item, ((Label) item).getStyle());
                    } else if (item instanceof HomePieceOfFurniture && ((HomePieceOfFurniture) item).isVisible()) {
                        italic = isItemTextItalic(item, ((HomePieceOfFurniture) item).getNameStyle());
                    } else if (item instanceof Room) {
                        Room room = (Room) item;
                        italic = isItemTextItalic(room, room.getNameStyle());
                        if (italic != isItemTextItalic(room, room.getAreaStyle())) {
                            italic = null;
                        }
                    } else if (item instanceof DimensionLine) {
                        italic = isItemTextItalic(item, ((DimensionLine) item).getLengthStyle());
                    } else {
                        continue;
                    }
                    if (selectionItalicStyle == null) {
                        selectionItalicStyle = italic;
                    } else if (italic == null || !selectionItalicStyle.equals(italic)) {
                        selectionItalicStyle = null;
                        break;
                    }
                }
                return selectionItalicStyle != null && selectionItalicStyle;
            }

            private boolean isItemTextItalic(Selectable item, TextStyle textStyle) {
                if (textStyle == null) {
                    textStyle = preferences.getDefaultTextStyle(item.getClass());
                }
                return textStyle.isItalic();
            }
        };
    }

    /**
     * Returns Import / Modify background image menu item.
     */
    private JMenuItem createImportModifyBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action importBackgroundImageAction = actionMap.get(ActionType.IMPORT_BACKGROUND_IMAGE);
        Action modifyBackgroundImageAction = actionMap.get(ActionType.MODIFY_BACKGROUND_IMAGE);
        if (importBackgroundImageAction != null && importBackgroundImageAction.getValue(Action.NAME) != null && modifyBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem importModifyBackgroundImageMenuItem = new JMenuItem(createImportModifyBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    importModifyBackgroundImageMenuItem.setAction(createImportModifyBackgroundImageAction(home, popup));
                }
            });
            return importModifyBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Adds to home and levels the given listener to follow background image changes.
     */
    private void addBackgroundImageChangeListener(final Home home, final PropertyChangeListener listener) {
        home.addPropertyChangeListener(Home.Property.BACKGROUND_IMAGE, listener);
        home.addPropertyChangeListener(Home.Property.SELECTED_LEVEL, listener);
        final PropertyChangeListener levelChangeListener = new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                if (Level.Property.BACKGROUND_IMAGE.name().equals(ev.getPropertyName())) {
                    listener.propertyChange(ev);
                }
            }
        };
        for (Level level : this.home.getLevels()) {
            level.addPropertyChangeListener(levelChangeListener);
        }
        this.home.addLevelsListener(new CollectionListener<Level>() {

            public void collectionChanged(CollectionEvent<Level> ev) {
                switch(ev.getType()) {
                    case ADD:
                        ev.getItem().addPropertyChangeListener(levelChangeListener);
                        break;
                    case DELETE:
                        ev.getItem().removePropertyChangeListener(levelChangeListener);
                        break;
                }
            }
        });
    }

    /**
     * Returns the action active on Import / Modify menu item.
     */
    private Action createImportModifyBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null ? ActionType.IMPORT_BACKGROUND_IMAGE : ActionType.MODIFY_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Hide / Show background image menu item.
     */
    private JMenuItem createHideShowBackgroundImageMenuItem(final Home home, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action hideBackgroundImageAction = actionMap.get(ActionType.HIDE_BACKGROUND_IMAGE);
        Action showBackgroundImageAction = actionMap.get(ActionType.SHOW_BACKGROUND_IMAGE);
        if (hideBackgroundImageAction != null && hideBackgroundImageAction.getValue(Action.NAME) != null && showBackgroundImageAction.getValue(Action.NAME) != null) {
            final JMenuItem hideShowBackgroundImageMenuItem = new JMenuItem(createHideShowBackgroundImageAction(home, popup));
            // Add a listener to home and levels on backgroundImage property change to
            // switch action according to backgroundImage change
            addBackgroundImageChangeListener(home, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    hideShowBackgroundImageMenuItem.setAction(createHideShowBackgroundImageAction(home, popup));
                }
            });
            return hideShowBackgroundImageMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action active on Hide / Show menu item.
     */
    private Action createHideShowBackgroundImageAction(Home home, boolean popup) {
        BackgroundImage backgroundImage = home.getSelectedLevel() != null ? home.getSelectedLevel().getBackgroundImage() : home.getBackgroundImage();
        ActionType backgroundImageActionType = backgroundImage == null || backgroundImage.isVisible() ? ActionType.HIDE_BACKGROUND_IMAGE : ActionType.SHOW_BACKGROUND_IMAGE;
        Action backgroundImageAction = getActionMap().get(backgroundImageActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Returns Go to point of view menu.
     */
    private JMenu createGoToPointOfViewMenu(final Home home, UserPreferences preferences, final HomeController controller) {
        Action goToPointOfViewAction = this.menuActionMap.get(MenuActionType.GO_TO_POINT_OF_VIEW);
        if (goToPointOfViewAction.getValue(Action.NAME) != null) {
            final JMenu goToPointOfViewMenu = new JMenu(goToPointOfViewAction);
            updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
            home.addPropertyChangeListener(Home.Property.STORED_CAMERAS, new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    updateGoToPointOfViewMenu(goToPointOfViewMenu, home, controller);
                }
            });
            return goToPointOfViewMenu;
        } else {
            return null;
        }
    }

    /**
     * Updates Go to point of view menu items from the cameras stored in home.
     */
    private void updateGoToPointOfViewMenu(JMenu goToPointOfViewMenu, Home home, final HomeController controller) {
        List<Camera> storedCameras = home.getStoredCameras();
        goToPointOfViewMenu.removeAll();
        if (storedCameras.isEmpty()) {
            goToPointOfViewMenu.setEnabled(false);
            goToPointOfViewMenu.add(new ResourceAction(preferences, HomePane.class, ""NoStoredPointOfView"", false));
        } else {
            goToPointOfViewMenu.setEnabled(true);
            for (final Camera camera : storedCameras) {
                goToPointOfViewMenu.add(new AbstractAction(camera.getName()) {

                    public void actionPerformed(ActionEvent e) {
                        controller.getHomeController3D().goToCamera(camera);
                    }
                });
            }
        }
    }

    /**
     * Returns Attach / Detach menu item for the 3D view.
     */
    private JMenuItem createAttachDetach3DViewMenuItem(final HomeController controller, final boolean popup) {
        ActionMap actionMap = getActionMap();
        Action display3DViewInSeparateWindowAction = actionMap.get(ActionType.DETACH_3D_VIEW);
        Action display3DViewInMainWindowAction = actionMap.get(ActionType.ATTACH_3D_VIEW);
        if (display3DViewInSeparateWindowAction != null && display3DViewInSeparateWindowAction.getValue(Action.NAME) != null && display3DViewInMainWindowAction.getValue(Action.NAME) != null) {
            final JMenuItem attachDetach3DViewMenuItem = new JMenuItem(createAttachDetach3DViewAction(controller, popup));
            // Add a listener to 3D view to switch action when its parent changes
            JComponent view3D = (JComponent) controller.getHomeController3D().getView();
            view3D.addAncestorListener(new AncestorListener() {

                public void ancestorAdded(AncestorEvent ev) {
                    attachDetach3DViewMenuItem.setAction(createAttachDetach3DViewAction(controller, popup));
                }

                public void ancestorRemoved(AncestorEvent ev) {
                }

                public void ancestorMoved(AncestorEvent ev) {
                }
            });
            return attachDetach3DViewMenuItem;
        } else {
            return null;
        }
    }

    /**
     * Returns the action Attach / Detach menu item.
     */
    private Action createAttachDetach3DViewAction(HomeController controller, boolean popup) {
        JRootPane view3DRootPane = SwingUtilities.getRootPane((JComponent) controller.getHomeController3D().getView());
        ActionType display3DViewActionType = view3DRootPane == this ? ActionType.DETACH_3D_VIEW : ActionType.ATTACH_3D_VIEW;
        Action backgroundImageAction = getActionMap().get(display3DViewActionType);
        return popup ? new ResourceAction.PopupMenuItemAction(backgroundImageAction) : new ResourceAction.MenuItemAction(backgroundImageAction);
    }

    /**
     * Updates <code>openRecentHomeMenu</code> from current recent homes in preferences.
     */
    protected void updateOpenRecentHomeMenu(JMenu openRecentHomeMenu, final HomeController controller) {
        openRecentHomeMenu.removeAll();
        for (final String homeName : controller.getRecentHomes()) {
            openRecentHomeMenu.add(new AbstractAction(controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D)) {

                public void actionPerformed(ActionEvent e) {
                    controller.open(homeName);
                }
            });
        }
        if (openRecentHomeMenu.getMenuComponentCount() > 0) {
            openRecentHomeMenu.addSeparator();
        }
        addActionToMenu(ActionType.DELETE_RECENT_HOMES, openRecentHomeMenu);
    }

    /**
     * Returns the tool bar displayed in this pane.
     */
    private JToolBar createToolBar(Home home) {
        final JToolBar toolBar = new UnfocusableToolBar();
        addActionToToolBar(ActionType.NEW_HOME, toolBar);
        addActionToToolBar(ActionType.OPEN, toolBar);
        addActionToToolBar(ActionType.SAVE, toolBar);
        if (!OperatingSystem.isMacOSX()) {
            addActionToToolBar(ActionType.PREFERENCES, toolBar);
        }
        toolBar.addSeparator();
        addActionToToolBar(ActionType.UNDO, toolBar);
        addActionToToolBar(ActionType.REDO, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.CUT, toolBar);
        addActionToToolBar(ActionType.COPY, toolBar);
        addActionToToolBar(ActionType.PASTE, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.ADD_HOME_FURNITURE, toolBar);
        toolBar.addSeparator();
        addToggleActionToToolBar(ActionType.SELECT, toolBar);
        addToggleActionToToolBar(ActionType.PAN, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_WALLS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_ROOMS, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_DIMENSION_LINES, toolBar);
        addToggleActionToToolBar(ActionType.CREATE_LABELS, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.INCREASE_TEXT_SIZE, toolBar);
        addActionToToolBar(ActionType.DECREASE_TEXT_SIZE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_BOLD_STYLE, toolBar);
        addToggleActionToToolBar(ActionType.TOGGLE_ITALIC_STYLE, toolBar);
        toolBar.add(Box.createRigidArea(new Dimension(2, 2)));
        addActionToToolBar(ActionType.ZOOM_IN, toolBar);
        addActionToToolBar(ActionType.ZOOM_OUT, toolBar);
        toolBar.addSeparator();
        addActionToToolBar(ActionType.CREATE_PHOTO, toolBar);
        addActionToToolBar(ActionType.CREATE_VIDEO, toolBar);
        toolBar.addSeparator();
        // Add plugin actions buttons
        boolean pluginActionsAdded = false;
        for (Action pluginAction : this.pluginActions) {
            if (Boolean.TRUE.equals(pluginAction.getValue(PluginAction.Property.TOOL_BAR.name()))) {
                toolBar.add(new ResourceAction.ToolBarAction(pluginAction));
                pluginActionsAdded = true;
            }
        }
        if (pluginActionsAdded) {
            toolBar.addSeparator();
        }
        addActionToToolBar(ActionType.HELP, toolBar);
        // Remove useless separators
        for (int i = toolBar.getComponentCount() - 1; i > 0; i--) {
            Component child = toolBar.getComponent(i);
            if (child instanceof JSeparator && (i == toolBar.getComponentCount() - 1 || toolBar.getComponent(i - 1) instanceof JSeparator)) {
                toolBar.remove(i);
            }
        }
        return toolBar;
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>
     * and returns <code>true</code> if it was added.
     */
    private void addToggleActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            Action toolBarAction = new ResourceAction.ToolBarAction(action);
            JToggleButton toggleButton = new JToggleButton(toolBarAction);
            toggleButton.setModel((JToggleButton.ToggleButtonModel) action.getValue(ResourceAction.TOGGLE_BUTTON_MODEL));
            toolBar.add(toggleButton);
        }
    }

    /**
     * Adds to tool bar the button matching the given <code>actionType</code>.
     */
    private void addActionToToolBar(ActionType actionType, JToolBar toolBar) {
        Action action = getActionMap().get(actionType);
        if (action != null && action.getValue(Action.NAME) != null) {
            toolBar.add(new ResourceAction.ToolBarAction(action));
        }
    }

    /**
     * Enables or disables the action matching <code>actionType</code>.
     */
    public void setEnabled(ActionType actionType, boolean enabled) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            action.setEnabled(enabled);
        }
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * of undo and redo actions. If a parameter is null,
     * the properties will be reset to their initial values.
     */
    public void setUndoRedoName(String undoText, String redoText) {
        setNameAndShortDescription(ActionType.UNDO, undoText);
        setNameAndShortDescription(ActionType.REDO, redoText);
    }

    /**
     * Sets the <code>NAME</code> and <code>SHORT_DESCRIPTION</code> properties value
     * matching <code>actionType</code>. If <code>name</code> is null,
     * the properties will be reset to their initial values.
     */
    private void setNameAndShortDescription(ActionType actionType, String name) {
        Action action = getActionMap().get(actionType);
        if (action != null) {
            if (name == null) {
                name = (String) action.getValue(Action.DEFAULT);
            }
            action.putValue(Action.NAME, name);
            action.putValue(Action.SHORT_DESCRIPTION, name);
        }
    }

    /**
     * Enables or disables transfer between components.
     */
    public void setTransferEnabled(boolean enabled) {
        boolean dragAndDropWithTransferHandlerSupported;
        try {
            // Don't use transfer handlers for drag and drop with Plugin2 under Mac OS X or when in an unsigned applet
            dragAndDropWithTransferHandlerSupported = !Boolean.getBoolean(""com.eteks.sweethome3d.dragAndDropWithoutTransferHandler"");
        } catch (AccessControlException ex) {
            dragAndDropWithTransferHandlerSupported = false;
        }
        JComponent catalogView = (JComponent) this.controller.getFurnitureCatalogController().getView();
        JComponent furnitureView = (JComponent) this.controller.getFurnitureController().getView();
        JComponent planView = (JComponent) this.controller.getPlanController().getView();
        if (enabled) {
            if (catalogView != null) {
                catalogView.setTransferHandler(this.catalogTransferHandler);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(this.furnitureTransferHandler);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(this.furnitureTransferHandler);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(this.planTransferHandler);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    // Check if furniture catalog is handled by a subcomponent
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    if (this.furnitureCatalogDragAndDropListener == null) {
                        this.furnitureCatalogDragAndDropListener = createFurnitureCatalogMouseListener();
                    }
                    catalogComponent.addMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.addMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        } else {
            if (catalogView != null) {
                catalogView.setTransferHandler(null);
            }
            if (furnitureView != null) {
                furnitureView.setTransferHandler(null);
                if (furnitureView instanceof Scrollable) {
                    ((JViewport) furnitureView.getParent()).setTransferHandler(null);
                }
            }
            if (planView != null) {
                planView.setTransferHandler(null);
            }
            if (!dragAndDropWithTransferHandlerSupported) {
                if (catalogView != null) {
                    List<JViewport> viewports = SwingTools.findChildren(catalogView, JViewport.class);
                    JComponent catalogComponent;
                    if (viewports.size() > 0) {
                        catalogComponent = (JComponent) viewports.get(0).getView();
                    } else {
                        catalogComponent = catalogView;
                    }
                    catalogComponent.removeMouseListener(this.furnitureCatalogDragAndDropListener);
                    catalogComponent.removeMouseMotionListener(this.furnitureCatalogDragAndDropListener);
                }
            }
        }
        this.transferHandlerEnabled = enabled;
    }

    /**
     * Returns a mouse listener for catalog that acts as catalog view, furniture view and plan transfer handlers
     * for drag and drop operations.
     */
    private MouseInputAdapter createFurnitureCatalogMouseListener() {
        return new MouseInputAdapter() {

            private CatalogPieceOfFurniture selectedPiece;

            private TransferHandler transferHandler;

            private boolean autoscrolls;

            private Cursor previousCursor;

            private View previousView;

            @Override
            public void mousePressed(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev)) {
                    List<CatalogPieceOfFurniture> selectedFurniture = controller.getFurnitureCatalogController().getSelectedFurniture();
                    if (selectedFurniture.size() > 0) {
                        JComponent source = (JComponent) ev.getSource();
                        this.transferHandler = source.getTransferHandler();
                        source.setTransferHandler(null);
                        this.autoscrolls = source.getAutoscrolls();
                        source.setAutoscrolls(false);
                        this.selectedPiece = selectedFurniture.get(0);
                        this.previousCursor = null;
                        this.previousView = null;
                    }
                }
            }

            @Override
            public void mouseDragged(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    // Force selection again
                    List<CatalogPieceOfFurniture> emptyList = Collections.emptyList();
                    controller.getFurnitureCatalogController().setSelectedFurniture(emptyList);
                    controller.getFurnitureCatalogController().setSelectedFurniture(Arrays.asList(new CatalogPieceOfFurniture[] { this.selectedPiece }));
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (this.previousView != view) {
                        if (this.previousView != null) {
                            if (this.previousView == controller.getPlanController().getView()) {
                                controller.getPlanController().stopDraggedItems();
                            }
                            ((JComponent) this.previousView).setCursor(this.previousCursor);
                            this.previousCursor = null;
                            this.previousView = null;
                        }
                        if (view != null) {
                            JComponent component = (JComponent) view;
                            this.previousCursor = component.getCursor();
                            this.previousView = view;
                            component.setCursor(DragSource.DefaultCopyDrop);
                            if (component.getParent() instanceof JViewport) {
                                ((JViewport) component.getParent()).setCursor(DragSource.DefaultCopyDrop);
                            }
                            if (view == controller.getPlanController().getView()) {
                                controller.getPlanController().startDraggedItems(transferredFurniture, pointInView[0], pointInView[1]);
                            }
                        }
                    } else if (pointInView != null) {
                        controller.getPlanController().moveMouse(pointInView[0], pointInView[1]);
                    }
                }
            }

            private float[] getPointInPlanView(MouseEvent ev, List<Selectable> transferredFurniture) {
                PlanView planView = controller.getPlanController().getView();
                if (planView != null) {
                    JComponent planComponent = (JComponent) planView;
                    Point pointInPlanComponent = SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent);
                    if (planComponent.getParent() instanceof JViewport && ((JViewport) planComponent.getParent()).contains(SwingUtilities.convertPoint(ev.getComponent(), ev.getPoint(), planComponent.getParent())) || !(planComponent.getParent() instanceof JViewport) && planView.canImportDraggedItems(transferredFurniture, pointInPlanComponent.x, pointInPlanComponent.y)) {
                        return new float[] { planView.convertXPixelToModel(pointInPlanComponent.x), planView.convertYPixelToModel(pointInPlanComponent.y) };
                    }
                }
                return null;
            }

            private float[] getPointInFurnitureView(MouseEvent ev) {
                View furnitureView = controller.getFurnitureController().getView();
                if (furnitureView != null) {
                    JComponent furnitureComponent = (JComponent) furnitureView;
                    Point point = SwingUtilities.convertPoint(ev.getComponent(), ev.getX(), ev.getY(), furnitureComponent.getParent() instanceof JViewport ? furnitureComponent.getParent() : furnitureComponent);
                    if (furnitureComponent.getParent() instanceof JViewport && ((JViewport) furnitureComponent.getParent()).contains(point) || !(furnitureComponent.getParent() instanceof JViewport) && furnitureComponent.contains(point)) {
                        return new float[] { 0, 0 };
                    }
                }
                return null;
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                if (SwingUtilities.isLeftMouseButton(ev) && this.selectedPiece != null) {
                    List<Selectable> transferredFurniture = Arrays.asList(new Selectable[] { controller.getFurnitureController().createHomePieceOfFurniture(this.selectedPiece) });
                    View view;
                    float[] pointInView = getPointInPlanView(ev, transferredFurniture);
                    if (pointInView != null) {
                        controller.getPlanController().stopDraggedItems();
                        view = controller.getPlanController().getView();
                    } else {
                        view = controller.getFurnitureController().getView();
                        pointInView = getPointInFurnitureView(ev);
                    }
                    if (pointInView != null) {
                        controller.drop(transferredFurniture, view, pointInView[0], pointInView[1]);
                        ((JComponent) this.previousView).setCursor(this.previousCursor);
                    }
                    this.selectedPiece = null;
                    JComponent source = (JComponent) ev.getSource();
                    source.setTransferHandler(this.transferHandler);
                    source.setAutoscrolls(this.autoscrolls);
                }
            }
        };
    }

    /**
     * Returns the main pane with catalog tree, furniture table and plan pane.
     */
    private JComponent createMainPane(Home home, UserPreferences preferences, HomeController controller) {
        final JComponent catalogFurniturePane = createCatalogFurniturePane(home, preferences, controller);
        final JComponent planView3DPane = createPlanView3DPane(home, preferences, controller);
        if (catalogFurniturePane == null) {
            return planView3DPane;
        } else if (planView3DPane == null) {
            return catalogFurniturePane;
        } else {
            final JSplitPane mainPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, catalogFurniturePane, planView3DPane);
            // Set default divider location
            mainPane.setDividerLocation(360);
            configureSplitPane(mainPane, home, MAIN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.3, true, controller);
            return mainPane;
        }
    }

    /**
     * Configures <code>splitPane</code> divider location.
     * If <code>dividerLocationProperty</code> visual property exists in <code>home</code>,
     * its value will be used, otherwise the given resize weight will be used.
     */
    private void configureSplitPane(final JSplitPane splitPane, Home home, final String dividerLocationProperty, final double defaultResizeWeight, boolean showBorder, final HomeController controller) {
        splitPane.setContinuousLayout(true);
        splitPane.setOneTouchExpandable(true);
        splitPane.setResizeWeight(defaultResizeWeight);
        if (!showBorder) {
            splitPane.setBorder(null);
        }
        // Restore divider location previously set
        Integer dividerLocation = (Integer) home.getVisualProperty(dividerLocationProperty);
        if (dividerLocation != null) {
            splitPane.setDividerLocation(dividerLocation);
        }
        splitPane.addPropertyChangeListener(JSplitPane.DIVIDER_LOCATION_PROPERTY, new PropertyChangeListener() {

            public void propertyChange(final PropertyChangeEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        Component focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
                        if (focusOwner != null && isChildComponentInvisible(splitPane, focusOwner)) {
                            FocusTraversalPolicy focusTraversalPolicy = getFocusTraversalPolicy();
                            Component focusedComponent = focusTraversalPolicy.getComponentAfter(HomePane.this, focusOwner);
                            if (focusedComponent == null) {
                                focusedComponent = focusTraversalPolicy.getComponentBefore(HomePane.this, focusOwner);
                            }
                            if (focusedComponent != null) {
                                focusedComponent.requestFocusInWindow();
                            }
                        }
                        controller.setVisualProperty(dividerLocationProperty, ev.getNewValue());
                    }
                });
            }
        });
    }

    /**
     * Returns the catalog tree and furniture table pane.
     */
    private JComponent createCatalogFurniturePane(Home home, UserPreferences preferences, final HomeController controller) {
        JComponent catalogView = (JComponent) controller.getFurnitureCatalogController().getView();
        if (catalogView != null) {
            // Create catalog view popup menu
            JPopupMenu catalogViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.COPY, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_HOME_FURNITURE, catalogViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, catalogViewPopup);
            catalogViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.IMPORT_FURNITURE, catalogViewPopup);
            SwingTools.hideDisabledMenuItems(catalogViewPopup);
            catalogView.setComponentPopupMenu(catalogViewPopup);
            preferences.addPropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, new FurnitureCatalogViewChangeListener(this, catalogView));
            if (catalogView instanceof Scrollable) {
                catalogView = SwingTools.createScrollPane(catalogView);
            }
        }
        // Configure furniture view
        JComponent furnitureView = (JComponent) controller.getFurnitureController().getView();
        if (furnitureView != null) {
            // Set default traversal keys of furniture view
            KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS));
            furnitureView.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, focusManager.getDefaultFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS));
            // Create furniture view popup menu
            JPopupMenu furnitureViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, furnitureViewPopup);
            addActionToPopupMenu(ActionType.REDO, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, furnitureViewPopup);
            addActionToPopupMenu(ActionType.COPY, furnitureViewPopup);
            addActionToPopupMenu(ActionType.PASTE, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.SELECT_ALL, furnitureViewPopup);
            furnitureViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, furnitureViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, furnitureViewPopup);
            furnitureViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            furnitureViewPopup.addSeparator();
            furnitureViewPopup.add(createFurnitureSortMenu(home, preferences));
            furnitureViewPopup.add(createFurnitureDisplayPropertyMenu(home, preferences));
            SwingTools.hideDisabledMenuItems(furnitureViewPopup);
            furnitureView.setComponentPopupMenu(furnitureViewPopup);
            if (furnitureView instanceof Scrollable) {
                JScrollPane furnitureScrollPane = SwingTools.createScrollPane(furnitureView);
                // Add a mouse listener that gives focus to furniture view when
                // user clicks in its viewport (tables don't spread vertically if their row count is too small)
                final JViewport viewport = furnitureScrollPane.getViewport();
                viewport.addMouseListener(new MouseAdapter() {

                    @Override
                    public void mouseClicked(MouseEvent ev) {
                        viewport.getView().requestFocusInWindow();
                    }
                });
                Integer viewportY = (Integer) home.getVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportY != null) {
                    viewport.setViewPosition(new Point(0, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        controller.setVisualProperty(FURNITURE_VIEWPORT_Y_VISUAL_PROPERTY, viewport.getViewPosition().y);
                    }
                });
                ((JViewport) furnitureView.getParent()).setComponentPopupMenu(furnitureViewPopup);
                furnitureView = furnitureScrollPane;
            }
        }
        if (catalogView == null) {
            return furnitureView;
        } else if (furnitureView == null) {
            return catalogView;
        } else {
            // Create a split pane that displays both components
            JSplitPane catalogFurniturePane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, catalogView, furnitureView);
            catalogFurniturePane.setBorder(null);
            catalogFurniturePane.setMinimumSize(new Dimension());
            configureSplitPane(catalogFurniturePane, home, CATALOG_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
            return catalogFurniturePane;
        }
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class FurnitureCatalogViewChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JComponent> furnitureCatalogView;

        public FurnitureCatalogViewChangeListener(HomePane homePane, JComponent furnitureCatalogView) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.furnitureCatalogView = new WeakReference<JComponent>(furnitureCatalogView);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            if (homePane == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.FURNITURE_CATALOG_VIEWED_IN_TREE, this);
            } else {
                // Replace previous furniture catalog view by the new one
                JComponent oldFurnitureCatalogView = this.furnitureCatalogView.get();
                if (oldFurnitureCatalogView != null) {
                    boolean transferHandlerEnabled = homePane.transferHandlerEnabled;
                    homePane.setTransferEnabled(false);
                    JComponent newFurnitureCatalogView = (JComponent) homePane.controller.getFurnitureCatalogController().getView();
                    newFurnitureCatalogView.setComponentPopupMenu(oldFurnitureCatalogView.getComponentPopupMenu());
                    homePane.setTransferEnabled(transferHandlerEnabled);
                    JComponent splitPaneTopComponent = newFurnitureCatalogView;
                    if (newFurnitureCatalogView instanceof Scrollable) {
                        splitPaneTopComponent = SwingTools.createScrollPane(newFurnitureCatalogView);
                    } else {
                        splitPaneTopComponent = newFurnitureCatalogView;
                    }
                    ((JSplitPane) SwingUtilities.getAncestorOfClass(JSplitPane.class, oldFurnitureCatalogView)).setTopComponent(splitPaneTopComponent);
                    this.furnitureCatalogView = new WeakReference<JComponent>(newFurnitureCatalogView);
                }
            }
        }
    }

    /**
     * Returns the plan view and 3D view pane.
     */
    private JComponent createPlanView3DPane(final Home home, UserPreferences preferences, final HomeController controller) {
        JComponent planView = (JComponent) controller.getPlanController().getView();
        if (planView != null) {
            // Create plan view popup menu
            JPopupMenu planViewPopup = new JPopupMenu();
            addActionToPopupMenu(ActionType.UNDO, planViewPopup);
            addActionToPopupMenu(ActionType.REDO, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.CUT, planViewPopup);
            addActionToPopupMenu(ActionType.COPY, planViewPopup);
            addActionToPopupMenu(ActionType.PASTE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.DELETE, planViewPopup);
            Action selectObjectAction = this.menuActionMap.get(MenuActionType.SELECT_OBJECT_MENU);
            JMenu selectObjectMenu;
            if (selectObjectAction.getValue(Action.NAME) != null) {
                selectObjectMenu = new JMenu(selectObjectAction);
                planViewPopup.add(selectObjectMenu);
            } else {
                selectObjectMenu = null;
            }
            addActionToPopupMenu(ActionType.SELECT_ALL, planViewPopup);
            planViewPopup.addSeparator();
            addToggleActionToPopupMenu(ActionType.SELECT, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.PAN, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_WALLS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_ROOMS, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_DIMENSION_LINES, true, planViewPopup);
            addToggleActionToPopupMenu(ActionType.CREATE_LABELS, true, planViewPopup);
            planViewPopup.addSeparator();
            JMenuItem lockUnlockBasePlanMenuItem = createLockUnlockBasePlanMenuItem(home, true);
            if (lockUnlockBasePlanMenuItem != null) {
                planViewPopup.add(lockUnlockBasePlanMenuItem);
            }
            addActionToPopupMenu(ActionType.MODIFY_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.GROUP_FURNITURE, planViewPopup);
            addActionToPopupMenu(ActionType.UNGROUP_FURNITURE, planViewPopup);
            planViewPopup.add(createAlignOrDistributeMenu(home, preferences, true));
            addActionToPopupMenu(ActionType.MODIFY_COMPASS, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.REVERSE_WALL_DIRECTION, planViewPopup);
            addActionToPopupMenu(ActionType.SPLIT_WALL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_ROOM, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LABEL, planViewPopup);
            planViewPopup.add(createTextStyleMenu(home, preferences, true));
            planViewPopup.addSeparator();
            JMenuItem importModifyBackgroundImageMenuItem = createImportModifyBackgroundImageMenuItem(home, true);
            if (importModifyBackgroundImageMenuItem != null) {
                planViewPopup.add(importModifyBackgroundImageMenuItem);
            }
            JMenuItem hideShowBackgroundImageMenuItem = createHideShowBackgroundImageMenuItem(home, true);
            if (hideShowBackgroundImageMenuItem != null) {
                planViewPopup.add(hideShowBackgroundImageMenuItem);
            }
            addActionToPopupMenu(ActionType.DELETE_BACKGROUND_IMAGE, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ADD_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.MODIFY_LEVEL, planViewPopup);
            addActionToPopupMenu(ActionType.DELETE_LEVEL, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.ZOOM_OUT, planViewPopup);
            addActionToPopupMenu(ActionType.ZOOM_IN, planViewPopup);
            planViewPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_SVG, planViewPopup);
            SwingTools.hideDisabledMenuItems(planViewPopup);
            if (selectObjectMenu != null) {
                // Add a second popup listener to manage Select object sub menu before the menu is hidden when empty
                addSelectObjectMenuItems(selectObjectMenu, controller.getPlanController(), preferences);
            }
            planView.setComponentPopupMenu(planViewPopup);
            final JScrollPane planScrollPane;
            if (planView instanceof Scrollable) {
                planView = planScrollPane = SwingTools.createScrollPane(planView);
            } else {
                List<JScrollPane> scrollPanes = SwingTools.findChildren(planView, JScrollPane.class);
                if (scrollPanes.size() == 1) {
                    planScrollPane = scrollPanes.get(0);
                } else {
                    planScrollPane = null;
                }
            }
            if (planScrollPane != null) {
                setPlanRulersVisible(planScrollPane, controller, preferences.isRulersVisible());
                if (planScrollPane.getCorner(JScrollPane.UPPER_LEADING_CORNER) == null) {
                    final JComponent lockUnlockBasePlanButton = createLockUnlockBasePlanButton(home);
                    if (lockUnlockBasePlanButton != null) {
                        planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                        planScrollPane.addPropertyChangeListener(""componentOrientation"", new PropertyChangeListener() {

                            public void propertyChange(PropertyChangeEvent ev) {
                                if (lockUnlockBasePlanButton.getParent() != null) {
                                    planScrollPane.setCorner(JScrollPane.UPPER_LEADING_CORNER, lockUnlockBasePlanButton);
                                }
                            }
                        });
                    }
                }
                // Add a listener to update rulers visibility in preferences
                preferences.addPropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, new RulersVisibilityChangeListener(this, planScrollPane, controller));
                // Restore viewport position if it exists
                final JViewport viewport = planScrollPane.getViewport();
                Integer viewportX = (Integer) home.getVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY);
                Integer viewportY = (Integer) home.getVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY);
                if (viewportX != null && viewportY != null) {
                    viewport.setViewPosition(new Point(viewportX, viewportY));
                }
                viewport.addChangeListener(new ChangeListener() {

                    public void stateChanged(ChangeEvent ev) {
                        Point viewportPosition = viewport.getViewPosition();
                        controller.setVisualProperty(PLAN_VIEWPORT_X_VISUAL_PROPERTY, viewportPosition.x);
                        controller.setVisualProperty(PLAN_VIEWPORT_Y_VISUAL_PROPERTY, viewportPosition.y);
                    }
                });
            }
        }
        // Configure 3D view
        JComponent view3D = (JComponent) controller.getHomeController3D().getView();
        if (view3D != null) {
            view3D.setPreferredSize(planView != null ? planView.getPreferredSize() : new Dimension(400, 400));
            view3D.setMinimumSize(new Dimension());
            // Create 3D view popup menu
            JPopupMenu view3DPopup = new JPopupMenu();
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_TOP, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.VIEW_FROM_OBSERVER, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_OBSERVER, view3DPopup);
            addActionToPopupMenu(ActionType.STORE_POINT_OF_VIEW, view3DPopup);
            JMenu goToPointOfViewMenu = createGoToPointOfViewMenu(home, preferences, controller);
            if (goToPointOfViewMenu != null) {
                view3DPopup.add(goToPointOfViewMenu);
            }
            view3DPopup.addSeparator();
            JMenuItem attachDetach3DViewMenuItem = createAttachDetach3DViewMenuItem(controller, true);
            if (attachDetach3DViewMenuItem != null) {
                view3DPopup.add(attachDetach3DViewMenuItem);
            }
            addToggleActionToPopupMenu(ActionType.DISPLAY_ALL_LEVELS, true, view3DPopup);
            addToggleActionToPopupMenu(ActionType.DISPLAY_SELECTED_LEVEL, true, view3DPopup);
            addActionToPopupMenu(ActionType.MODIFY_3D_ATTRIBUTES, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.CREATE_PHOTO, view3DPopup);
            addActionToPopupMenu(ActionType.CREATE_VIDEO, view3DPopup);
            view3DPopup.addSeparator();
            addActionToPopupMenu(ActionType.EXPORT_TO_OBJ, view3DPopup);
            SwingTools.hideDisabledMenuItems(view3DPopup);
            view3D.setComponentPopupMenu(view3DPopup);
            if (view3D instanceof Scrollable) {
                view3D = SwingTools.createScrollPane(view3D);
            }
            JComponent planView3DPane;
            if (planView != null) {
                // Create a split pane that displays both components
                final JSplitPane planView3DSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, planView, view3D);
                planView3DSplitPane.setMinimumSize(new Dimension());
                configureSplitPane((JSplitPane) planView3DSplitPane, home, PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY, 0.5, false, controller);
                final Integer dividerLocation = (Integer) home.getVisualProperty(PLAN_PANE_DIVIDER_LOCATION_VISUAL_PROPERTY);
                if (OperatingSystem.isMacOSX() && dividerLocation != null && dividerLocation > 2) {
                    // Under Mac OS X, ensure that the 3D view of an existing home will be displayed during a while
                    // to avoid a freeze when the 3D view was saved as hidden and then the window displaying the 3D view is enlarged
                    planView3DSplitPane.addAncestorListener(new AncestorListener() {

                        public void ancestorAdded(AncestorEvent event) {
                            planView3DSplitPane.removeAncestorListener(this);
                            if (planView3DSplitPane.getRightComponent().getHeight() == 0) {
                                // If the 3D view is invisible, make it appear during a while
                                planView3DSplitPane.setDividerLocation(dividerLocation - 2);
                                Executors.newSingleThreadScheduledExecutor().schedule(new Runnable() {

                                    public void run() {
                                        EventQueue.invokeLater(new Runnable() {

                                            public void run() {
                                                planView3DSplitPane.setDividerLocation(dividerLocation);
                                            }
                                        });
                                    }
                                }, 1, TimeUnit.SECONDS);
                            }
                        }

                        public void ancestorRemoved(AncestorEvent event) {
                        }

                        public void ancestorMoved(AncestorEvent event) {
                        }
                    });
                }
                planView3DPane = planView3DSplitPane;
            } else {
                planView3DPane = view3D;
            }
            // Detach 3D view if it was detached when saved and its dialog can be viewed in one of the screen devices
            Boolean detachedView3D = (Boolean) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY);
            if (detachedView3D != null && detachedView3D.booleanValue()) {
                // Check 3D view can be viewed in one of the available screens
                final Integer dialogX = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
                final Integer dialogY = (Integer) this.home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY);
                final Integer dialogWidth = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
                final Integer dialogHeight = (Integer) home.getVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY);
                if (dialogX != null && dialogY != null && dialogWidth != null && dialogHeight != null && SwingTools.isRectangleVisibleAtScreen(new Rectangle(dialogX, dialogY, dialogWidth, dialogHeight))) {
                    EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            View view3D = controller.getHomeController3D().getView();
                            detachView(view3D, dialogX, dialogY, dialogWidth, dialogHeight);
                        }
                    });
                    return planView3DPane;
                }
                if (planView3DPane instanceof JSplitPane) {
                    ((JSplitPane) planView3DPane).setDividerLocation(0.5);
                }
                controller.setVisualProperty(view3D.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, null);
            }
            return planView3DPane;
        } else {
            return planView;
        }
    }

    /**
     * Adds to the menu a listener that will update the menu items able to select
     * the selectable items in plan at the location where the menu will be triggered.
     */
    private void addSelectObjectMenuItems(final JMenu selectObjectMenu, final PlanController planController, final UserPreferences preferences) {
        JComponent planView = (JComponent) planController.getView();
        final Point lastMouseMoveLocation = new Point(-1, -1);
        ((JPopupMenu) selectObjectMenu.getParent()).addPopupMenuListener(new PopupMenuListener() {

            @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
            public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
                if (lastMouseMoveLocation.getX() >= 0 && !planController.isModificationState()) {
                    final List<Selectable> items = planController.getSelectableItemsAt(planController.getView().convertXPixelToModel(lastMouseMoveLocation.x), planController.getView().convertYPixelToModel(lastMouseMoveLocation.y));
                    // Prepare localized formatters
                    Map<Class<? extends Selectable>, SelectableFormat> formatters = new HashMap<Class<? extends Selectable>, SelectableFormat>();
                    formatters.put(Compass.class, new SelectableFormat<Compass>() {

                        public String format(Compass compass) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.compass"");
                        }
                    });
                    formatters.put(HomePieceOfFurniture.class, new SelectableFormat<HomePieceOfFurniture>() {

                        public String format(HomePieceOfFurniture piece) {
                            if (piece.getName().length() > 0) {
                                return piece.getName();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.furniture"");
                            }
                        }
                    });
                    formatters.put(Wall.class, new SelectableFormat<Wall>() {

                        public String format(Wall wall) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.wall"", preferences.getLengthUnit().getFormatWithUnit().format(wall.getLength()));
                        }
                    });
                    formatters.put(Room.class, new SelectableFormat<Room>() {

                        public String format(Room room) {
                            String roomInfo = room.getName() != null && room.getName().length() > 0 ? room.getName() : (room.isAreaVisible() ? preferences.getLengthUnit().getAreaFormatWithUnit().format(room.getArea()) : """");
                            if (room.isFloorVisible() && !room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.floor"", roomInfo);
                            } else if (!room.isFloorVisible() && room.isCeilingVisible()) {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.ceiling"", roomInfo);
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.room"", roomInfo);
                            }
                        }
                    });
                    formatters.put(DimensionLine.class, new SelectableFormat<DimensionLine>() {

                        public String format(DimensionLine dimensionLine) {
                            return preferences.getLocalizedString(HomePane.class, ""selectObject.dimensionLine"", preferences.getLengthUnit().getFormatWithUnit().format(dimensionLine.getLength()));
                        }
                    });
                    formatters.put(Label.class, new SelectableFormat<Label>() {

                        public String format(Label label) {
                            if (label.getText().length() > 0) {
                                return label.getText();
                            } else {
                                return preferences.getLocalizedString(HomePane.class, ""selectObject.label"");
                            }
                        }
                    });
                    for (final Selectable item : items) {
                        String format = null;
                        for (Map.Entry<Class<? extends Selectable>, SelectableFormat> entry : formatters.entrySet()) {
                            if (entry.getKey().isInstance(item)) {
                                format = entry.getValue().format(item);
                                break;
                            }
                        }
                        if (format != null) {
                            selectObjectMenu.add(new JMenuItem(new AbstractAction(format) {

                                public void actionPerformed(ActionEvent ev) {
                                    planController.selectItem(item);
                                }
                            }));
                        }
                    }
                }
            }

            public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
                selectObjectMenu.removeAll();
            }

            public void popupMenuCanceled(PopupMenuEvent ev) {
            }
        });
        planView.addMouseMotionListener(new MouseMotionAdapter() {

            @Override
            public void mouseMoved(MouseEvent ev) {
                lastMouseMoveLocation.setLocation(ev.getPoint());
            }
        });
        planView.addMouseListener(new MouseAdapter() {

            @Override
            public void mouseExited(MouseEvent e) {
                lastMouseMoveLocation.x = -1;
            }
        });
    }

    /**
     * Preferences property listener bound to this component with a weak reference to avoid
     * strong link between preferences and this component.
     */
    private static class RulersVisibilityChangeListener implements PropertyChangeListener {

        private WeakReference<HomePane> homePane;

        private WeakReference<JScrollPane> planScrollPane;

        private WeakReference<HomeController> controller;

        public RulersVisibilityChangeListener(HomePane homePane, JScrollPane planScrollPane, HomeController controller) {
            this.homePane = new WeakReference<HomePane>(homePane);
            this.planScrollPane = new WeakReference<JScrollPane>(planScrollPane);
            this.controller = new WeakReference<HomeController>(controller);
        }

        public void propertyChange(PropertyChangeEvent ev) {
            // If home pane was garbage collected, remove this listener from preferences
            HomePane homePane = this.homePane.get();
            JScrollPane planScrollPane = this.planScrollPane.get();
            HomeController controller = this.controller.get();
            if (homePane == null || planScrollPane == null || controller == null) {
                ((UserPreferences) ev.getSource()).removePropertyChangeListener(UserPreferences.Property.RULERS_VISIBLE, this);
            } else {
                homePane.setPlanRulersVisible(planScrollPane, controller, (Boolean) ev.getNewValue());
            }
        }
    }

    /**
     * Sets the rulers visible in plan view.
     */
    private void setPlanRulersVisible(JScrollPane planScrollPane, HomeController controller, boolean visible) {
        if (visible) {
            // Change column and row header views
            planScrollPane.setColumnHeaderView((JComponent) controller.getPlanController().getHorizontalRulerView());
            planScrollPane.setRowHeaderView((JComponent) controller.getPlanController().getVerticalRulerView());
        } else {
            planScrollPane.setColumnHeaderView(null);
            planScrollPane.setRowHeaderView(null);
        }
    }

    /**
     * Adds to <code>view</code> a mouse listener that disables all menu items of
     * <code>menuBar</code> during a drag and drop operation in <code>view</code>.
     */
    private void disableMenuItemsDuringDragAndDrop(View view, final JMenuBar menuBar) {
        class MouseAndFocusListener extends MouseAdapter implements FocusListener {

            @Override
            public void mousePressed(MouseEvent ev) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), false);
                        }
                    }
                });
            }

            @Override
            public void mouseReleased(MouseEvent ev) {
                enableMenuItems(menuBar);
            }

            private void enableMenuItems(final JMenuBar menuBar) {
                EventQueue.invokeLater(new Runnable() {

                    public void run() {
                        for (int i = 0, n = menuBar.getMenuCount(); i < n; i++) {
                            setMenuItemsEnabled(menuBar.getMenu(i), true);
                        }
                    }
                });
            }

            private void setMenuItemsEnabled(JMenu menu, boolean enabled) {
                for (int i = 0, n = menu.getItemCount(); i < n; i++) {
                    JMenuItem item = menu.getItem(i);
                    if (item instanceof JMenu) {
                        setMenuItemsEnabled((JMenu) item, enabled);
                    } else if (item != null) {
                        item.setEnabled(enabled ? item.getAction().isEnabled() : false);
                    }
                }
            }

            // Need to take into account focus events because a mouse released event
            // isn't dispatched when the component loses focus
            public void focusGained(FocusEvent ev) {
                enableMenuItems(menuBar);
            }

            public void focusLost(FocusEvent ev) {
                enableMenuItems(menuBar);
            }
        }
        ;
        MouseAndFocusListener listener = new MouseAndFocusListener();
        if (view != null) {
            ((JComponent) view).addMouseListener(listener);
            ((JComponent) view).addFocusListener(listener);
        }
    }

    /**
     * Detaches the given <code>view</code> from home view.
     */
    public void detachView(final View view) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        float dividerLocation;
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            if (splitPane.getOrientation() == JSplitPane.VERTICAL_SPLIT) {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getHeight() - splitPane.getDividerSize());
            } else {
                dividerLocation = (float) splitPane.getDividerLocation() / (splitPane.getWidth() - splitPane.getDividerSize());
            }
        } else {
            dividerLocation = -1;
        }
        Integer dialogX = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY);
        Integer dialogWidth = (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY);
        if (dialogX != null && dialogWidth != null) {
            detachView(view, dialogX, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY), dialogWidth, (Integer) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY));
        } else {
            Point componentLocation = new Point();
            Dimension componentSize = component.getSize();
            SwingUtilities.convertPointToScreen(componentLocation, component);
            Insets insets = new JDialog().getInsets();
            detachView(view, componentLocation.x - insets.left, componentLocation.y - insets.top, componentSize.width + insets.left + insets.right, componentSize.height + insets.top + insets.bottom);
        }
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY, dividerLocation);
    }

    /**
     * Detaches a <code>view</code> at the given location and size.
     */
    private void detachView(final View view, int x, int y, int width, int height) {
        JComponent component = (JComponent) view;
        Container parent = component.getParent();
        if (parent instanceof JViewport) {
            component = (JComponent) parent.getParent();
            parent = component.getParent();
        }
        // Replace component by a dummy label to find easily where to attach back the component
        JLabel dummyLabel = new JLabel();
        dummyLabel.setMaximumSize(new Dimension());
        dummyLabel.setName(view.getClass().getName());
        dummyLabel.setBorder(component.getBorder());
        if (parent instanceof JSplitPane) {
            JSplitPane splitPane = (JSplitPane) parent;
            splitPane.setDividerSize(0);
            if (splitPane.getLeftComponent() == component) {
                splitPane.setLeftComponent(dummyLabel);
                splitPane.setDividerLocation(0f);
            } else {
                splitPane.setRightComponent(dummyLabel);
                splitPane.setDividerLocation(1f);
            }
        } else {
            int componentIndex = parent.getComponentZOrder(component);
            parent.remove(componentIndex);
            parent.add(dummyLabel, componentIndex);
        }
        // Display view in a separate non modal dialog
        Window window = SwingUtilities.getWindowAncestor(this);
        if (!(window instanceof JFrame)) {
            window = JOptionPane.getRootFrame();
        }
        JFrame defaultFrame = (JFrame) window;
        // Create a dialog with the same title as home frame
        final JDialog separateDialog = new JDialog(defaultFrame, defaultFrame.getTitle(), false);
        separateDialog.setResizable(true);
        defaultFrame.addPropertyChangeListener(""title"", new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                separateDialog.setTitle((String) ev.getNewValue());
            }
        });
        // Use same document modified indicator
        if (OperatingSystem.isMacOSXLeopardOrSuperior()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""Window.documentModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""Window.documentModified"", ev.getNewValue());
                }
            });
        } else if (OperatingSystem.isMacOSX()) {
            defaultFrame.getRootPane().addPropertyChangeListener(""windowModified"", new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    separateDialog.getRootPane().putClientProperty(""windowModified"", ev.getNewValue());
                }
            });
        }
        separateDialog.setContentPane(component);
        separateDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        separateDialog.addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent ev) {
                controller.attachView(view);
            }
        });
        separateDialog.addComponentListener(new ComponentAdapter() {

            @Override
            public void componentResized(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_WIDTH_VISUAL_PROPERTY, separateDialog.getWidth());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_HEIGHT_VISUAL_PROPERTY, separateDialog.getHeight());
            }

            @Override
            public void componentMoved(ComponentEvent ev) {
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_X_VISUAL_PROPERTY, separateDialog.getX());
                controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_Y_VISUAL_PROPERTY, separateDialog.getY());
            }
        });
        separateDialog.setBounds(x, y, width, height);
        separateDialog.setLocationByPlatform(!SwingTools.isRectangleVisibleAtScreen(separateDialog.getBounds()));
        separateDialog.setVisible(true);
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, true);
    }

    /**
     * Attaches the given <code>view</code> to home view.
     */
    public void attachView(View view) {
        this.controller.setVisualProperty(view.getClass().getName() + DETACHED_VIEW_VISUAL_PROPERTY, false);
        JComponent dummyComponent = (JComponent) findChild(this, view.getClass().getName());
        if (dummyComponent != null) {
            JComponent component = (JComponent) view;
            Window window = SwingUtilities.getWindowAncestor(component);
            component.setBorder(dummyComponent.getBorder());
            Container parent = dummyComponent.getParent();
            if (parent instanceof JSplitPane) {
                JSplitPane splitPane = (JSplitPane) parent;
                float dividerLocation = (Float) this.home.getVisualProperty(view.getClass().getName() + DETACHED_VIEW_DIVIDER_LOCATION_VISUAL_PROPERTY);
                splitPane.setDividerSize(UIManager.getInt(""SplitPane.dividerSize""));
                splitPane.setDividerLocation(dividerLocation);
                if (splitPane.getLeftComponent() == dummyComponent) {
                    splitPane.setLeftComponent(component);
                } else {
                    splitPane.setRightComponent(component);
                }
            } else {
                int componentIndex = parent.getComponentZOrder(dummyComponent);
                parent.remove(componentIndex);
                parent.add(component, componentIndex);
            }
            window.dispose();
        }
    }

    /**
     * Returns among <code>parent</code> children the first child with the given name.
     */
    private Component findChild(Container parent, String childName) {
        for (int i = 0; i < parent.getComponentCount(); i++) {
            Component child = parent.getComponent(i);
            if (childName.equals(child.getName())) {
                return child;
            } else if (child instanceof Container) {
                child = findChild((Container) child, childName);
                if (child != null) {
                    return child;
                }
            }
        }
        return null;
    }

    /**
     * Displays a content chooser open dialog to choose the name of a home.
     */
    public String showOpenDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""openHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D);
    }

    /**
     * Displays a content chooser open dialog to choose a language library.
     */
    public String showImportLanguageLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importLanguageLibraryDialog.title""), ContentManager.ContentType.LANGUAGE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing language library or not.
     */
    public boolean confirmReplaceLanguageLibrary(String languageLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.message"", new File(languageLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceLanguageLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a furniture library.
     */
    public String showImportFurnitureLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importFurnitureLibraryDialog.title""), ContentManager.ContentType.FURNITURE_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing furniture library or not.
     */
    public boolean confirmReplaceFurnitureLibrary(String furnitureLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.message"", new File(furnitureLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceFurnitureLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser open dialog to choose a textures library.
     */
    public String showImportTexturesLibraryDialog() {
        return this.controller.getContentManager().showOpenDialog(this, this.preferences.getLocalizedString(HomePane.class, ""importTexturesLibraryDialog.title""), ContentManager.ContentType.TEXTURES_LIBRARY);
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing textures library or not.
     */
    public boolean confirmReplaceTexturesLibrary(String texturesLibraryName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.message"", new File(texturesLibraryName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplaceTexturesLibrary.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets user choose whether he wants to overwrite
     * an existing plug-in or not.
     */
    public boolean confirmReplacePlugin(String pluginName) {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.message"", new File(pluginName).getName());
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.title"");
        String replace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.replace"");
        String doNotReplace = this.preferences.getLocalizedString(HomePane.class, ""confirmReplacePlugin.doNotReplace"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { replace, doNotReplace }, doNotReplace) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a content chooser save dialog to choose the name of a home.
     */
    public String showSaveDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""saveHomeDialog.title""), ContentManager.ContentType.SWEET_HOME_3D, homeName);
    }

    /**
     * Displays <code>message</code> in an error message box.
     */
    public void showError(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""error.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays <code>message</code> in a message box.
     */
    public void showMessage(String message) {
        String title = this.preferences.getLocalizedString(HomePane.class, ""message.title"");
        JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE);
    }

    /**
     * Displays the tip matching <code>actionTipKey</code> and
     * returns <code>true</code> if the user chose not to display again the tip.
     */
    public boolean showActionTipMessage(String actionTipKey) {
        String title = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipTitle"");
        String message = this.preferences.getLocalizedString(HomePane.class, actionTipKey + "".tipMessage"");
        if (message.length() > 0) {
            JPanel tipPanel = new JPanel(new GridBagLayout());
            JLabel messageLabel = new JLabel(message);
            tipPanel.add(messageLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));
            // Add a check box that lets user choose whether he wants to display again the tip or not
            JCheckBox doNotDisplayTipCheckBox = new JCheckBox(SwingTools.getLocalizedLabelText(this.preferences, HomePane.class, ""doNotDisplayTipCheckBox.text""));
            if (!OperatingSystem.isMacOSX()) {
                doNotDisplayTipCheckBox.setMnemonic(KeyStroke.getKeyStroke(this.preferences.getLocalizedString(HomePane.class, ""doNotDisplayTipCheckBox.mnemonic"")).getKeyCode());
            }
            tipPanel.add(doNotDisplayTipCheckBox, new GridBagConstraints(0, 1, 1, 1, 0, 1, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 5, 0), 0, 0));
            SwingTools.showMessageDialog(this, tipPanel, title, JOptionPane.INFORMATION_MESSAGE, doNotDisplayTipCheckBox);
            return doNotDisplayTipCheckBox.isSelected();
        } else {
            // Ignore untranslated tips
            return true;
        }
    }

    /**
     * Displays a dialog that lets user choose whether he wants to save
     * the current home or not.
     * @return {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#SAVE}
     * if the user chose to save home,
     * {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#DO_NOT_SAVE}
     * if he doesn't want to save home,
     * or {@link com.eteks.sweethome3d.viewcontroller.HomeView.SaveAnswer#CANCEL}
     * if he doesn't want to continue current operation.
     */
    public SaveAnswer confirmSave(String homeName) {
        // Retrieve displayed text in buttons and message
        String message;
        if (homeName != null) {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", ""\"""" + this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D) + ""\"""");
        } else {
            message = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.message"", """");
        }
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.doNotSave"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmSave.cancel"");
        switch(JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave, cancel }, save)) {
            // Convert showOptionDialog answer to SaveAnswer enum constants
            case JOptionPane.YES_OPTION:
                return SaveAnswer.SAVE;
            case JOptionPane.NO_OPTION:
                return SaveAnswer.DO_NOT_SAVE;
            default:
                return SaveAnswer.CANCEL;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to save
     * a home that was created with a newer version of Sweet Home 3D.
     * @return <code>true</code> if user confirmed to save.
     */
    public boolean confirmSaveNewerHome(String homeName) {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.message"", this.controller.getContentManager().getPresentationName(homeName, ContentManager.ContentType.SWEET_HOME_3D));
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.title"");
        String save = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.save"");
        String doNotSave = this.preferences.getLocalizedString(HomePane.class, ""confirmSaveNewerHome.doNotSave"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { save, doNotSave }, doNotSave) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays a dialog that let user choose whether he wants to exit
     * application or not.
     * @return <code>true</code> if user confirmed to exit.
     */
    public boolean confirmExit() {
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.title"");
        String quit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.quit"");
        String doNotQuit = this.preferences.getLocalizedString(HomePane.class, ""confirmExit.doNotQuit"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { quit, doNotQuit }, doNotQuit) == JOptionPane.YES_OPTION;
    }

    /**
     * Displays an about dialog.
     */
    public void showAboutDialog() {
        String messageFormat = this.preferences.getLocalizedString(HomePane.class, ""about.message"");
        String aboutVersion = this.controller.getVersion();
        String message = String.format(messageFormat, aboutVersion, System.getProperty(""java.version""));
        // Use an uneditable editor pane to let user select text in dialog
        JEditorPane messagePane = new JEditorPane(""text/html"", message);
        messagePane.setOpaque(false);
        messagePane.setEditable(false);
        // Add a listener that displays hyperlinks content in browser
        messagePane.addHyperlinkListener(new HyperlinkListener() {

            public void hyperlinkUpdate(HyperlinkEvent ev) {
                if (ev.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                    SwingTools.showDocumentInBrowser(ev.getURL());
                }
            }
        });
        String title = this.preferences.getLocalizedString(HomePane.class, ""about.title"");
        Icon icon = new ImageIcon(HomePane.class.getResource(this.preferences.getLocalizedString(HomePane.class, ""about.icon"")));
        JOptionPane.showMessageDialog(this, messagePane, title, JOptionPane.INFORMATION_MESSAGE, icon);
    }

    /**
     * Shows a print dialog to print the home displayed by this pane.
     * @return a print task to execute or <code>null</code> if the user canceled print.
     *    The <code>call</code> method of the returned task may throw a
     *    {@link RecorderException RecorderException} exception if print failed
     *    or an {@link InterruptedRecorderException InterruptedRecorderException}
     *    exception if it was interrupted.
     */
    public Callable<Void> showPrintDialog() {
        PageFormat pageFormat = HomePrintableComponent.getPageFormat(this.home.getPrint());
        final PrinterJob printerJob = PrinterJob.getPrinterJob();
        printerJob.setPrintable(new HomePrintableComponent(this.home, this.controller, getFont()), pageFormat);
        String jobName = this.preferences.getLocalizedString(HomePane.class, ""print.jobName"");
        if (this.home.getName() != null) {
            jobName += "" - "" + this.controller.getContentManager().getPresentationName(this.home.getName(), ContentManager.ContentType.SWEET_HOME_3D);
        }
        printerJob.setJobName(jobName);
        if (printerJob.printDialog()) {
            return new Callable<Void>() {

                public Void call() throws RecorderException {
                    try {
                        printerJob.print();
                        return null;
                    } catch (InterruptedPrinterException ex) {
                        throw new InterruptedRecorderException(""Print interrupted"");
                    } catch (PrinterException ex) {
                        throw new RecorderException(""Couldn't print"", ex);
                    }
                }
            };
        } else {
            return null;
        }
    }

    /**
     * Shows a content chooser save dialog to print a home in a PDF file.
     */
    public String showPrintToPDFDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""printToPDFDialog.title""), ContentManager.ContentType.PDF, homeName);
    }

    /**
     * Prints a home to a given PDF file. This method may be overridden
     * to write to another kind of output stream.
     */
    public void printToPDF(String pdfFile) throws RecorderException {
        OutputStream outputStream = null;
        boolean printInterrupted = false;
        try {
            outputStream = new FileOutputStream(pdfFile);
            new HomePDFPrinter(this.home, this.preferences, this.controller, getFont()).write(outputStream);
        } catch (InterruptedIOException ex) {
            printInterrupted = true;
            throw new InterruptedRecorderException(""Print interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to PDF"", ex);
        } finally {
            try {
                if (outputStream != null) {
                    outputStream.close();
                }
                // Delete the file if printing is interrupted
                if (printInterrupted) {
                    new File(pdfFile).delete();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to PDF"", ex);
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a home plan in a SVG file.
     */
    public String showExportToSVGDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToSVGDialog.title""), ContentManager.ContentType.SVG, homeName);
    }

    /**
     * Exports the plan objects to a given SVG file.
     */
    public void exportToSVG(String svgFile) throws RecorderException {
        View planView = this.controller.getPlanController().getView();
        PlanComponent planComponent;
        if (planView instanceof PlanComponent) {
            planComponent = (PlanComponent) planView;
        } else {
            planComponent = new PlanComponent(this.home, this.preferences, null);
        }
        OutputStream outputStream = null;
        boolean exportInterrupted = false;
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(svgFile));
            planComponent.exportToSVG(outputStream);
        } catch (InterruptedIOException ex) {
            exportInterrupted = true;
            throw new InterruptedRecorderException(""Export to "" + svgFile + "" interrupted"");
        } catch (IOException ex) {
            throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
        } finally {
            if (outputStream != null) {
                try {
                    outputStream.close();
                    // Delete the file if exporting is interrupted
                    if (exportInterrupted) {
                        new File(svgFile).delete();
                    }
                } catch (IOException ex) {
                    throw new RecorderException(""Couldn't export to SVG in "" + svgFile, ex);
                }
            }
        }
    }

    /**
     * Shows a content chooser save dialog to export a 3D home in a OBJ file.
     */
    public String showExportToOBJDialog(String homeName) {
        return this.controller.getContentManager().showSaveDialog(this, this.preferences.getLocalizedString(HomePane.class, ""exportToOBJDialog.title""), ContentManager.ContentType.OBJ, homeName);
    }

    /**
     * Exports the objects of the 3D view to the given OBJ file.
     */
    public void exportToOBJ(String objFile) throws RecorderException {
        String header = this.preferences != null ? this.preferences.getLocalizedString(HomePane.class, ""exportToOBJ.header"", new Date()) : """";
        // Use a clone of home to ignore selection
        OBJExporter.exportHomeToFile(this.home.clone(), objFile, header);
    }

    /**
     * Export to OBJ in a separate class to be able to run HomePane without Java 3D classes.
     */
    private static class OBJExporter {

        public static void exportHomeToFile(Home home, String objFile, String header) throws RecorderException {
            OBJWriter writer = null;
            boolean exportInterrupted = false;
            try {
                writer = new OBJWriter(objFile, header, -1);
                List<Selectable> emptySelection = Collections.emptyList();
                home.setSelectedItems(emptySelection);
                if (home.getWalls().size() > 0) {
                    // Create a not alive new ground to be able to explore its coordinates without setting capabilities
                    Rectangle2D homeBounds = getExportedHomeBounds(home);
                    Ground3D groundNode = new Ground3D(home, (float) homeBounds.getX(), (float) homeBounds.getY(), (float) homeBounds.getWidth(), (float) homeBounds.getHeight(), true);
                    writer.writeNode(groundNode, ""ground"");
                }
                // Write 3D walls
                int i = 0;
                for (Wall wall : home.getWalls()) {
                    // Create a not alive new wall to be able to explore its coordinates without setting capabilities
                    Wall3D wallNode = new Wall3D(wall, home, true, true);
                    writer.writeNode(wallNode, ""wall_"" + ++i);
                }
                // Write 3D furniture
                i = 0;
                for (HomePieceOfFurniture piece : home.getFurniture()) {
                    if (piece.isVisible()) {
                        // Create a not alive new piece to be able to explore its coordinates without setting capabilities
                        HomePieceOfFurniture3D pieceNode = new HomePieceOfFurniture3D(piece, home, true, true);
                        writer.writeNode(pieceNode);
                    }
                }
                // Write 3D rooms
                i = 0;
                for (Room room : home.getRooms()) {
                    // Create a not alive new room to be able to explore its coordinates without setting capabilities
                    Room3D roomNode = new Room3D(room, home, false, true, true);
                    writer.writeNode(roomNode, ""room_"" + ++i);
                }
            } catch (InterruptedIOException ex) {
                exportInterrupted = true;
                throw new InterruptedRecorderException(""Export to "" + objFile + "" interrupted"");
            } catch (IOException ex) {
                throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                        // Delete the file if exporting is interrupted
                        if (exportInterrupted) {
                            new File(objFile).delete();
                        }
                    } catch (IOException ex) {
                        throw new RecorderException(""Couldn't export to OBJ in "" + objFile, ex);
                    }
                }
            }
        }

        /**
         * Returns <code>home</code> bounds.
         */
        private static Rectangle2D getExportedHomeBounds(Home home) {
            // Compute bounds that include walls and furniture
            Rectangle2D homeBounds = updateObjectsBounds(null, home.getWalls());
            for (HomePieceOfFurniture piece : getVisibleFurniture(home.getFurniture())) {
                for (float[] point : piece.getPoints()) {
                    if (homeBounds == null) {
                        homeBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                    } else {
                        homeBounds.add(point[0], point[1]);
                    }
                }
            }
            return updateObjectsBounds(homeBounds, home.getRooms());
        }

        /**
         * Returns all the visible pieces in the given <code>furniture</code>.
         */
        private static List<HomePieceOfFurniture> getVisibleFurniture(List<HomePieceOfFurniture> furniture) {
            List<HomePieceOfFurniture> visibleFurniture = new ArrayList<HomePieceOfFurniture>(furniture.size());
            for (HomePieceOfFurniture piece : furniture) {
                if (piece.isVisible() && (piece.getLevel() == null || piece.getLevel().isVisible())) {
                    if (piece instanceof HomeFurnitureGroup) {
                        visibleFurniture.addAll(getVisibleFurniture(((HomeFurnitureGroup) piece).getFurniture()));
                    } else {
                        visibleFurniture.add(piece);
                    }
                }
            }
            return visibleFurniture;
        }

        /**
         * Updates <code>objectBounds</code> to include the bounds of <code>items</code>.
         */
        private static Rectangle2D updateObjectsBounds(Rectangle2D objectBounds, Collection<? extends Selectable> items) {
            for (Selectable item : items) {
                if (!(item instanceof Elevatable) || ((Elevatable) item).getLevel() == null || ((Elevatable) item).getLevel().isVisible()) {
                    for (float[] point : item.getPoints()) {
                        if (objectBounds == null) {
                            objectBounds = new Rectangle2D.Float(point[0], point[1], 0, 0);
                        } else {
                            objectBounds.add(point[0], point[1]);
                        }
                    }
                }
            }
            return objectBounds;
        }
    }

    /**
     * Displays a dialog that let user choose whether he wants to delete
     * the selected furniture from catalog or not.
     * @return <code>true</code> if user confirmed to delete.
     */
    public boolean confirmDeleteCatalogSelection() {
        // Retrieve displayed text in buttons and message
        String message = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.title"");
        String delete = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.delete"");
        String cancel = this.preferences.getLocalizedString(HomePane.class, ""confirmDeleteCatalogSelection.cancel"");
        return JOptionPane.showOptionDialog(this, message, title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, new Object[] { delete, cancel }, cancel) == JOptionPane.OK_OPTION;
    }

    /**
     * Displays a dialog that lets the user choose a name for the current camera.
     * @return the chosen name or <code>null</code> if the user canceled.
     */
    public String showStoreCameraDialog(String cameraName) {
        // Retrieve displayed text in dialog
        String message = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.message"");
        String title = this.preferences.getLocalizedString(HomePane.class, ""showStoreCameraDialog.title"");
        List<Camera> storedCameras = this.home.getStoredCameras();
        JComponent cameraNameChooser;
        JTextComponent cameraNameTextComponent;
        if (storedCameras.isEmpty()) {
            cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
        } else {
            // If cameras are already stored in home propose an editable combo box to user
            // to let him choose more easily an existing one if he want to overwrite it
            String[] storedCameraNames = new String[storedCameras.size()];
            for (int i = 0; i < storedCameraNames.length; i++) {
                storedCameraNames[i] = storedCameras.get(i).getName();
            }
            JComboBox cameraNameComboBox = new JComboBox(storedCameraNames);
            cameraNameComboBox.setEditable(true);
            cameraNameComboBox.getEditor().setItem(cameraName);
            Component editorComponent = cameraNameComboBox.getEditor().getEditorComponent();
            if (editorComponent instanceof JTextComponent) {
                cameraNameTextComponent = (JTextComponent) editorComponent;
                cameraNameChooser = cameraNameComboBox;
            } else {
                cameraNameChooser = cameraNameTextComponent = new JTextField(cameraName, 20);
            }
        }
        JPanel cameraNamePanel = new JPanel(new BorderLayout(2, 2));
        cameraNamePanel.add(new JLabel(message), BorderLayout.NORTH);
        cameraNamePanel.add(cameraNameChooser, BorderLayout.SOUTH);
        if (SwingTools.showConfirmDialog(this, cameraNamePanel, title, cameraNameTextComponent) == JOptionPane.OK_OPTION) {
            return cameraNameTextComponent.getText();
        } else {
            return null;
        }
    }

    /**
     * Returns <code>true</code> if clipboard contains data that
     * components are able to handle.
     */
    public boolean isClipboardEmpty() {
        try {
            Clipboard clipboard = getToolkit().getSystemClipboard();
            return !(clipboard.isDataFlavorAvailable(HomeTransferableList.HOME_FLAVOR) || getToolkit().getSystemClipboard().isDataFlavorAvailable(DataFlavor.javaFileListFlavor));
        } catch (AccessControlException ex) {
            // AWT uses a private clipboard that won't be empty as soon as a copy action will be done
            return this.clipboardEmpty;
        }
    }

    /**
     * Execute <code>runnable</code> asynchronously in the thread
     * that manages toolkit events.
     */
    public void invokeLater(Runnable runnable) {
        EventQueue.invokeLater(runnable);
    }

    /**
     * A Swing action adapter to a plug-in action.
     */
    private class ActionAdapter implements Action {

        private PluginAction pluginAction;

        private SwingPropertyChangeSupport propertyChangeSupport;

        private ActionAdapter(PluginAction pluginAction) {
            this.pluginAction = pluginAction;
            this.propertyChangeSupport = new SwingPropertyChangeSupport(this);
            this.pluginAction.addPropertyChangeListener(new PropertyChangeListener() {

                public void propertyChange(PropertyChangeEvent ev) {
                    String propertyName = ev.getPropertyName();
                    Object oldValue = ev.getOldValue();
                    Object newValue = ev.getNewValue();
                    if (PluginAction.Property.ENABLED.name().equals(propertyName)) {
                        propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), ""enabled"", oldValue, newValue));
                    } else {
                        // In case a property value changes, fire the new value decorated in subclasses
                        // unless new value is null (most Swing listeners don't check new value is null !)
                        if (newValue != null) {
                            if (PluginAction.Property.NAME.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.NAME, oldValue, newValue));
                            } else if (PluginAction.Property.SHORT_DESCRIPTION.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SHORT_DESCRIPTION, oldValue, newValue));
                            } else if (PluginAction.Property.MNEMONIC.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.MNEMONIC_KEY, oldValue != null ? new Integer((Character) oldValue) : null, newValue));
                            } else if (PluginAction.Property.SMALL_ICON.name().equals(propertyName)) {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), Action.SMALL_ICON, oldValue != null ? IconManager.getInstance().getIcon((Content) oldValue, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null, newValue));
                            } else {
                                propertyChangeSupport.firePropertyChange(new PropertyChangeEvent(ev.getSource(), propertyName, oldValue, newValue));
                            }
                        }
                    }
                }
            });
        }

        public void actionPerformed(ActionEvent ev) {
            this.pluginAction.execute();
        }

        public void addPropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.addPropertyChangeListener(listener);
        }

        public void removePropertyChangeListener(PropertyChangeListener listener) {
            this.propertyChangeSupport.removePropertyChangeListener(listener);
        }

        public Object getValue(String key) {
            if (NAME.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.NAME);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.SHORT_DESCRIPTION);
            } else if (SMALL_ICON.equals(key)) {
                Content smallIcon = (Content) this.pluginAction.getPropertyValue(PluginAction.Property.SMALL_ICON);
                return smallIcon != null ? IconManager.getInstance().getIcon(smallIcon, DEFAULT_SMALL_ICON_HEIGHT, HomePane.this) : null;
            } else if (MNEMONIC_KEY.equals(key)) {
                Character mnemonic = (Character) this.pluginAction.getPropertyValue(PluginAction.Property.MNEMONIC);
                return mnemonic != null ? new Integer(mnemonic) : null;
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.TOOL_BAR);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                return this.pluginAction.getPropertyValue(PluginAction.Property.MENU);
            } else {
                return null;
            }
        }

        public void putValue(String key, Object value) {
            if (NAME.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.NAME, value);
            } else if (SHORT_DESCRIPTION.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.SHORT_DESCRIPTION, value);
            } else if (SMALL_ICON.equals(key)) {
                // Ignore icon change
            } else if (MNEMONIC_KEY.equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MNEMONIC, new Character((char) ((Integer) value).intValue()));
            } else if (PluginAction.Property.TOOL_BAR.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.TOOL_BAR, value);
            } else if (PluginAction.Property.MENU.name().equals(key)) {
                this.pluginAction.putPropertyValue(PluginAction.Property.MENU, value);
            }
        }

        public boolean isEnabled() {
            return this.pluginAction.isEnabled();
        }

        public void setEnabled(boolean enabled) {
            this.pluginAction.setEnabled(enabled);
        }
    }

    /**
     * An object able to format a selectable item.
     */
    private abstract interface SelectableFormat<T extends Selectable> {

        public abstract String format(T item);
    }
}
","// HomePane_17Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#confirmDeleteCatalogSelection()} method.
*/
class HomePane_17Test {","// HomePane_17Test.java
package com.eteks.sweethome3d.swing;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.FocusTraversalPolicy;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DragSource;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.geom.Rectangle2D;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.lang.ref.WeakReference;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.Box;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.JViewport;
import javax.swing.KeyStroke;
import javax.swing.LayoutFocusTraversalPolicy;
import javax.swing.Scrollable;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.TransferHandler;
import javax.swing.UIManager;
import javax.swing.event.AncestorEvent;
import javax.swing.event.AncestorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.MenuEvent;
import javax.swing.event.MenuListener;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.event.SwingPropertyChangeSupport;
import javax.swing.text.JTextComponent;
import com.eteks.sweethome3d.j3d.Ground3D;
import com.eteks.sweethome3d.j3d.HomePieceOfFurniture3D;
import com.eteks.sweethome3d.j3d.OBJWriter;
import com.eteks.sweethome3d.j3d.Room3D;
import com.eteks.sweethome3d.j3d.Wall3D;
import com.eteks.sweethome3d.model.BackgroundImage;
import com.eteks.sweethome3d.model.Camera;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CollectionEvent;
import com.eteks.sweethome3d.model.CollectionListener;
import com.eteks.sweethome3d.model.Compass;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.DimensionLine;
import com.eteks.sweethome3d.model.Elevatable;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.model.HomeEnvironment;
import com.eteks.sweethome3d.model.HomeFurnitureGroup;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.model.InterruptedRecorderException;
import com.eteks.sweethome3d.model.Label;
import com.eteks.sweethome3d.model.Level;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Room;
import com.eteks.sweethome3d.model.Selectable;
import com.eteks.sweethome3d.model.SelectionEvent;
import com.eteks.sweethome3d.model.SelectionListener;
import com.eteks.sweethome3d.model.TextStyle;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.model.Wall;
import com.eteks.sweethome3d.plugin.HomePluginController;
import com.eteks.sweethome3d.plugin.Plugin;
import com.eteks.sweethome3d.plugin.PluginAction;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.viewcontroller.ContentManager;
import com.eteks.sweethome3d.viewcontroller.FurnitureController;
import com.eteks.sweethome3d.viewcontroller.HomeController;
import com.eteks.sweethome3d.viewcontroller.HomeController3D;
import com.eteks.sweethome3d.viewcontroller.HomeView;
import com.eteks.sweethome3d.viewcontroller.PlanController;
import com.eteks.sweethome3d.viewcontroller.PlanController.Mode;
import com.eteks.sweethome3d.viewcontroller.PlanView;
import com.eteks.sweethome3d.viewcontroller.View;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HomePane}.
* It contains one unit test case for the {@link HomePane#confirmDeleteCatalogSelection()} method.
*/
class HomePane_17Test {
"
c937e20f-c4d2-42c0-b91d-7ec381a55010,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/IconManager_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// IconManager.java
/*
 * IconManager.java 2 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;

/**
 * Singleton managing icons cache.
 * @author Emmanuel Puybaret
 */
public class IconManager {

    private static IconManager instance;

    // Icon used if an image content couldn't be loaded
    private final Content errorIconContent;

    // Icon used while an image content is loaded
    private final Content waitIconContent;

    // Map storing loaded icons
    private final Map<Content, Map<Integer, Icon>> icons;

    // Executor used by IconProxy to load images
    private ExecutorService iconsLoader;

    private IconManager() {
        this.errorIconContent = new ResourceURLContent(IconManager.class, ""resources/icons/tango/image-missing.png"");
        this.waitIconContent = new ResourceURLContent(IconManager.class, ""resources/icons/tango/image-loading.png"");
        this.icons = Collections.synchronizedMap(new WeakHashMap<Content, Map<Integer, Icon>>());
    }

    /**
     * Returns an instance of this singleton.
     */
    public static IconManager getInstance() {
        if (instance == null) {
            instance = new IconManager();
        }
        return instance;
    }

    /**
     * Clears the loaded resources cache and shutdowns the multithreaded service
     * that loads icons.
     */
    public void clear() {
        if (this.iconsLoader != null) {
            this.iconsLoader.shutdownNow();
            this.iconsLoader = null;
        }
        this.icons.clear();
    }

    /**
     * Returns the icon displayed for wrong content resized at a given height.
     */
    public Icon getErrorIcon(int height) {
        return getIcon(this.errorIconContent, height, null);
    }

    /**
     * Returns the icon displayed for wrong content.
     */
    public Icon getErrorIcon() {
        return getIcon(this.errorIconContent, -1, null);
    }

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the error icon
     * used by this manager to indicate it couldn't load an icon.
     */
    public boolean isErrorIcon(Icon icon) {
        Map<Integer, Icon> errorIcons = this.icons.get(this.errorIconContent);
        return errorIcons != null && (errorIcons.containsValue(icon) || icon instanceof IconProxy && errorIcons.containsValue(((IconProxy) icon).getIcon()));
    }

    /**
     * Returns the icon displayed while a content is loaded resized at a given height.
     */
    public Icon getWaitIcon(int height) {
        return getIcon(this.waitIconContent, height, null);
    }

    /**
     * Returns the icon displayed while a content is loaded.
     */
    public Icon getWaitIcon() {
        return getIcon(this.waitIconContent, -1, null);
    }

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the wait icon
     * used by this manager to indicate it's currently loading an icon.
     */
    public boolean isWaitIcon(Icon icon) {
        Map<Integer, Icon> waitIcons = this.icons.get(this.waitIconContent);
        return waitIcons != null && (waitIcons.containsValue(icon) || icon instanceof IconProxy && waitIcons.containsValue(((IconProxy) icon).getIcon()));
    }

    /**
     * Returns an icon read from <code>content</code>.
     * @param content an object containing an image
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, Component waitingComponent) {
        return getIcon(content, -1, waitingComponent);
    }

    /**
     * Returns an icon read from <code>content</code> and rescaled at a given <code>height</code>.
     * @param content an object containing an image
     * @param height  the desired height of the returned icon
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, final int height, Component waitingComponent) {
        Map<Integer, Icon> contentIcons = this.icons.get(content);
        if (contentIcons == null) {
            contentIcons = Collections.synchronizedMap(new HashMap<Integer, Icon>());
            this.icons.put(content, contentIcons);
        }
        Icon icon = contentIcons.get(height);
        if (icon == null) {
            // Tolerate null content
            if (content == null) {
                icon = new Icon() {

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                    }

                    public int getIconWidth() {
                        return Math.max(0, height);
                    }

                    public int getIconHeight() {
                        return Math.max(0, height);
                    }
                };
            } else if (content == this.errorIconContent || content == this.waitIconContent) {
                // Load error and wait icons immediately in this thread
                icon = createIcon(content, height, null);
            } else if (waitingComponent == null) {
                // Load icon immediately in this thread
                icon = createIcon(content, height, getIcon(this.errorIconContent, height, null));
            } else {
                // For content different from error icon and wait icon,
                // load it in a different thread with a virtual proxy
                icon = new IconProxy(content, height, waitingComponent, getIcon(this.errorIconContent, height, null), getIcon(this.waitIconContent, height, null));
            }
            // Store the icon in icons map
            contentIcons.put(height, icon);
        }
        return icon;
    }

    /**
     * Returns an icon created and scaled from its content.
     * @param content the content from which the icon image is read
     * @param height  the desired height of the returned icon
     * @param errorIcon the returned icon in case of error
     */
    private Icon createIcon(Content content, int height, Icon errorIcon) {
        try {
            // Read the icon of the piece
            InputStream contentStream = content.openStream();
            BufferedImage image = ImageIO.read(contentStream);
            contentStream.close();
            if (image != null) {
                if (height != -1 && height != image.getHeight()) {
                    int width = image.getWidth() * height / image.getHeight();
                    // Create a scaled image not bound to original image to let the original image being garbage collected
                    BufferedImage scaledImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
                    Graphics g = scaledImage.getGraphics();
                    g.drawImage(image.getScaledInstance(width, height, Image.SCALE_SMOOTH), 0, 0, null);
                    g.dispose();
                    return new ImageIcon(scaledImage);
                } else {
                    return new ImageIcon(image);
                }
            }
        } catch (IOException ex) {
            // Too bad, we'll use errorIcon
        }
        return errorIcon;
    }

    /**
     * Proxy icon that displays a temporary icon while waiting
     * image loading completion.
     */
    private class IconProxy implements Icon {

        private Icon icon;

        public IconProxy(final Content content, final int height, final Component waitingComponent, final Icon errorIcon, Icon waitIcon) {
            this.icon = waitIcon;
            if (iconsLoader == null) {
                iconsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
            }
            // Load the icon in a different thread
            iconsLoader.execute(new Runnable() {

                public void run() {
                    icon = createIcon(content, height, errorIcon);
                    waitingComponent.repaint();
                }
            });
        }

        public int getIconWidth() {
            return this.icon.getIconWidth();
        }

        public int getIconHeight() {
            return this.icon.getIconHeight();
        }

        public void paintIcon(Component c, Graphics g, int x, int y) {
            this.icon.paintIcon(c, g, x, y);
        }

        public Icon getIcon() {
            return this.icon;
        }
    }
}
","// IconManager_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains one unit test case for the {@link IconManager#getInstance()} method.
*/
class IconManager_0Test {","// IconManager_0Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains one unit test case for the {@link IconManager#getInstance()} method.
*/
class IconManager_0Test {
"
c4c3742a-c699-4a4a-bf2b-80d015fada06,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/IconManager_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// IconManager.java
/*
 * IconManager.java 2 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;

/**
 * Singleton managing icons cache.
 * @author Emmanuel Puybaret
 */
public class IconManager {

    private static IconManager instance;

    // Icon used if an image content couldn't be loaded
    private final Content errorIconContent;

    // Icon used while an image content is loaded
    private final Content waitIconContent;

    // Map storing loaded icons
    private final Map<Content, Map<Integer, Icon>> icons;

    // Executor used by IconProxy to load images
    private ExecutorService iconsLoader;

    private IconManager() {
        this.errorIconContent = new ResourceURLContent(IconManager.class, ""resources/icons/tango/image-missing.png"");
        this.waitIconContent = new ResourceURLContent(IconManager.class, ""resources/icons/tango/image-loading.png"");
        this.icons = Collections.synchronizedMap(new WeakHashMap<Content, Map<Integer, Icon>>());
    }

    /**
     * Returns an instance of this singleton.
     */
    public static IconManager getInstance() {
        if (instance == null) {
            instance = new IconManager();
        }
        return instance;
    }

    /**
     * Clears the loaded resources cache and shutdowns the multithreaded service
     * that loads icons.
     */
    public void clear() {
        if (this.iconsLoader != null) {
            this.iconsLoader.shutdownNow();
            this.iconsLoader = null;
        }
        this.icons.clear();
    }

    /**
     * Returns the icon displayed for wrong content resized at a given height.
     */
    public Icon getErrorIcon(int height) {
        return getIcon(this.errorIconContent, height, null);
    }

    /**
     * Returns the icon displayed for wrong content.
     */
    public Icon getErrorIcon() {
        return getIcon(this.errorIconContent, -1, null);
    }

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the error icon
     * used by this manager to indicate it couldn't load an icon.
     */
    public boolean isErrorIcon(Icon icon) {
        Map<Integer, Icon> errorIcons = this.icons.get(this.errorIconContent);
        return errorIcons != null && (errorIcons.containsValue(icon) || icon instanceof IconProxy && errorIcons.containsValue(((IconProxy) icon).getIcon()));
    }

    /**
     * Returns the icon displayed while a content is loaded resized at a given height.
     */
    public Icon getWaitIcon(int height) {
        return getIcon(this.waitIconContent, height, null);
    }

    /**
     * Returns the icon displayed while a content is loaded.
     */
    public Icon getWaitIcon() {
        return getIcon(this.waitIconContent, -1, null);
    }

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the wait icon
     * used by this manager to indicate it's currently loading an icon.
     */
    public boolean isWaitIcon(Icon icon) {
        Map<Integer, Icon> waitIcons = this.icons.get(this.waitIconContent);
        return waitIcons != null && (waitIcons.containsValue(icon) || icon instanceof IconProxy && waitIcons.containsValue(((IconProxy) icon).getIcon()));
    }

    /**
     * Returns an icon read from <code>content</code>.
     * @param content an object containing an image
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, Component waitingComponent) {
        return getIcon(content, -1, waitingComponent);
    }

    /**
     * Returns an icon read from <code>content</code> and rescaled at a given <code>height</code>.
     * @param content an object containing an image
     * @param height  the desired height of the returned icon
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, final int height, Component waitingComponent) {
        Map<Integer, Icon> contentIcons = this.icons.get(content);
        if (contentIcons == null) {
            contentIcons = Collections.synchronizedMap(new HashMap<Integer, Icon>());
            this.icons.put(content, contentIcons);
        }
        Icon icon = contentIcons.get(height);
        if (icon == null) {
            // Tolerate null content
            if (content == null) {
                icon = new Icon() {

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                    }

                    public int getIconWidth() {
                        return Math.max(0, height);
                    }

                    public int getIconHeight() {
                        return Math.max(0, height);
                    }
                };
            } else if (content == this.errorIconContent || content == this.waitIconContent) {
                // Load error and wait icons immediately in this thread
                icon = createIcon(content, height, null);
            } else if (waitingComponent == null) {
                // Load icon immediately in this thread
                icon = createIcon(content, height, getIcon(this.errorIconContent, height, null));
            } else {
                // For content different from error icon and wait icon,
                // load it in a different thread with a virtual proxy
                icon = new IconProxy(content, height, waitingComponent, getIcon(this.errorIconContent, height, null), getIcon(this.waitIconContent, height, null));
            }
            // Store the icon in icons map
            contentIcons.put(height, icon);
        }
        return icon;
    }

    /**
     * Returns an icon created and scaled from its content.
     * @param content the content from which the icon image is read
     * @param height  the desired height of the returned icon
     * @param errorIcon the returned icon in case of error
     */
    private Icon createIcon(Content content, int height, Icon errorIcon) {
        try {
            // Read the icon of the piece
            InputStream contentStream = content.openStream();
            BufferedImage image = ImageIO.read(contentStream);
            contentStream.close();
            if (image != null) {
                if (height != -1 && height != image.getHeight()) {
                    int width = image.getWidth() * height / image.getHeight();
                    // Create a scaled image not bound to original image to let the original image being garbage collected
                    BufferedImage scaledImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
                    Graphics g = scaledImage.getGraphics();
                    g.drawImage(image.getScaledInstance(width, height, Image.SCALE_SMOOTH), 0, 0, null);
                    g.dispose();
                    return new ImageIcon(scaledImage);
                } else {
                    return new ImageIcon(image);
                }
            }
        } catch (IOException ex) {
            // Too bad, we'll use errorIcon
        }
        return errorIcon;
    }

    /**
     * Proxy icon that displays a temporary icon while waiting
     * image loading completion.
     */
    private class IconProxy implements Icon {

        private Icon icon;

        public IconProxy(final Content content, final int height, final Component waitingComponent, final Icon errorIcon, Icon waitIcon) {
            this.icon = waitIcon;
            if (iconsLoader == null) {
                iconsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
            }
            // Load the icon in a different thread
            iconsLoader.execute(new Runnable() {

                public void run() {
                    icon = createIcon(content, height, errorIcon);
                    waitingComponent.repaint();
                }
            });
        }

        public int getIconWidth() {
            return this.icon.getIconWidth();
        }

        public int getIconHeight() {
            return this.icon.getIconHeight();
        }

        public void paintIcon(Component c, Graphics g, int x, int y) {
            this.icon.paintIcon(c, g, x, y);
        }

        public Icon getIcon() {
            return this.icon;
        }
    }
}
","// IconManager_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains one unit test case for the {@link IconManager#getIcon(Content, Component)} method.
*/
class IconManager_5Test {","// IconManager_5Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains one unit test case for the {@link IconManager#getIcon(Content, Component)} method.
*/
class IconManager_5Test {
"
63f82505-a80c-49d0-b8a4-759e90ad8990,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/swing/IconManager_6Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// IconManager.java
/*
 * IconManager.java 2 mai 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;

/**
 * Singleton managing icons cache.
 * @author Emmanuel Puybaret
 */
public class IconManager {

    private static IconManager instance;

    // Icon used if an image content couldn't be loaded
    private final Content errorIconContent;

    // Icon used while an image content is loaded
    private final Content waitIconContent;

    // Map storing loaded icons
    private final Map<Content, Map<Integer, Icon>> icons;

    // Executor used by IconProxy to load images
    private ExecutorService iconsLoader;

    private IconManager() {
        this.errorIconContent = new ResourceURLContent(IconManager.class, ""resources/icons/tango/image-missing.png"");
        this.waitIconContent = new ResourceURLContent(IconManager.class, ""resources/icons/tango/image-loading.png"");
        this.icons = Collections.synchronizedMap(new WeakHashMap<Content, Map<Integer, Icon>>());
    }

    /**
     * Returns an instance of this singleton.
     */
    public static IconManager getInstance() {
        if (instance == null) {
            instance = new IconManager();
        }
        return instance;
    }

    /**
     * Clears the loaded resources cache and shutdowns the multithreaded service
     * that loads icons.
     */
    public void clear() {
        if (this.iconsLoader != null) {
            this.iconsLoader.shutdownNow();
            this.iconsLoader = null;
        }
        this.icons.clear();
    }

    /**
     * Returns the icon displayed for wrong content resized at a given height.
     */
    public Icon getErrorIcon(int height) {
        return getIcon(this.errorIconContent, height, null);
    }

    /**
     * Returns the icon displayed for wrong content.
     */
    public Icon getErrorIcon() {
        return getIcon(this.errorIconContent, -1, null);
    }

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the error icon
     * used by this manager to indicate it couldn't load an icon.
     */
    public boolean isErrorIcon(Icon icon) {
        Map<Integer, Icon> errorIcons = this.icons.get(this.errorIconContent);
        return errorIcons != null && (errorIcons.containsValue(icon) || icon instanceof IconProxy && errorIcons.containsValue(((IconProxy) icon).getIcon()));
    }

    /**
     * Returns the icon displayed while a content is loaded resized at a given height.
     */
    public Icon getWaitIcon(int height) {
        return getIcon(this.waitIconContent, height, null);
    }

    /**
     * Returns the icon displayed while a content is loaded.
     */
    public Icon getWaitIcon() {
        return getIcon(this.waitIconContent, -1, null);
    }

    /**
     * Returns <code>true</code> if the given <code>icon</code> is the wait icon
     * used by this manager to indicate it's currently loading an icon.
     */
    public boolean isWaitIcon(Icon icon) {
        Map<Integer, Icon> waitIcons = this.icons.get(this.waitIconContent);
        return waitIcons != null && (waitIcons.containsValue(icon) || icon instanceof IconProxy && waitIcons.containsValue(((IconProxy) icon).getIcon()));
    }

    /**
     * Returns an icon read from <code>content</code>.
     * @param content an object containing an image
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, Component waitingComponent) {
        return getIcon(content, -1, waitingComponent);
    }

    /**
     * Returns an icon read from <code>content</code> and rescaled at a given <code>height</code>.
     * @param content an object containing an image
     * @param height  the desired height of the returned icon
     * @param waitingComponent a waiting component. If <code>null</code>, the returned icon will
     *            be read immediately in the current thread.
     */
    public Icon getIcon(Content content, final int height, Component waitingComponent) {
        Map<Integer, Icon> contentIcons = this.icons.get(content);
        if (contentIcons == null) {
            contentIcons = Collections.synchronizedMap(new HashMap<Integer, Icon>());
            this.icons.put(content, contentIcons);
        }
        Icon icon = contentIcons.get(height);
        if (icon == null) {
            // Tolerate null content
            if (content == null) {
                icon = new Icon() {

                    public void paintIcon(Component c, Graphics g, int x, int y) {
                    }

                    public int getIconWidth() {
                        return Math.max(0, height);
                    }

                    public int getIconHeight() {
                        return Math.max(0, height);
                    }
                };
            } else if (content == this.errorIconContent || content == this.waitIconContent) {
                // Load error and wait icons immediately in this thread
                icon = createIcon(content, height, null);
            } else if (waitingComponent == null) {
                // Load icon immediately in this thread
                icon = createIcon(content, height, getIcon(this.errorIconContent, height, null));
            } else {
                // For content different from error icon and wait icon,
                // load it in a different thread with a virtual proxy
                icon = new IconProxy(content, height, waitingComponent, getIcon(this.errorIconContent, height, null), getIcon(this.waitIconContent, height, null));
            }
            // Store the icon in icons map
            contentIcons.put(height, icon);
        }
        return icon;
    }

    /**
     * Returns an icon created and scaled from its content.
     * @param content the content from which the icon image is read
     * @param height  the desired height of the returned icon
     * @param errorIcon the returned icon in case of error
     */
    private Icon createIcon(Content content, int height, Icon errorIcon) {
        try {
            // Read the icon of the piece
            InputStream contentStream = content.openStream();
            BufferedImage image = ImageIO.read(contentStream);
            contentStream.close();
            if (image != null) {
                if (height != -1 && height != image.getHeight()) {
                    int width = image.getWidth() * height / image.getHeight();
                    // Create a scaled image not bound to original image to let the original image being garbage collected
                    BufferedImage scaledImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
                    Graphics g = scaledImage.getGraphics();
                    g.drawImage(image.getScaledInstance(width, height, Image.SCALE_SMOOTH), 0, 0, null);
                    g.dispose();
                    return new ImageIcon(scaledImage);
                } else {
                    return new ImageIcon(image);
                }
            }
        } catch (IOException ex) {
            // Too bad, we'll use errorIcon
        }
        return errorIcon;
    }

    /**
     * Proxy icon that displays a temporary icon while waiting
     * image loading completion.
     */
    private class IconProxy implements Icon {

        private Icon icon;

        public IconProxy(final Content content, final int height, final Component waitingComponent, final Icon errorIcon, Icon waitIcon) {
            this.icon = waitIcon;
            if (iconsLoader == null) {
                iconsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);
            }
            // Load the icon in a different thread
            iconsLoader.execute(new Runnable() {

                public void run() {
                    icon = createIcon(content, height, errorIcon);
                    waitingComponent.repaint();
                }
            });
        }

        public int getIconWidth() {
            return this.icon.getIconWidth();
        }

        public int getIconHeight() {
            return this.icon.getIconHeight();
        }

        public void paintIcon(Component c, Graphics g, int x, int y) {
            this.icon.paintIcon(c, g, x, y);
        }

        public Icon getIcon() {
            return this.icon;
        }
    }
}
","// IconManager_6Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains one unit test case for the {@link IconManager#getIcon(Content, int, Component)} method.
*/
class IconManager_6Test {","// IconManager_6Test.java
package com.eteks.sweethome3d.swing;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.ResourceURLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IconManager}.
* It contains one unit test case for the {@link IconManager#getIcon(Content, int, Component)} method.
*/
class IconManager_6Test {
"
49729a0f-a859-4709-94cc-aecba87afc52,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/io/DefaultHomeInputStream.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DefaultHomeInputStream.java
/*
 * DefaultHomeInputStream.java 13 Oct 2008
 *
 * Sweet Home 3D, Copyright (c) 2008 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.URLContent;

/**
 * An <code>InputStream</code> filter that reads a home from a stream
 * at .sh3d file format.
 * @see DefaultHomeOutputStream
 */
public class DefaultHomeInputStream extends FilterInputStream {

    private final ContentRecording contentRecording;

    private File tempFile;

    /**
     * Creates a home input stream filter able to read a home and its content
     * from <code>in</code>.
     */
    public DefaultHomeInputStream(InputStream in) throws IOException {
        this(in, ContentRecording.INCLUDE_ALL_CONTENT);
    }

    /**
     * Creates a home input stream filter able to read a home and its content
     * from <code>in</code>.
     */
    public DefaultHomeInputStream(InputStream in, ContentRecording contentRecording) throws IOException {
        super(in);
        this.contentRecording = contentRecording;
    }

    /**
     * Throws an <code>InterruptedRecorderException</code> exception
     * if current thread is interrupted. The interrupted status of the current thread
     * is cleared when an exception is thrown.
     */
    private static void checkCurrentThreadIsntInterrupted() throws InterruptedIOException {
        if (Thread.interrupted()) {
            throw new InterruptedIOException();
        }
    }

    /**
     * Reads home from a zipped stream.
     */
    public Home readHome() throws IOException, ClassNotFoundException {
        if (this.contentRecording != ContentRecording.INCLUDE_NO_CONTENT) {
            // Copy home stream in a temporary file
            this.tempFile = OperatingSystem.createTemporaryFile(""open"", "".sweethome3d"");
            checkCurrentThreadIsntInterrupted();
            OutputStream tempOut = null;
            try {
                tempOut = new FileOutputStream(this.tempFile);
                byte[] buffer = new byte[8192];
                int size;
                while ((size = this.in.read(buffer)) != -1) {
                    tempOut.write(buffer, 0, size);
                }
            } finally {
                if (tempOut != null) {
                    tempOut.close();
                }
            }
        }
        ZipInputStream zipIn = null;
        try {
            // Open a zip input from temp file
            zipIn = new ZipInputStream(this.contentRecording == ContentRecording.INCLUDE_NO_CONTENT ? this.in : new FileInputStream(this.tempFile));
            // Read Home entry
            ZipEntry entry;
            while ((entry = zipIn.getNextEntry()) != null && !""Home"".equals(entry.getName())) {
            }
            if (entry == null) {
                throw new IOException(""Missing entry \""Home\"""");
            }
            checkCurrentThreadIsntInterrupted();
            // Use an ObjectInputStream that replaces temporary URLs of Content objects
            // by URLs relative to file
            ObjectInputStream objectStream = new HomeObjectInputStream(zipIn);
            return (Home) objectStream.readObject();
        } finally {
            if (zipIn != null) {
                zipIn.close();
            }
        }
    }

    /**
     * <code>ObjectInputStream</code> that replaces temporary <code>URLContent</code>
     * objects by <code>URLContent</code> objects that points to file.
     */
    private class HomeObjectInputStream extends ObjectInputStream {

        public HomeObjectInputStream(InputStream in) throws IOException {
            super(in);
            if (contentRecording != ContentRecording.INCLUDE_NO_CONTENT) {
                enableResolveObject(true);
            }
        }

        @Override
        protected Object resolveObject(Object obj) throws IOException {
            if (obj instanceof URLContent) {
                URL tmpURL = ((URLContent) obj).getURL();
                String url = tmpURL.toString();
                if (url.startsWith(""jar:file:temp!/"")) {
                    // Replace ""temp"" in URL by current temporary file
                    String entryName = url.substring(url.indexOf('!') + 2);
                    URL fileURL = new URL(""jar:file:"" + tempFile.toString() + ""!/"" + entryName);
                    try {
                        // Check entry exists
                        fileURL.openStream().close();
                    } catch (IOException ex) {
                        throw new IOException(""Missing entry \"""" + entryName + ""\"""");
                    }
                    return new HomeURLContent(fileURL);
                } else {
                    return obj;
                }
            } else {
                return obj;
            }
        }
    }
}
","// DefaultHomeInputStreamTest.java
package com.eteks.sweethome3d.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultHomeInputStream}.
* It contains one unit test case for the {@link DefaultHomeInputStream#readHome()} method.
*/
class DefaultHomeInputStreamTest {","// DefaultHomeInputStreamTest.java
package com.eteks.sweethome3d.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.Home;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultHomeInputStream}.
* It contains one unit test case for the {@link DefaultHomeInputStream#readHome()} method.
*/
class DefaultHomeInputStreamTest {
"
f526aafc-e830-4fa2-89db-a63896f2d884,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/io/FileUserPreferences_3Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FileUserPreferences.java
/*
 * FileUserPreferences.java 18 sept 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;

/**
 * User preferences initialized from
 * {@link com.eteks.sweethome3d.io.DefaultUserPreferences default user preferences}
 * and stored in user preferences on local file system.
 * @author Emmanuel Puybaret
 */
public class FileUserPreferences extends UserPreferences {

    private static final String LANGUAGE = ""language"";

    private static final String UNIT = ""unit"";

    private static final String FURNITURE_CATALOG_VIEWED_IN_TREE = ""furnitureCatalogViewedInTree"";

    private static final String NAVIGATION_PANEL_VISIBLE = ""navigationPanelVisible"";

    private static final String MAGNETISM_ENABLED = ""magnetismEnabled"";

    private static final String RULERS_VISIBLE = ""rulersVisible"";

    private static final String GRID_VISIBLE = ""gridVisible"";

    private static final String FURNITURE_VIEWED_FROM_TOP = ""furnitureViewedFromTop"";

    private static final String ROOM_FLOOR_COLORED_OR_TEXTURED = ""roomFloorColoredOrTextured"";

    private static final String WALL_PATTERN = ""wallPattern"";

    private static final String NEW_WALL_HEIGHT = ""newHomeWallHeight"";

    private static final String NEW_WALL_THICKNESS = ""newWallThickness"";

    private static final String NEW_FLOOR_THICKNESS = ""newFloorThickness"";

    private static final String AUTO_SAVE_DELAY_FOR_RECOVERY = ""autoSaveDelayForRecovery"";

    private static final String AUTO_COMPLETION_PROPERTY = ""autoCompletionProperty#"";

    private static final String AUTO_COMPLETION_STRINGS = ""autoCompletionStrings#"";

    private static final String RECENT_HOMES = ""recentHomes#"";

    private static final String IGNORED_ACTION_TIP = ""ignoredActionTip#"";

    private static final String FURNITURE_NAME = ""furnitureName#"";

    private static final String FURNITURE_CATEGORY = ""furnitureCategory#"";

    private static final String FURNITURE_ICON = ""furnitureIcon#"";

    private static final String FURNITURE_MODEL = ""furnitureModel#"";

    private static final String FURNITURE_WIDTH = ""furnitureWidth#"";

    private static final String FURNITURE_DEPTH = ""furnitureDepth#"";

    private static final String FURNITURE_HEIGHT = ""furnitureHeight#"";

    private static final String FURNITURE_MOVABLE = ""furnitureMovable#"";

    private static final String FURNITURE_DOOR_OR_WINDOW = ""furnitureDoorOrWindow#"";

    private static final String FURNITURE_ELEVATION = ""furnitureElevation#"";

    private static final String FURNITURE_COLOR = ""furnitureColor#"";

    private static final String FURNITURE_MODEL_ROTATION = ""furnitureModelRotation#"";

    private static final String FURNITURE_STAIRCASE_CUT_OUT_SHAPE = ""furnitureStaircaseCutOutShape#"";

    private static final String FURNITURE_BACK_FACE_SHOWN = ""furnitureBackFaceShown#"";

    private static final String FURNITURE_ICON_YAW = ""furnitureIconYaw#"";

    private static final String FURNITURE_PROPORTIONAL = ""furnitureProportional#"";

    private static final String TEXTURE_NAME = ""textureName#"";

    private static final String TEXTURE_CATEGORY = ""textureCategory#"";

    private static final String TEXTURE_IMAGE = ""textureImage#"";

    private static final String TEXTURE_WIDTH = ""textureWidth#"";

    private static final String TEXTURE_HEIGHT = ""textureHeight#"";

    private static final String FURNITURE_CONTENT_PREFIX = ""Furniture-3-"";

    private static final String TEXTURE_CONTENT_PREFIX = ""Texture-3-"";

    private static final String LANGUAGE_LIBRARIES_PLUGIN_SUB_FOLDER = ""languages"";

    private static final String FURNITURE_LIBRARIES_PLUGIN_SUB_FOLDER = ""furniture"";

    private static final String TEXTURES_LIBRARIES_PLUGIN_SUB_FOLDER = ""textures"";

    private static final Content DUMMY_CONTENT;

    private final Map<String, Boolean> ignoredActionTips = new HashMap<String, Boolean>();

    private List<ClassLoader> resourceClassLoaders;

    private final File preferencesFolder;

    private final File[] applicationFolders;

    private Preferences preferences;

    private Executor catalogsLoader;

    private Executor updater;

    static {
        Content dummyURLContent = null;
        try {
            dummyURLContent = new URLContent(new URL(""file:/dummySweetHome3DContent""));
        } catch (MalformedURLException ex) {
        }
        DUMMY_CONTENT = dummyURLContent;
    }

    /**
     * Creates user preferences read from user preferences in file system,
     * and from resource files.
     */
    public FileUserPreferences() {
        this(null, null);
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders) {
        this(preferencesFolder, applicationFolders, null);
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders  the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     * @param updater  an executor that will be used to update user preferences for lengthy
     *    operations. If <code>null</code>, then these operations and
     *    updates will be executed in the current thread.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders, Executor updater) {
        this.preferencesFolder = preferencesFolder;
        this.applicationFolders = applicationFolders;
        Executor defaultExecutor = new Executor() {

            public void execute(Runnable command) {
                command.run();
            }
        };
        if (updater == null) {
            this.catalogsLoader = this.updater = defaultExecutor;
        } else {
            this.catalogsLoader = Executors.newSingleThreadExecutor();
            this.updater = updater;
        }
        updateSupportedLanguages();
        final Preferences preferences;
        // From version 3.0 use portable preferences
        PortablePreferences portablePreferences = new PortablePreferences();
        // If portable preferences storage doesn't exist and default preferences folder is used
        if (!portablePreferences.exist() && preferencesFolder == null) {
            // Retrieve preferences from pre version 3.0
            preferences = getPreferences();
        } else {
            preferences = portablePreferences;
        }
        String language = preferences.get(LANGUAGE, getLanguage());
        // Check language is still supported
        if (!Arrays.asList(getSupportedLanguages()).contains(language)) {
            language = Locale.ENGLISH.getLanguage();
        }
        setLanguage(language);
        setFurnitureCatalog(new FurnitureCatalog());
        // Fill default furniture catalog
        updateFurnitureDefaultCatalog(defaultExecutor, defaultExecutor);
        // Read additional furniture
        readModifiableFurnitureCatalog(preferences);
        setTexturesCatalog(new TexturesCatalog());
        // Fill default textures catalog
        updateTexturesDefaultCatalog(defaultExecutor, defaultExecutor);
        // Read additional textures
        readModifiableTexturesCatalog(preferences);
        DefaultUserPreferences defaultPreferences = new DefaultUserPreferences(false, this);
        // Fill default patterns catalog
        PatternsCatalog patternsCatalog = defaultPreferences.getPatternsCatalog();
        setPatternsCatalog(patternsCatalog);
        // Read other preferences
        setUnit(LengthUnit.valueOf(preferences.get(UNIT, defaultPreferences.getLengthUnit().name())));
        setFurnitureCatalogViewedInTree(preferences.getBoolean(FURNITURE_CATALOG_VIEWED_IN_TREE, defaultPreferences.isFurnitureCatalogViewedInTree()));
        setNavigationPanelVisible(preferences.getBoolean(NAVIGATION_PANEL_VISIBLE, defaultPreferences.isNavigationPanelVisible()));
        setMagnetismEnabled(preferences.getBoolean(MAGNETISM_ENABLED, true));
        setRulersVisible(preferences.getBoolean(RULERS_VISIBLE, defaultPreferences.isRulersVisible()));
        setGridVisible(preferences.getBoolean(GRID_VISIBLE, defaultPreferences.isGridVisible()));
        setFurnitureViewedFromTop(preferences.getBoolean(FURNITURE_VIEWED_FROM_TOP, defaultPreferences.isFurnitureViewedFromTop()));
        setFloorColoredOrTextured(preferences.getBoolean(ROOM_FLOOR_COLORED_OR_TEXTURED, defaultPreferences.isRoomFloorColoredOrTextured()));
        try {
            setWallPattern(patternsCatalog.getPattern(preferences.get(WALL_PATTERN, defaultPreferences.getWallPattern().getName())));
        } catch (IllegalArgumentException ex) {
            // Ensure wall pattern always exists even if new patterns are added in future versions
            setWallPattern(defaultPreferences.getWallPattern());
        }
        setNewWallThickness(preferences.getFloat(NEW_WALL_THICKNESS, defaultPreferences.getNewWallThickness()));
        setNewWallHeight(preferences.getFloat(NEW_WALL_HEIGHT, defaultPreferences.getNewWallHeight()));
        setNewFloorThickness(preferences.getFloat(NEW_FLOOR_THICKNESS, defaultPreferences.getNewFloorThickness()));
        setAutoSaveDelayForRecovery(preferences.getInt(AUTO_SAVE_DELAY_FOR_RECOVERY, defaultPreferences.getAutoSaveDelayForRecovery()));
        setCurrency(defaultPreferences.getCurrency());
        // Read recent homes list
        List<String> recentHomes = new ArrayList<String>();
        for (int i = 1; i <= getRecentHomesMaxCount(); i++) {
            String recentHome = preferences.get(RECENT_HOMES + i, null);
            if (recentHome != null) {
                recentHomes.add(recentHome);
            }
        }
        setRecentHomes(recentHomes);
        // Read ignored action tips
        for (int i = 1; ; i++) {
            String ignoredActionTip = preferences.get(IGNORED_ACTION_TIP + i, """");
            if (ignoredActionTip.length() == 0) {
                break;
            } else {
                this.ignoredActionTips.put(ignoredActionTip, true);
            }
        }
        // Get default auto completion strings
        for (String property : defaultPreferences.getAutoCompletedProperties()) {
            setAutoCompletionStrings(property, defaultPreferences.getAutoCompletionStrings(property));
        }
        // Read auto completion strings list
        for (int i = 1; ; i++) {
            String autoCompletionProperty = preferences.get(AUTO_COMPLETION_PROPERTY + i, null);
            String autoCompletionStrings = preferences.get(AUTO_COMPLETION_STRINGS + i, null);
            if (autoCompletionProperty != null && autoCompletionStrings != null) {
                setAutoCompletionStrings(autoCompletionProperty, Arrays.asList(autoCompletionStrings.split("","")));
            } else {
                break;
            }
        }
        addPropertyChangeListener(Property.LANGUAGE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                // Update catalogs with new default locale
                updateFurnitureDefaultCatalog(catalogsLoader, FileUserPreferences.this.updater);
                updateTexturesDefaultCatalog(catalogsLoader, FileUserPreferences.this.updater);
                updateAutoCompletionStrings();
            }
        });
        if (preferences != portablePreferences) {
            // Switch to portable preferences now that all preferences are read
            this.preferences = portablePreferences;
        } else {
            this.preferences = preferences;
        }
    }

    /**
     * Updates the default supported languages with languages available in plugin folder.
     */
    private void updateSupportedLanguages() {
        List<ClassLoader> resourceClassLoaders = new ArrayList<ClassLoader>();
        String[] defaultSupportedLanguages = getDefaultSupportedLanguages();
        Set<String> supportedLanguages = new TreeSet<String>(Arrays.asList(defaultSupportedLanguages));
        File[] languageLibrariesPluginFolders = getLanguageLibrariesPluginFolders();
        if (languageLibrariesPluginFolders != null) {
            for (File languageLibrariesPluginFolder : languageLibrariesPluginFolders) {
                // Try to load sh3l files from language plugin folder
                File[] pluginLanguageLibraryFiles = languageLibrariesPluginFolder.listFiles(new FileFilter() {

                    public boolean accept(File pathname) {
                        return pathname.isFile();
                    }
                });
                if (pluginLanguageLibraryFiles != null) {
                    // Treat language files in reverse order so file named with a date or a version
                    // will be taken into account from most recent to least recent
                    Arrays.sort(pluginLanguageLibraryFiles, Collections.reverseOrder());
                    for (File pluginLanguageLibraryFile : pluginLanguageLibraryFiles) {
                        try {
                            Set<String> languages = getLanguages(pluginLanguageLibraryFile);
                            if (!languages.isEmpty()) {
                                supportedLanguages.addAll(languages);
                                URL pluginFurnitureCatalogUrl = pluginLanguageLibraryFile.toURI().toURL();
                                resourceClassLoaders.add(new URLClassLoader(new URL[] { pluginFurnitureCatalogUrl }));
                            }
                        } catch (IOException ex) {
                            // Ignore malformed files
                        }
                    }
                }
            }
        }
        // Give less priority to default class loader
        resourceClassLoaders.addAll(super.getResourceClassLoaders());
        this.resourceClassLoaders = Collections.unmodifiableList(resourceClassLoaders);
        if (defaultSupportedLanguages.length < supportedLanguages.size()) {
            setSupportedLanguages(supportedLanguages.toArray(new String[supportedLanguages.size()]));
        }
    }

    /**
     * Returns the languages included in the given language library file.
     */
    private Set<String> getLanguages(File languageLibraryFile) throws IOException {
        Set<String> languages = new LinkedHashSet<String>();
        ZipInputStream zipIn = null;
        try {
            // Search if zip file contains some *_xx.properties or *_xx_xx.properties files
            zipIn = new ZipInputStream(new FileInputStream(languageLibraryFile));
            for (ZipEntry entry; (entry = zipIn.getNextEntry()) != null; ) {
                String zipEntryName = entry.getName();
                int underscoreIndex = zipEntryName.indexOf('_');
                if (underscoreIndex != -1) {
                    int extensionIndex = zipEntryName.lastIndexOf("".properties"");
                    if (extensionIndex != -1 && underscoreIndex < extensionIndex - 2) {
                        String language = zipEntryName.substring(underscoreIndex + 1, extensionIndex);
                        int countrySeparator = language.indexOf('_');
                        if (countrySeparator == 2 && language.length() == 5) {
                            languages.add(language);
                        } else if (language.length() == 2) {
                            languages.add(language);
                        }
                    }
                }
            }
            return languages;
        } finally {
            if (zipIn != null) {
                zipIn.close();
            }
        }
    }

    /**
     * Returns the default class loader of user preferences and the class loaders that
     * give access to resources in language libraries plugin folder.
     */
    @Override
    public List<ClassLoader> getResourceClassLoaders() {
        return this.resourceClassLoaders;
    }

    /**
     * Reloads furniture default catalogs.
     */
    private void updateFurnitureDefaultCatalog(Executor furnitureCatalogLoader, final Executor updater) {
        // Delete default pieces of current furniture catalog
        final FurnitureCatalog furnitureCatalog = getFurnitureCatalog();
        for (FurnitureCategory category : furnitureCatalog.getCategories()) {
            for (CatalogPieceOfFurniture piece : category.getFurniture()) {
                if (!piece.isModifiable()) {
                    furnitureCatalog.delete(piece);
                }
            }
        }
        // Read default furniture catalog
        furnitureCatalogLoader.execute(new Runnable() {

            public void run() {
                // Fill default furniture catalog
                DefaultFurnitureCatalog defaultFurnitureCatalog = new DefaultFurnitureCatalog(FileUserPreferences.this, getFurnitureLibrariesPluginFolders());
                for (final FurnitureCategory category : defaultFurnitureCatalog.getCategories()) {
                    for (final CatalogPieceOfFurniture piece : category.getFurniture()) {
                        updater.execute(new Runnable() {

                            public void run() {
                                furnitureCatalog.add(category, piece);
                            }
                        });
                    }
                }
            }
        });
    }

    /**
     * Reloads textures default catalog.
     */
    private void updateTexturesDefaultCatalog(Executor texturesCatalogLoader, final Executor updater) {
        // Delete default textures of current textures catalog
        final TexturesCatalog texturesCatalog = getTexturesCatalog();
        for (TexturesCategory category : texturesCatalog.getCategories()) {
            for (CatalogTexture texture : category.getTextures()) {
                if (!texture.isModifiable()) {
                    texturesCatalog.delete(texture);
                }
            }
        }
        // Read default textures catalog
        texturesCatalogLoader.execute(new Runnable() {

            public void run() {
                TexturesCatalog defaultTexturesCatalog = new DefaultTexturesCatalog(FileUserPreferences.this, getTexturesLibrariesPluginFolders());
                for (final TexturesCategory category : defaultTexturesCatalog.getCategories()) {
                    for (final CatalogTexture texture : category.getTextures()) {
                        updater.execute(new Runnable() {

                            public void run() {
                                texturesCatalog.add(category, texture);
                            }
                        });
                    }
                }
            }
        });
    }

    /**
     * Adds to auto completion strings the default strings of the new chosen language.
     */
    private void updateAutoCompletionStrings() {
        DefaultUserPreferences defaultPreferences = new DefaultUserPreferences(false, this);
        for (String property : defaultPreferences.getAutoCompletedProperties()) {
            for (String autoCompletionString : defaultPreferences.getAutoCompletionStrings(property)) {
                addAutoCompletionString(property, autoCompletionString);
            }
        }
    }

    /**
     * Read modifiable furniture catalog from preferences.
     */
    private void readModifiableFurnitureCatalog(Preferences preferences) {
        for (int i = 1; ; i++) {
            String name = preferences.get(FURNITURE_NAME + i, null);
            if (name == null) {
                // Stop the loop when a key furnitureName# doesn't exist
                break;
            }
            String category = preferences.get(FURNITURE_CATEGORY + i, """");
            Content icon = getContent(preferences, FURNITURE_ICON + i);
            Content model = getContent(preferences, FURNITURE_MODEL + i);
            float width = preferences.getFloat(FURNITURE_WIDTH + i, 0.1f);
            float depth = preferences.getFloat(FURNITURE_DEPTH + i, 0.1f);
            float height = preferences.getFloat(FURNITURE_HEIGHT + i, 0.1f);
            boolean movable = preferences.getBoolean(FURNITURE_MOVABLE + i, false);
            boolean doorOrWindow = preferences.getBoolean(FURNITURE_DOOR_OR_WINDOW + i, false);
            float elevation = preferences.getFloat(FURNITURE_ELEVATION + i, 0);
            String colorString = preferences.get(FURNITURE_COLOR + i, null);
            Integer color = colorString != null ? Integer.valueOf(colorString) : null;
            float[][] modelRotation = getModelRotation(preferences, FURNITURE_MODEL_ROTATION + i);
            String staircaseCutOutShape = preferences.get(FURNITURE_STAIRCASE_CUT_OUT_SHAPE + i, null);
            boolean backFaceShown = preferences.getBoolean(FURNITURE_BACK_FACE_SHOWN + i, false);
            float iconYaw = preferences.getFloat(FURNITURE_ICON_YAW + i, 0);
            boolean proportional = preferences.getBoolean(FURNITURE_PROPORTIONAL + i, true);
            final FurnitureCategory pieceCategory = new FurnitureCategory(category);
            final CatalogPieceOfFurniture piece;
            if (doorOrWindow) {
                piece = new CatalogDoorOrWindow(name, icon, model, width, depth, height, elevation, movable, 1, 0, new Sash[0], color, modelRotation, backFaceShown, iconYaw, proportional);
            } else {
                piece = new CatalogPieceOfFurniture(name, icon, model, width, depth, height, elevation, movable, staircaseCutOutShape, color, modelRotation, backFaceShown, iconYaw, proportional);
            }
            getFurnitureCatalog().add(pieceCategory, piece);
        }
    }

    /**
     * Returns model rotation parsed from key value.
     */
    private float[][] getModelRotation(Preferences preferences, String key) {
        String modelRotationString = preferences.get(key, null);
        if (modelRotationString == null) {
            return new float[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
        } else {
            String[] values = modelRotationString.split("" "", 9);
            if (values.length != 9) {
                return new float[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
            } else {
                try {
                    return new float[][] { { Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]) }, { Float.parseFloat(values[3]), Float.parseFloat(values[4]), Float.parseFloat(values[5]) }, { Float.parseFloat(values[6]), Float.parseFloat(values[7]), Float.parseFloat(values[8]) } };
                } catch (NumberFormatException ex) {
                    return new float[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
                }
            }
        }
    }

    /**
     * Returns a content instance from the resource file value of key.
     */
    private Content getContent(Preferences preferences, String key) {
        String content = preferences.get(key, null);
        if (content != null) {
            try {
                String preferencesFolderUrl = getPreferencesFolder().toURI().toURL().toString();
                if (content.startsWith(preferencesFolderUrl) || content.startsWith(""jar:"" + preferencesFolderUrl)) {
                    return new URLContent(new URL(content));
                } else {
                    return new URLContent(new URL(content.replace(""file:"", preferencesFolderUrl)));
                }
            } catch (IOException ex) {
                // Return DUMMY_CONTENT for incorrect URL
            }
        }
        return DUMMY_CONTENT;
    }

    /**
     * Read modifiable textures catalog from preferences.
     */
    private void readModifiableTexturesCatalog(Preferences preferences) {
        for (int i = 1; ; i++) {
            String name = preferences.get(TEXTURE_NAME + i, null);
            if (name == null) {
                // Stop the loop when a key textureName# doesn't exist
                break;
            }
            String category = preferences.get(TEXTURE_CATEGORY + i, """");
            Content image = getContent(preferences, TEXTURE_IMAGE + i);
            float width = preferences.getFloat(TEXTURE_WIDTH + i, 0.1f);
            float height = preferences.getFloat(TEXTURE_HEIGHT + i, 0.1f);
            final TexturesCategory textureCategory = new TexturesCategory(category);
            final CatalogTexture texture = new CatalogTexture(name, image, width, height, true);
            getTexturesCatalog().add(textureCategory, texture);
        }
    }

    /**
     * Writes user preferences in current user preferences in system.
     */
    @Override
    public void write() throws RecorderException {
        Preferences preferences = getPreferences();
        writeModifiableFurnitureCatalog(preferences);
        writeModifiableTexturesCatalog(preferences);
        // Write other preferences
        preferences.put(LANGUAGE, getLanguage());
        preferences.put(UNIT, getLengthUnit().name());
        preferences.putBoolean(FURNITURE_CATALOG_VIEWED_IN_TREE, isFurnitureCatalogViewedInTree());
        preferences.putBoolean(NAVIGATION_PANEL_VISIBLE, isNavigationPanelVisible());
        preferences.putBoolean(MAGNETISM_ENABLED, isMagnetismEnabled());
        preferences.putBoolean(RULERS_VISIBLE, isRulersVisible());
        preferences.putBoolean(GRID_VISIBLE, isGridVisible());
        preferences.putBoolean(FURNITURE_VIEWED_FROM_TOP, isFurnitureViewedFromTop());
        preferences.putBoolean(ROOM_FLOOR_COLORED_OR_TEXTURED, isRoomFloorColoredOrTextured());
        preferences.put(WALL_PATTERN, getWallPattern().getName());
        preferences.putFloat(NEW_WALL_THICKNESS, getNewWallThickness());
        preferences.putFloat(NEW_WALL_HEIGHT, getNewWallHeight());
        preferences.putFloat(NEW_FLOOR_THICKNESS, getNewFloorThickness());
        preferences.putInt(AUTO_SAVE_DELAY_FOR_RECOVERY, getAutoSaveDelayForRecovery());
        // Write recent homes list
        int i = 1;
        for (Iterator<String> it = getRecentHomes().iterator(); it.hasNext() && i <= getRecentHomesMaxCount(); i++) {
            preferences.put(RECENT_HOMES + i, it.next());
        }
        // Remove obsolete keys
        for (; i <= getRecentHomesMaxCount(); i++) {
            preferences.remove(RECENT_HOMES + i);
        }
        // Write ignored action tips
        i = 1;
        for (Iterator<Map.Entry<String, Boolean>> it = this.ignoredActionTips.entrySet().iterator(); it.hasNext(); ) {
            Entry<String, Boolean> ignoredActionTipEntry = it.next();
            if (ignoredActionTipEntry.getValue()) {
                preferences.put(IGNORED_ACTION_TIP + i++, ignoredActionTipEntry.getKey());
            }
        }
        // Remove obsolete keys
        for (; i <= this.ignoredActionTips.size(); i++) {
            preferences.remove(IGNORED_ACTION_TIP + i);
        }
        // Write auto completion strings lists
        i = 1;
        for (String property : getAutoCompletedProperties()) {
            StringBuilder autoCompletionStrings = new StringBuilder();
            Iterator<String> it = getAutoCompletionStrings(property).iterator();
            for (int j = 0; j < 1000 && it.hasNext(); j++) {
                String autoCompletionString = it.next();
                // As strings are comma separated, accept only the ones without a comma
                if (autoCompletionString.indexOf(',') < 0) {
                    if (autoCompletionStrings.length() > 0) {
                        autoCompletionStrings.append("","");
                    }
                    autoCompletionStrings.append(autoCompletionString);
                }
            }
            preferences.put(AUTO_COMPLETION_PROPERTY + i, property);
            preferences.put(AUTO_COMPLETION_STRINGS + i++, autoCompletionStrings.toString());
        }
        for (; preferences.get(AUTO_COMPLETION_PROPERTY + i, null) != null; i++) {
            preferences.remove(AUTO_COMPLETION_PROPERTY + i);
            preferences.remove(AUTO_COMPLETION_STRINGS + i);
        }
        try {
            // Write preferences
            preferences.flush();
        } catch (BackingStoreException ex) {
            throw new RecorderException(""Couldn't write preferences"", ex);
        }
    }

    /**
     * Writes modifiable furniture in <code>preferences</code>.
     */
    private void writeModifiableFurnitureCatalog(Preferences preferences) throws RecorderException {
        final Set<URL> furnitureContentURLs = new HashSet<URL>();
        int i = 1;
        for (FurnitureCategory category : getFurnitureCatalog().getCategories()) {
            for (CatalogPieceOfFurniture piece : category.getFurniture()) {
                if (piece.isModifiable()) {
                    preferences.put(FURNITURE_NAME + i, piece.getName());
                    preferences.put(FURNITURE_CATEGORY + i, category.getName());
                    putContent(preferences, FURNITURE_ICON + i, piece.getIcon(), FURNITURE_CONTENT_PREFIX, furnitureContentURLs);
                    putContent(preferences, FURNITURE_MODEL + i, piece.getModel(), FURNITURE_CONTENT_PREFIX, furnitureContentURLs);
                    preferences.putFloat(FURNITURE_WIDTH + i, piece.getWidth());
                    preferences.putFloat(FURNITURE_DEPTH + i, piece.getDepth());
                    preferences.putFloat(FURNITURE_HEIGHT + i, piece.getHeight());
                    preferences.putBoolean(FURNITURE_MOVABLE + i, piece.isMovable());
                    preferences.putBoolean(FURNITURE_DOOR_OR_WINDOW + i, piece.isDoorOrWindow());
                    preferences.putFloat(FURNITURE_ELEVATION + i, piece.getElevation());
                    if (piece.getColor() == null) {
                        preferences.remove(FURNITURE_COLOR + i);
                    } else {
                        preferences.put(FURNITURE_COLOR + i, String.valueOf(piece.getColor()));
                    }
                    float[][] modelRotation = piece.getModelRotation();
                    preferences.put(FURNITURE_MODEL_ROTATION + i, floatToString(modelRotation[0][0]) + "" "" + floatToString(modelRotation[0][1]) + "" "" + floatToString(modelRotation[0][2]) + "" "" + floatToString(modelRotation[1][0]) + "" "" + floatToString(modelRotation[1][1]) + "" "" + floatToString(modelRotation[1][2]) + "" "" + floatToString(modelRotation[2][0]) + "" "" + floatToString(modelRotation[2][1]) + "" "" + floatToString(modelRotation[2][2]));
                    if (piece.getStaircaseCutOutShape() != null) {
                        preferences.put(FURNITURE_STAIRCASE_CUT_OUT_SHAPE + i, piece.getStaircaseCutOutShape());
                    }
                    preferences.putBoolean(FURNITURE_BACK_FACE_SHOWN + i, piece.isBackFaceShown());
                    preferences.putFloat(FURNITURE_ICON_YAW + i, piece.getIconYaw());
                    preferences.putBoolean(FURNITURE_PROPORTIONAL + i, piece.isProportional());
                    i++;
                }
            }
        }
        // Remove obsolete keys
        for (; preferences.get(FURNITURE_NAME + i, null) != null; i++) {
            preferences.remove(FURNITURE_NAME + i);
            preferences.remove(FURNITURE_CATEGORY + i);
            preferences.remove(FURNITURE_ICON + i);
            preferences.remove(FURNITURE_MODEL + i);
            preferences.remove(FURNITURE_WIDTH + i);
            preferences.remove(FURNITURE_DEPTH + i);
            preferences.remove(FURNITURE_HEIGHT + i);
            preferences.remove(FURNITURE_MOVABLE + i);
            preferences.remove(FURNITURE_DOOR_OR_WINDOW + i);
            preferences.remove(FURNITURE_ELEVATION + i);
            preferences.remove(FURNITURE_COLOR + i);
            preferences.remove(FURNITURE_MODEL_ROTATION + i);
            preferences.remove(FURNITURE_STAIRCASE_CUT_OUT_SHAPE + i);
            preferences.remove(FURNITURE_BACK_FACE_SHOWN + i);
            preferences.remove(FURNITURE_ICON_YAW + i);
            preferences.remove(FURNITURE_PROPORTIONAL + i);
        }
        deleteObsoleteContent(furnitureContentURLs, FURNITURE_CONTENT_PREFIX);
    }

    /**
     * Returns the string value of the given float, except for -1.0, 1.0 or 0.0 where -1, 1 and 0 is returned.
     */
    private String floatToString(float f) {
        if (Math.abs(f) < 1E-6) {
            return ""0"";
        } else if (Math.abs(f - 1f) < 1E-6) {
            return ""1"";
        } else if (Math.abs(f + 1f) < 1E-6) {
            return ""-1"";
        } else {
            return String.valueOf(f);
        }
    }

    /**
     * Writes modifiable textures catalog in <code>preferences</code>.
     */
    private void writeModifiableTexturesCatalog(Preferences preferences) throws RecorderException {
        final Set<URL> texturesContentURLs = new HashSet<URL>();
        int i = 1;
        for (TexturesCategory category : getTexturesCatalog().getCategories()) {
            for (CatalogTexture texture : category.getTextures()) {
                if (texture.isModifiable()) {
                    preferences.put(TEXTURE_NAME + i, texture.getName());
                    preferences.put(TEXTURE_CATEGORY + i, category.getName());
                    putContent(preferences, TEXTURE_IMAGE + i, texture.getImage(), TEXTURE_CONTENT_PREFIX, texturesContentURLs);
                    preferences.putFloat(TEXTURE_WIDTH + i, texture.getWidth());
                    preferences.putFloat(TEXTURE_HEIGHT + i, texture.getHeight());
                    i++;
                }
            }
        }
        // Remove obsolete keys
        for (; preferences.get(TEXTURE_NAME + i, null) != null; i++) {
            preferences.remove(TEXTURE_NAME + i);
            preferences.remove(TEXTURE_CATEGORY + i);
            preferences.remove(TEXTURE_IMAGE + i);
            preferences.remove(TEXTURE_WIDTH + i);
            preferences.remove(TEXTURE_HEIGHT + i);
        }
        deleteObsoleteContent(texturesContentURLs, TEXTURE_CONTENT_PREFIX);
    }

    /**
     * Writes <code>key</code> <code>content</code> in <code>preferences</code>.
     */
    private void putContent(Preferences preferences, String key, Content content, String contentPrefix, Set<URL> furnitureContentURLs) throws RecorderException {
        if (content instanceof TemporaryURLContent) {
            URLContent urlContent = (URLContent) content;
            URLContent copiedContent;
            if (urlContent.isJAREntry()) {
                try {
                    // If content is a JAR entry copy the content of its URL and rebuild a new URL content from
                    // this copy and the entry name
                    copiedContent = copyToPreferencesURLContent(new URLContent(urlContent.getJAREntryURL()), contentPrefix);
                    copiedContent = new URLContent(new URL(""jar:"" + copiedContent.getURL() + ""!/"" + urlContent.getJAREntryName()));
                } catch (MalformedURLException ex) {
                    // Shouldn't happen
                    throw new RecorderException(""Can't build URL"", ex);
                }
            } else {
                copiedContent = copyToPreferencesURLContent(urlContent, contentPrefix);
            }
            putContent(preferences, key, copiedContent, contentPrefix, furnitureContentURLs);
        } else if (content instanceof URLContent) {
            URLContent urlContent = (URLContent) content;
            try {
                preferences.put(key, urlContent.getURL().toString().replace(getPreferencesFolder().toURI().toURL().toString(), ""file:""));
            } catch (IOException ex) {
                throw new RecorderException(""Can't save content"", ex);
            }
            // Add to furnitureContentURLs the URL to the application file
            if (urlContent.isJAREntry()) {
                furnitureContentURLs.add(urlContent.getJAREntryURL());
            } else {
                furnitureContentURLs.add(urlContent.getURL());
            }
        } else {
            putContent(preferences, key, copyToPreferencesURLContent(content, contentPrefix), contentPrefix, furnitureContentURLs);
        }
    }

    /**
     * Returns a content object that references a copy of <code>content</code> in
     * user preferences folder.
     */
    private URLContent copyToPreferencesURLContent(Content content, String contentPrefix) throws RecorderException {
        InputStream tempIn = null;
        OutputStream tempOut = null;
        try {
            File preferencesFile = createPreferencesFile(contentPrefix);
            tempIn = content.openStream();
            tempOut = new FileOutputStream(preferencesFile);
            byte[] buffer = new byte[8192];
            int size;
            while ((size = tempIn.read(buffer)) != -1) {
                tempOut.write(buffer, 0, size);
            }
            return new URLContent(preferencesFile.toURI().toURL());
        } catch (IOException ex) {
            throw new RecorderException(""Can't save content"", ex);
        } finally {
            try {
                if (tempIn != null) {
                    tempIn.close();
                }
                if (tempOut != null) {
                    tempOut.close();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Can't close files"", ex);
            }
        }
    }

    /**
     * Returns the folder where language libraries files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getLanguageLibrariesPluginFolders() {
        try {
            return getApplicationSubfolders(LANGUAGE_LIBRARIES_PLUGIN_SUB_FOLDER);
        } catch (IOException ex) {
            return null;
        }
    }

    /**
     * Returns the folder where furniture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getFurnitureLibrariesPluginFolders() {
        try {
            return getApplicationSubfolders(FURNITURE_LIBRARIES_PLUGIN_SUB_FOLDER);
        } catch (IOException ex) {
            return null;
        }
    }

    /**
     * Returns the folder where texture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getTexturesLibrariesPluginFolders() {
        try {
            return getApplicationSubfolders(TEXTURES_LIBRARIES_PLUGIN_SUB_FOLDER);
        } catch (IOException ex) {
            return null;
        }
    }

    /**
     * Returns the first Sweet Home 3D application folder.
     */
    public File getApplicationFolder() throws IOException {
        File[] applicationFolders = getApplicationFolders();
        if (applicationFolders.length == 0) {
            throw new IOException(""No application folder defined"");
        } else {
            return applicationFolders[0];
        }
    }

    /**
     * Returns Sweet Home 3D application folders.
     */
    public File[] getApplicationFolders() throws IOException {
        if (this.applicationFolders != null) {
            return this.applicationFolders;
        } else {
            return new File[] { OperatingSystem.getDefaultApplicationFolder() };
        }
    }

    /**
     * Returns subfolders of Sweet Home 3D application folders of a given name.
     */
    public File[] getApplicationSubfolders(String subfolder) throws IOException {
        File[] applicationFolders = getApplicationFolders();
        File[] applicationSubfolders = new File[applicationFolders.length];
        for (int i = 0; i < applicationFolders.length; i++) {
            applicationSubfolders[i] = new File(applicationFolders[i], subfolder);
        }
        return applicationSubfolders;
    }

    /**
     * Returns a new file in user preferences folder.
     */
    private File createPreferencesFile(String filePrefix) throws IOException {
        checkPreferencesFolder();
        // Return a new file in preferences folder
        return File.createTempFile(filePrefix, "".pref"", getPreferencesFolder());
    }

    /**
     * Creates preferences folder and its sub folders if it doesn't exist.
     */
    private void checkPreferencesFolder() throws IOException {
        File preferencesFolder = getPreferencesFolder();
        // Create preferences folder if it doesn't exist
        if (!preferencesFolder.exists() && !preferencesFolder.mkdirs()) {
            throw new IOException(""Couldn't create "" + preferencesFolder);
        }
        checkPreferencesSubFolder(getLanguageLibrariesPluginFolders());
        checkPreferencesSubFolder(getFurnitureLibrariesPluginFolders());
        checkPreferencesSubFolder(getTexturesLibrariesPluginFolders());
    }

    /**
     * Creates the first folder in the given folders.
     */
    private void checkPreferencesSubFolder(File[] librariesPluginFolders) {
        if (librariesPluginFolders != null && librariesPluginFolders.length > 0 && !librariesPluginFolders[0].exists()) {
            librariesPluginFolders[0].mkdirs();
        }
    }

    /**
     * Deletes from application folder the content files starting by <code>contentPrefix</code>
     * that don't belong to <code>contentURLs</code>.
     */
    private void deleteObsoleteContent(final Set<URL> contentURLs, final String contentPrefix) throws RecorderException {
        // Search obsolete contents
        File applicationFolder;
        try {
            applicationFolder = getPreferencesFolder();
        } catch (IOException ex) {
            throw new RecorderException(""Can't access to application folder"");
        }
        File[] obsoleteContentFiles = applicationFolder.listFiles(new FileFilter() {

            public boolean accept(File applicationFile) {
                try {
                    URL toURL = applicationFile.toURI().toURL();
                    return applicationFile.getName().startsWith(contentPrefix) && !contentURLs.contains(toURL);
                } catch (MalformedURLException ex) {
                    return false;
                }
            }
        });
        if (obsoleteContentFiles != null) {
            // Delete obsolete contents at program exit to ensure removed contents
            // can still be saved in homes that reference them
            for (File file : obsoleteContentFiles) {
                file.deleteOnExit();
            }
        }
    }

    /**
     * Returns the folder where files depending on preferences are stored.
     */
    private File getPreferencesFolder() throws IOException {
        if (this.preferencesFolder != null) {
            return this.preferencesFolder;
        } else {
            return OperatingSystem.getDefaultApplicationFolder();
        }
    }

    /**
     * Returns default Java preferences for current system user.
     * Caution : This method is called once in constructor so overriding implementations
     * shouldn't be based on the state of their fields.
     */
    protected Preferences getPreferences() {
        if (this.preferences != null) {
            return this.preferences;
        } else {
            return Preferences.userNodeForPackage(FileUserPreferences.class);
        }
    }

    /**
     * Sets which action tip should be ignored.
     */
    @Override
    public void setActionTipIgnored(String actionKey) {
        this.ignoredActionTips.put(actionKey, true);
        super.setActionTipIgnored(actionKey);
    }

    /**
     * Returns whether an action tip should be ignored or not.
     */
    @Override
    public boolean isActionTipIgnored(String actionKey) {
        Boolean ignoredActionTip = this.ignoredActionTips.get(actionKey);
        return ignoredActionTip != null && ignoredActionTip.booleanValue();
    }

    /**
     * Resets the display flag of action tips.
     */
    @Override
    public void resetIgnoredActionTips() {
        for (Iterator<Map.Entry<String, Boolean>> it = this.ignoredActionTips.entrySet().iterator(); it.hasNext(); ) {
            Entry<String, Boolean> ignoredActionTipEntry = it.next();
            ignoredActionTipEntry.setValue(false);
        }
        super.resetIgnoredActionTips();
    }

    /**
     * Returns <code>true</code> if the given language library exists in the first
     * language libraries folder.
     */
    public boolean languageLibraryExists(String name) throws RecorderException {
        File[] languageLibrariesPluginFolders = getLanguageLibrariesPluginFolders();
        if (languageLibrariesPluginFolders == null || languageLibrariesPluginFolders.length == 0) {
            throw new RecorderException(""Can't access to language libraries plugin folder"");
        } else {
            String libraryFileName = new File(name).getName();
            return new File(languageLibrariesPluginFolders[0], libraryFileName).exists();
        }
    }

    /**
     * Adds <code>languageLibraryName</code> to the first language libraries folder
     * to make the language library it contains available to supported languages.
     */
    public void addLanguageLibrary(String languageLibraryName) throws RecorderException {
        try {
            File[] languageLibrariesPluginFolders = getLanguageLibrariesPluginFolders();
            if (languageLibrariesPluginFolders == null || languageLibrariesPluginFolders.length == 0) {
                throw new RecorderException(""Can't access to language libraries plugin folder"");
            }
            File languageLibraryFile = new File(languageLibraryName);
            copyToLibraryFolder(languageLibraryFile, languageLibrariesPluginFolders[0]);
            updateSupportedLanguages();
        } catch (IOException ex) {
            throw new RecorderException(""Can't write "" + languageLibraryName + "" in language libraries plugin folder"", ex);
        }
    }

    /**
     * Returns <code>true</code> if the given furniture library file exists in the first
     * furniture libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean furnitureLibraryExists(String name) throws RecorderException {
        File[] furnitureLibrariesPluginFolders = getFurnitureLibrariesPluginFolders();
        if (furnitureLibrariesPluginFolders == null || furnitureLibrariesPluginFolders.length == 0) {
            throw new RecorderException(""Can't access to furniture libraries plugin folder"");
        } else {
            String libraryFileName = new File(name).getName();
            return new File(furnitureLibrariesPluginFolders[0], libraryFileName).exists();
        }
    }

    /**
     * Adds the file <code>furnitureLibraryName</code> to the first furniture libraries folder
     * to make the furniture library available to catalog.
     */
    @Override
    public void addFurnitureLibrary(String furnitureLibraryName) throws RecorderException {
        try {
            File[] furnitureLibrariesPluginFolders = getFurnitureLibrariesPluginFolders();
            if (furnitureLibrariesPluginFolders == null || furnitureLibrariesPluginFolders.length == 0) {
                throw new RecorderException(""Can't access to furniture libraries plugin folder"");
            }
            copyToLibraryFolder(new File(furnitureLibraryName), furnitureLibrariesPluginFolders[0]);
            updateFurnitureDefaultCatalog(this.catalogsLoader, this.updater);
        } catch (IOException ex) {
            throw new RecorderException(""Can't write "" + furnitureLibraryName + "" in furniture libraries plugin folder"", ex);
        }
    }

    /**
     * Returns <code>true</code> if the given textures library file exists in the first textures libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean texturesLibraryExists(String name) throws RecorderException {
        File[] texturesLibrariesPluginFolders = getTexturesLibrariesPluginFolders();
        if (texturesLibrariesPluginFolders == null || texturesLibrariesPluginFolders.length == 0) {
            throw new RecorderException(""Can't access to textures libraries plugin folder"");
        } else {
            String libraryFileName = new File(name).getName();
            return new File(texturesLibrariesPluginFolders[0], libraryFileName).exists();
        }
    }

    /**
     * Adds the file <code>texturesLibraryName</code> to the first textures libraries folder
     * to make the textures library available to catalog.
     */
    @Override
    public void addTexturesLibrary(String texturesLibraryName) throws RecorderException {
        try {
            File[] texturesLibrariesPluginFolders = getTexturesLibrariesPluginFolders();
            if (texturesLibrariesPluginFolders == null || texturesLibrariesPluginFolders.length == 0) {
                throw new RecorderException(""Can't access to textures libraries plugin folder"");
            }
            copyToLibraryFolder(new File(texturesLibraryName), texturesLibrariesPluginFolders[0]);
            updateTexturesDefaultCatalog(this.catalogsLoader, this.updater);
        } catch (IOException ex) {
            throw new RecorderException(""Can't write "" + texturesLibraryName + "" in textures libraries plugin folder"", ex);
        }
    }

    /**
     * Copies a library file to a folder.
     */
    private void copyToLibraryFolder(File libraryFile, File folder) throws IOException {
        String libraryFileName = libraryFile.getName();
        File destinationFile = new File(folder, libraryFileName);
        if (destinationFile.exists()) {
            // Delete file to reinitialize handlers
            destinationFile.delete();
        }
        InputStream tempIn = null;
        OutputStream tempOut = null;
        try {
            tempIn = new BufferedInputStream(new FileInputStream(libraryFile));
            // Create folder if it doesn't exist
            folder.mkdirs();
            tempOut = new FileOutputStream(destinationFile);
            byte[] buffer = new byte[8192];
            int size;
            while ((size = tempIn.read(buffer)) != -1) {
                tempOut.write(buffer, 0, size);
            }
        } finally {
            if (tempIn != null) {
                tempIn.close();
            }
            if (tempOut != null) {
                tempOut.close();
            }
        }
    }

    /**
     * Preferences based on the <code>preferences.xml</code> file
     * stored in a preferences folder.
     * @author Emmanuel Puybaret
     */
    private class PortablePreferences extends AbstractPreferences {

        private static final String PREFERENCES_FILE = ""preferences.xml"";

        private Properties preferencesProperties;

        private boolean exist;

        private PortablePreferences() {
            super(null, """");
            this.preferencesProperties = new Properties();
            this.exist = readPreferences();
        }

        public boolean exist() {
            return this.exist;
        }

        @Override
        protected void syncSpi() throws BackingStoreException {
            this.preferencesProperties.clear();
            this.exist = readPreferences();
        }

        @Override
        protected void removeSpi(String key) {
            this.preferencesProperties.remove(key);
        }

        @Override
        protected void putSpi(String key, String value) {
            this.preferencesProperties.put(key, value);
        }

        @Override
        protected String[] keysSpi() throws BackingStoreException {
            return this.preferencesProperties.keySet().toArray(new String[0]);
        }

        @Override
        protected String getSpi(String key) {
            return (String) this.preferencesProperties.get(key);
        }

        @Override
        protected void flushSpi() throws BackingStoreException {
            try {
                writePreferences();
            } catch (IOException ex) {
                throw new BackingStoreException(ex);
            }
        }

        @Override
        protected void removeNodeSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected String[] childrenNamesSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected AbstractPreferences childSpi(String name) {
            throw new UnsupportedOperationException();
        }

        /**
         * Reads user preferences.
         */
        private boolean readPreferences() {
            InputStream in = null;
            try {
                in = new FileInputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.loadFromXML(in);
                return true;
            } catch (IOException ex) {
                // Preferences don't exist
                return false;
            } finally {
                try {
                    if (in != null) {
                        in.close();
                    }
                } catch (IOException ex) {
                    // Let default preferences unchanged
                }
            }
        }

        /**
         * Writes user preferences.
         */
        private void writePreferences() throws IOException {
            OutputStream out = null;
            try {
                checkPreferencesFolder();
                out = new FileOutputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.storeToXML(out, ""Portable user preferences 3.0"");
            } finally {
                if (out != null) {
                    out.close();
                    this.exist = true;
                }
            }
        }
    }
}
","// FileUserPreferences_3Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains one unit test case for the {@link FileUserPreferences#furnitureLibraryExists(String)} method.
*/
class FileUserPreferences_3Test {","// FileUserPreferences_3Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains one unit test case for the {@link FileUserPreferences#furnitureLibraryExists(String)} method.
*/
class FileUserPreferences_3Test {
"
3f377f73-cec4-4ccb-993f-29af1dc49d2e,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/io/FileUserPreferences_4Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FileUserPreferences.java
/*
 * FileUserPreferences.java 18 sept 2006
 *
 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;

/**
 * User preferences initialized from
 * {@link com.eteks.sweethome3d.io.DefaultUserPreferences default user preferences}
 * and stored in user preferences on local file system.
 * @author Emmanuel Puybaret
 */
public class FileUserPreferences extends UserPreferences {

    private static final String LANGUAGE = ""language"";

    private static final String UNIT = ""unit"";

    private static final String FURNITURE_CATALOG_VIEWED_IN_TREE = ""furnitureCatalogViewedInTree"";

    private static final String NAVIGATION_PANEL_VISIBLE = ""navigationPanelVisible"";

    private static final String MAGNETISM_ENABLED = ""magnetismEnabled"";

    private static final String RULERS_VISIBLE = ""rulersVisible"";

    private static final String GRID_VISIBLE = ""gridVisible"";

    private static final String FURNITURE_VIEWED_FROM_TOP = ""furnitureViewedFromTop"";

    private static final String ROOM_FLOOR_COLORED_OR_TEXTURED = ""roomFloorColoredOrTextured"";

    private static final String WALL_PATTERN = ""wallPattern"";

    private static final String NEW_WALL_HEIGHT = ""newHomeWallHeight"";

    private static final String NEW_WALL_THICKNESS = ""newWallThickness"";

    private static final String NEW_FLOOR_THICKNESS = ""newFloorThickness"";

    private static final String AUTO_SAVE_DELAY_FOR_RECOVERY = ""autoSaveDelayForRecovery"";

    private static final String AUTO_COMPLETION_PROPERTY = ""autoCompletionProperty#"";

    private static final String AUTO_COMPLETION_STRINGS = ""autoCompletionStrings#"";

    private static final String RECENT_HOMES = ""recentHomes#"";

    private static final String IGNORED_ACTION_TIP = ""ignoredActionTip#"";

    private static final String FURNITURE_NAME = ""furnitureName#"";

    private static final String FURNITURE_CATEGORY = ""furnitureCategory#"";

    private static final String FURNITURE_ICON = ""furnitureIcon#"";

    private static final String FURNITURE_MODEL = ""furnitureModel#"";

    private static final String FURNITURE_WIDTH = ""furnitureWidth#"";

    private static final String FURNITURE_DEPTH = ""furnitureDepth#"";

    private static final String FURNITURE_HEIGHT = ""furnitureHeight#"";

    private static final String FURNITURE_MOVABLE = ""furnitureMovable#"";

    private static final String FURNITURE_DOOR_OR_WINDOW = ""furnitureDoorOrWindow#"";

    private static final String FURNITURE_ELEVATION = ""furnitureElevation#"";

    private static final String FURNITURE_COLOR = ""furnitureColor#"";

    private static final String FURNITURE_MODEL_ROTATION = ""furnitureModelRotation#"";

    private static final String FURNITURE_STAIRCASE_CUT_OUT_SHAPE = ""furnitureStaircaseCutOutShape#"";

    private static final String FURNITURE_BACK_FACE_SHOWN = ""furnitureBackFaceShown#"";

    private static final String FURNITURE_ICON_YAW = ""furnitureIconYaw#"";

    private static final String FURNITURE_PROPORTIONAL = ""furnitureProportional#"";

    private static final String TEXTURE_NAME = ""textureName#"";

    private static final String TEXTURE_CATEGORY = ""textureCategory#"";

    private static final String TEXTURE_IMAGE = ""textureImage#"";

    private static final String TEXTURE_WIDTH = ""textureWidth#"";

    private static final String TEXTURE_HEIGHT = ""textureHeight#"";

    private static final String FURNITURE_CONTENT_PREFIX = ""Furniture-3-"";

    private static final String TEXTURE_CONTENT_PREFIX = ""Texture-3-"";

    private static final String LANGUAGE_LIBRARIES_PLUGIN_SUB_FOLDER = ""languages"";

    private static final String FURNITURE_LIBRARIES_PLUGIN_SUB_FOLDER = ""furniture"";

    private static final String TEXTURES_LIBRARIES_PLUGIN_SUB_FOLDER = ""textures"";

    private static final Content DUMMY_CONTENT;

    private final Map<String, Boolean> ignoredActionTips = new HashMap<String, Boolean>();

    private List<ClassLoader> resourceClassLoaders;

    private final File preferencesFolder;

    private final File[] applicationFolders;

    private Preferences preferences;

    private Executor catalogsLoader;

    private Executor updater;

    static {
        Content dummyURLContent = null;
        try {
            dummyURLContent = new URLContent(new URL(""file:/dummySweetHome3DContent""));
        } catch (MalformedURLException ex) {
        }
        DUMMY_CONTENT = dummyURLContent;
    }

    /**
     * Creates user preferences read from user preferences in file system,
     * and from resource files.
     */
    public FileUserPreferences() {
        this(null, null);
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders) {
        this(preferencesFolder, applicationFolders, null);
    }

    /**
     * Creates user preferences stored in the folders given in parameter.
     * @param preferencesFolder the folder where preferences files are stored
     *    or <code>null</code> if this folder is the default one.
     * @param applicationFolders  the folders where application private files are stored
     *    or <code>null</code> if it's the default one. As the first application folder
     *    is used as the folder where plug-ins files are imported by the user, it should
     *    have write access otherwise the user won't be able to import them.
     * @param updater  an executor that will be used to update user preferences for lengthy
     *    operations. If <code>null</code>, then these operations and
     *    updates will be executed in the current thread.
     */
    public FileUserPreferences(File preferencesFolder, File[] applicationFolders, Executor updater) {
        this.preferencesFolder = preferencesFolder;
        this.applicationFolders = applicationFolders;
        Executor defaultExecutor = new Executor() {

            public void execute(Runnable command) {
                command.run();
            }
        };
        if (updater == null) {
            this.catalogsLoader = this.updater = defaultExecutor;
        } else {
            this.catalogsLoader = Executors.newSingleThreadExecutor();
            this.updater = updater;
        }
        updateSupportedLanguages();
        final Preferences preferences;
        // From version 3.0 use portable preferences
        PortablePreferences portablePreferences = new PortablePreferences();
        // If portable preferences storage doesn't exist and default preferences folder is used
        if (!portablePreferences.exist() && preferencesFolder == null) {
            // Retrieve preferences from pre version 3.0
            preferences = getPreferences();
        } else {
            preferences = portablePreferences;
        }
        String language = preferences.get(LANGUAGE, getLanguage());
        // Check language is still supported
        if (!Arrays.asList(getSupportedLanguages()).contains(language)) {
            language = Locale.ENGLISH.getLanguage();
        }
        setLanguage(language);
        setFurnitureCatalog(new FurnitureCatalog());
        // Fill default furniture catalog
        updateFurnitureDefaultCatalog(defaultExecutor, defaultExecutor);
        // Read additional furniture
        readModifiableFurnitureCatalog(preferences);
        setTexturesCatalog(new TexturesCatalog());
        // Fill default textures catalog
        updateTexturesDefaultCatalog(defaultExecutor, defaultExecutor);
        // Read additional textures
        readModifiableTexturesCatalog(preferences);
        DefaultUserPreferences defaultPreferences = new DefaultUserPreferences(false, this);
        // Fill default patterns catalog
        PatternsCatalog patternsCatalog = defaultPreferences.getPatternsCatalog();
        setPatternsCatalog(patternsCatalog);
        // Read other preferences
        setUnit(LengthUnit.valueOf(preferences.get(UNIT, defaultPreferences.getLengthUnit().name())));
        setFurnitureCatalogViewedInTree(preferences.getBoolean(FURNITURE_CATALOG_VIEWED_IN_TREE, defaultPreferences.isFurnitureCatalogViewedInTree()));
        setNavigationPanelVisible(preferences.getBoolean(NAVIGATION_PANEL_VISIBLE, defaultPreferences.isNavigationPanelVisible()));
        setMagnetismEnabled(preferences.getBoolean(MAGNETISM_ENABLED, true));
        setRulersVisible(preferences.getBoolean(RULERS_VISIBLE, defaultPreferences.isRulersVisible()));
        setGridVisible(preferences.getBoolean(GRID_VISIBLE, defaultPreferences.isGridVisible()));
        setFurnitureViewedFromTop(preferences.getBoolean(FURNITURE_VIEWED_FROM_TOP, defaultPreferences.isFurnitureViewedFromTop()));
        setFloorColoredOrTextured(preferences.getBoolean(ROOM_FLOOR_COLORED_OR_TEXTURED, defaultPreferences.isRoomFloorColoredOrTextured()));
        try {
            setWallPattern(patternsCatalog.getPattern(preferences.get(WALL_PATTERN, defaultPreferences.getWallPattern().getName())));
        } catch (IllegalArgumentException ex) {
            // Ensure wall pattern always exists even if new patterns are added in future versions
            setWallPattern(defaultPreferences.getWallPattern());
        }
        setNewWallThickness(preferences.getFloat(NEW_WALL_THICKNESS, defaultPreferences.getNewWallThickness()));
        setNewWallHeight(preferences.getFloat(NEW_WALL_HEIGHT, defaultPreferences.getNewWallHeight()));
        setNewFloorThickness(preferences.getFloat(NEW_FLOOR_THICKNESS, defaultPreferences.getNewFloorThickness()));
        setAutoSaveDelayForRecovery(preferences.getInt(AUTO_SAVE_DELAY_FOR_RECOVERY, defaultPreferences.getAutoSaveDelayForRecovery()));
        setCurrency(defaultPreferences.getCurrency());
        // Read recent homes list
        List<String> recentHomes = new ArrayList<String>();
        for (int i = 1; i <= getRecentHomesMaxCount(); i++) {
            String recentHome = preferences.get(RECENT_HOMES + i, null);
            if (recentHome != null) {
                recentHomes.add(recentHome);
            }
        }
        setRecentHomes(recentHomes);
        // Read ignored action tips
        for (int i = 1; ; i++) {
            String ignoredActionTip = preferences.get(IGNORED_ACTION_TIP + i, """");
            if (ignoredActionTip.length() == 0) {
                break;
            } else {
                this.ignoredActionTips.put(ignoredActionTip, true);
            }
        }
        // Get default auto completion strings
        for (String property : defaultPreferences.getAutoCompletedProperties()) {
            setAutoCompletionStrings(property, defaultPreferences.getAutoCompletionStrings(property));
        }
        // Read auto completion strings list
        for (int i = 1; ; i++) {
            String autoCompletionProperty = preferences.get(AUTO_COMPLETION_PROPERTY + i, null);
            String autoCompletionStrings = preferences.get(AUTO_COMPLETION_STRINGS + i, null);
            if (autoCompletionProperty != null && autoCompletionStrings != null) {
                setAutoCompletionStrings(autoCompletionProperty, Arrays.asList(autoCompletionStrings.split("","")));
            } else {
                break;
            }
        }
        addPropertyChangeListener(Property.LANGUAGE, new PropertyChangeListener() {

            public void propertyChange(PropertyChangeEvent ev) {
                // Update catalogs with new default locale
                updateFurnitureDefaultCatalog(catalogsLoader, FileUserPreferences.this.updater);
                updateTexturesDefaultCatalog(catalogsLoader, FileUserPreferences.this.updater);
                updateAutoCompletionStrings();
            }
        });
        if (preferences != portablePreferences) {
            // Switch to portable preferences now that all preferences are read
            this.preferences = portablePreferences;
        } else {
            this.preferences = preferences;
        }
    }

    /**
     * Updates the default supported languages with languages available in plugin folder.
     */
    private void updateSupportedLanguages() {
        List<ClassLoader> resourceClassLoaders = new ArrayList<ClassLoader>();
        String[] defaultSupportedLanguages = getDefaultSupportedLanguages();
        Set<String> supportedLanguages = new TreeSet<String>(Arrays.asList(defaultSupportedLanguages));
        File[] languageLibrariesPluginFolders = getLanguageLibrariesPluginFolders();
        if (languageLibrariesPluginFolders != null) {
            for (File languageLibrariesPluginFolder : languageLibrariesPluginFolders) {
                // Try to load sh3l files from language plugin folder
                File[] pluginLanguageLibraryFiles = languageLibrariesPluginFolder.listFiles(new FileFilter() {

                    public boolean accept(File pathname) {
                        return pathname.isFile();
                    }
                });
                if (pluginLanguageLibraryFiles != null) {
                    // Treat language files in reverse order so file named with a date or a version
                    // will be taken into account from most recent to least recent
                    Arrays.sort(pluginLanguageLibraryFiles, Collections.reverseOrder());
                    for (File pluginLanguageLibraryFile : pluginLanguageLibraryFiles) {
                        try {
                            Set<String> languages = getLanguages(pluginLanguageLibraryFile);
                            if (!languages.isEmpty()) {
                                supportedLanguages.addAll(languages);
                                URL pluginFurnitureCatalogUrl = pluginLanguageLibraryFile.toURI().toURL();
                                resourceClassLoaders.add(new URLClassLoader(new URL[] { pluginFurnitureCatalogUrl }));
                            }
                        } catch (IOException ex) {
                            // Ignore malformed files
                        }
                    }
                }
            }
        }
        // Give less priority to default class loader
        resourceClassLoaders.addAll(super.getResourceClassLoaders());
        this.resourceClassLoaders = Collections.unmodifiableList(resourceClassLoaders);
        if (defaultSupportedLanguages.length < supportedLanguages.size()) {
            setSupportedLanguages(supportedLanguages.toArray(new String[supportedLanguages.size()]));
        }
    }

    /**
     * Returns the languages included in the given language library file.
     */
    private Set<String> getLanguages(File languageLibraryFile) throws IOException {
        Set<String> languages = new LinkedHashSet<String>();
        ZipInputStream zipIn = null;
        try {
            // Search if zip file contains some *_xx.properties or *_xx_xx.properties files
            zipIn = new ZipInputStream(new FileInputStream(languageLibraryFile));
            for (ZipEntry entry; (entry = zipIn.getNextEntry()) != null; ) {
                String zipEntryName = entry.getName();
                int underscoreIndex = zipEntryName.indexOf('_');
                if (underscoreIndex != -1) {
                    int extensionIndex = zipEntryName.lastIndexOf("".properties"");
                    if (extensionIndex != -1 && underscoreIndex < extensionIndex - 2) {
                        String language = zipEntryName.substring(underscoreIndex + 1, extensionIndex);
                        int countrySeparator = language.indexOf('_');
                        if (countrySeparator == 2 && language.length() == 5) {
                            languages.add(language);
                        } else if (language.length() == 2) {
                            languages.add(language);
                        }
                    }
                }
            }
            return languages;
        } finally {
            if (zipIn != null) {
                zipIn.close();
            }
        }
    }

    /**
     * Returns the default class loader of user preferences and the class loaders that
     * give access to resources in language libraries plugin folder.
     */
    @Override
    public List<ClassLoader> getResourceClassLoaders() {
        return this.resourceClassLoaders;
    }

    /**
     * Reloads furniture default catalogs.
     */
    private void updateFurnitureDefaultCatalog(Executor furnitureCatalogLoader, final Executor updater) {
        // Delete default pieces of current furniture catalog
        final FurnitureCatalog furnitureCatalog = getFurnitureCatalog();
        for (FurnitureCategory category : furnitureCatalog.getCategories()) {
            for (CatalogPieceOfFurniture piece : category.getFurniture()) {
                if (!piece.isModifiable()) {
                    furnitureCatalog.delete(piece);
                }
            }
        }
        // Read default furniture catalog
        furnitureCatalogLoader.execute(new Runnable() {

            public void run() {
                // Fill default furniture catalog
                DefaultFurnitureCatalog defaultFurnitureCatalog = new DefaultFurnitureCatalog(FileUserPreferences.this, getFurnitureLibrariesPluginFolders());
                for (final FurnitureCategory category : defaultFurnitureCatalog.getCategories()) {
                    for (final CatalogPieceOfFurniture piece : category.getFurniture()) {
                        updater.execute(new Runnable() {

                            public void run() {
                                furnitureCatalog.add(category, piece);
                            }
                        });
                    }
                }
            }
        });
    }

    /**
     * Reloads textures default catalog.
     */
    private void updateTexturesDefaultCatalog(Executor texturesCatalogLoader, final Executor updater) {
        // Delete default textures of current textures catalog
        final TexturesCatalog texturesCatalog = getTexturesCatalog();
        for (TexturesCategory category : texturesCatalog.getCategories()) {
            for (CatalogTexture texture : category.getTextures()) {
                if (!texture.isModifiable()) {
                    texturesCatalog.delete(texture);
                }
            }
        }
        // Read default textures catalog
        texturesCatalogLoader.execute(new Runnable() {

            public void run() {
                TexturesCatalog defaultTexturesCatalog = new DefaultTexturesCatalog(FileUserPreferences.this, getTexturesLibrariesPluginFolders());
                for (final TexturesCategory category : defaultTexturesCatalog.getCategories()) {
                    for (final CatalogTexture texture : category.getTextures()) {
                        updater.execute(new Runnable() {

                            public void run() {
                                texturesCatalog.add(category, texture);
                            }
                        });
                    }
                }
            }
        });
    }

    /**
     * Adds to auto completion strings the default strings of the new chosen language.
     */
    private void updateAutoCompletionStrings() {
        DefaultUserPreferences defaultPreferences = new DefaultUserPreferences(false, this);
        for (String property : defaultPreferences.getAutoCompletedProperties()) {
            for (String autoCompletionString : defaultPreferences.getAutoCompletionStrings(property)) {
                addAutoCompletionString(property, autoCompletionString);
            }
        }
    }

    /**
     * Read modifiable furniture catalog from preferences.
     */
    private void readModifiableFurnitureCatalog(Preferences preferences) {
        for (int i = 1; ; i++) {
            String name = preferences.get(FURNITURE_NAME + i, null);
            if (name == null) {
                // Stop the loop when a key furnitureName# doesn't exist
                break;
            }
            String category = preferences.get(FURNITURE_CATEGORY + i, """");
            Content icon = getContent(preferences, FURNITURE_ICON + i);
            Content model = getContent(preferences, FURNITURE_MODEL + i);
            float width = preferences.getFloat(FURNITURE_WIDTH + i, 0.1f);
            float depth = preferences.getFloat(FURNITURE_DEPTH + i, 0.1f);
            float height = preferences.getFloat(FURNITURE_HEIGHT + i, 0.1f);
            boolean movable = preferences.getBoolean(FURNITURE_MOVABLE + i, false);
            boolean doorOrWindow = preferences.getBoolean(FURNITURE_DOOR_OR_WINDOW + i, false);
            float elevation = preferences.getFloat(FURNITURE_ELEVATION + i, 0);
            String colorString = preferences.get(FURNITURE_COLOR + i, null);
            Integer color = colorString != null ? Integer.valueOf(colorString) : null;
            float[][] modelRotation = getModelRotation(preferences, FURNITURE_MODEL_ROTATION + i);
            String staircaseCutOutShape = preferences.get(FURNITURE_STAIRCASE_CUT_OUT_SHAPE + i, null);
            boolean backFaceShown = preferences.getBoolean(FURNITURE_BACK_FACE_SHOWN + i, false);
            float iconYaw = preferences.getFloat(FURNITURE_ICON_YAW + i, 0);
            boolean proportional = preferences.getBoolean(FURNITURE_PROPORTIONAL + i, true);
            final FurnitureCategory pieceCategory = new FurnitureCategory(category);
            final CatalogPieceOfFurniture piece;
            if (doorOrWindow) {
                piece = new CatalogDoorOrWindow(name, icon, model, width, depth, height, elevation, movable, 1, 0, new Sash[0], color, modelRotation, backFaceShown, iconYaw, proportional);
            } else {
                piece = new CatalogPieceOfFurniture(name, icon, model, width, depth, height, elevation, movable, staircaseCutOutShape, color, modelRotation, backFaceShown, iconYaw, proportional);
            }
            getFurnitureCatalog().add(pieceCategory, piece);
        }
    }

    /**
     * Returns model rotation parsed from key value.
     */
    private float[][] getModelRotation(Preferences preferences, String key) {
        String modelRotationString = preferences.get(key, null);
        if (modelRotationString == null) {
            return new float[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
        } else {
            String[] values = modelRotationString.split("" "", 9);
            if (values.length != 9) {
                return new float[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
            } else {
                try {
                    return new float[][] { { Float.parseFloat(values[0]), Float.parseFloat(values[1]), Float.parseFloat(values[2]) }, { Float.parseFloat(values[3]), Float.parseFloat(values[4]), Float.parseFloat(values[5]) }, { Float.parseFloat(values[6]), Float.parseFloat(values[7]), Float.parseFloat(values[8]) } };
                } catch (NumberFormatException ex) {
                    return new float[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
                }
            }
        }
    }

    /**
     * Returns a content instance from the resource file value of key.
     */
    private Content getContent(Preferences preferences, String key) {
        String content = preferences.get(key, null);
        if (content != null) {
            try {
                String preferencesFolderUrl = getPreferencesFolder().toURI().toURL().toString();
                if (content.startsWith(preferencesFolderUrl) || content.startsWith(""jar:"" + preferencesFolderUrl)) {
                    return new URLContent(new URL(content));
                } else {
                    return new URLContent(new URL(content.replace(""file:"", preferencesFolderUrl)));
                }
            } catch (IOException ex) {
                // Return DUMMY_CONTENT for incorrect URL
            }
        }
        return DUMMY_CONTENT;
    }

    /**
     * Read modifiable textures catalog from preferences.
     */
    private void readModifiableTexturesCatalog(Preferences preferences) {
        for (int i = 1; ; i++) {
            String name = preferences.get(TEXTURE_NAME + i, null);
            if (name == null) {
                // Stop the loop when a key textureName# doesn't exist
                break;
            }
            String category = preferences.get(TEXTURE_CATEGORY + i, """");
            Content image = getContent(preferences, TEXTURE_IMAGE + i);
            float width = preferences.getFloat(TEXTURE_WIDTH + i, 0.1f);
            float height = preferences.getFloat(TEXTURE_HEIGHT + i, 0.1f);
            final TexturesCategory textureCategory = new TexturesCategory(category);
            final CatalogTexture texture = new CatalogTexture(name, image, width, height, true);
            getTexturesCatalog().add(textureCategory, texture);
        }
    }

    /**
     * Writes user preferences in current user preferences in system.
     */
    @Override
    public void write() throws RecorderException {
        Preferences preferences = getPreferences();
        writeModifiableFurnitureCatalog(preferences);
        writeModifiableTexturesCatalog(preferences);
        // Write other preferences
        preferences.put(LANGUAGE, getLanguage());
        preferences.put(UNIT, getLengthUnit().name());
        preferences.putBoolean(FURNITURE_CATALOG_VIEWED_IN_TREE, isFurnitureCatalogViewedInTree());
        preferences.putBoolean(NAVIGATION_PANEL_VISIBLE, isNavigationPanelVisible());
        preferences.putBoolean(MAGNETISM_ENABLED, isMagnetismEnabled());
        preferences.putBoolean(RULERS_VISIBLE, isRulersVisible());
        preferences.putBoolean(GRID_VISIBLE, isGridVisible());
        preferences.putBoolean(FURNITURE_VIEWED_FROM_TOP, isFurnitureViewedFromTop());
        preferences.putBoolean(ROOM_FLOOR_COLORED_OR_TEXTURED, isRoomFloorColoredOrTextured());
        preferences.put(WALL_PATTERN, getWallPattern().getName());
        preferences.putFloat(NEW_WALL_THICKNESS, getNewWallThickness());
        preferences.putFloat(NEW_WALL_HEIGHT, getNewWallHeight());
        preferences.putFloat(NEW_FLOOR_THICKNESS, getNewFloorThickness());
        preferences.putInt(AUTO_SAVE_DELAY_FOR_RECOVERY, getAutoSaveDelayForRecovery());
        // Write recent homes list
        int i = 1;
        for (Iterator<String> it = getRecentHomes().iterator(); it.hasNext() && i <= getRecentHomesMaxCount(); i++) {
            preferences.put(RECENT_HOMES + i, it.next());
        }
        // Remove obsolete keys
        for (; i <= getRecentHomesMaxCount(); i++) {
            preferences.remove(RECENT_HOMES + i);
        }
        // Write ignored action tips
        i = 1;
        for (Iterator<Map.Entry<String, Boolean>> it = this.ignoredActionTips.entrySet().iterator(); it.hasNext(); ) {
            Entry<String, Boolean> ignoredActionTipEntry = it.next();
            if (ignoredActionTipEntry.getValue()) {
                preferences.put(IGNORED_ACTION_TIP + i++, ignoredActionTipEntry.getKey());
            }
        }
        // Remove obsolete keys
        for (; i <= this.ignoredActionTips.size(); i++) {
            preferences.remove(IGNORED_ACTION_TIP + i);
        }
        // Write auto completion strings lists
        i = 1;
        for (String property : getAutoCompletedProperties()) {
            StringBuilder autoCompletionStrings = new StringBuilder();
            Iterator<String> it = getAutoCompletionStrings(property).iterator();
            for (int j = 0; j < 1000 && it.hasNext(); j++) {
                String autoCompletionString = it.next();
                // As strings are comma separated, accept only the ones without a comma
                if (autoCompletionString.indexOf(',') < 0) {
                    if (autoCompletionStrings.length() > 0) {
                        autoCompletionStrings.append("","");
                    }
                    autoCompletionStrings.append(autoCompletionString);
                }
            }
            preferences.put(AUTO_COMPLETION_PROPERTY + i, property);
            preferences.put(AUTO_COMPLETION_STRINGS + i++, autoCompletionStrings.toString());
        }
        for (; preferences.get(AUTO_COMPLETION_PROPERTY + i, null) != null; i++) {
            preferences.remove(AUTO_COMPLETION_PROPERTY + i);
            preferences.remove(AUTO_COMPLETION_STRINGS + i);
        }
        try {
            // Write preferences
            preferences.flush();
        } catch (BackingStoreException ex) {
            throw new RecorderException(""Couldn't write preferences"", ex);
        }
    }

    /**
     * Writes modifiable furniture in <code>preferences</code>.
     */
    private void writeModifiableFurnitureCatalog(Preferences preferences) throws RecorderException {
        final Set<URL> furnitureContentURLs = new HashSet<URL>();
        int i = 1;
        for (FurnitureCategory category : getFurnitureCatalog().getCategories()) {
            for (CatalogPieceOfFurniture piece : category.getFurniture()) {
                if (piece.isModifiable()) {
                    preferences.put(FURNITURE_NAME + i, piece.getName());
                    preferences.put(FURNITURE_CATEGORY + i, category.getName());
                    putContent(preferences, FURNITURE_ICON + i, piece.getIcon(), FURNITURE_CONTENT_PREFIX, furnitureContentURLs);
                    putContent(preferences, FURNITURE_MODEL + i, piece.getModel(), FURNITURE_CONTENT_PREFIX, furnitureContentURLs);
                    preferences.putFloat(FURNITURE_WIDTH + i, piece.getWidth());
                    preferences.putFloat(FURNITURE_DEPTH + i, piece.getDepth());
                    preferences.putFloat(FURNITURE_HEIGHT + i, piece.getHeight());
                    preferences.putBoolean(FURNITURE_MOVABLE + i, piece.isMovable());
                    preferences.putBoolean(FURNITURE_DOOR_OR_WINDOW + i, piece.isDoorOrWindow());
                    preferences.putFloat(FURNITURE_ELEVATION + i, piece.getElevation());
                    if (piece.getColor() == null) {
                        preferences.remove(FURNITURE_COLOR + i);
                    } else {
                        preferences.put(FURNITURE_COLOR + i, String.valueOf(piece.getColor()));
                    }
                    float[][] modelRotation = piece.getModelRotation();
                    preferences.put(FURNITURE_MODEL_ROTATION + i, floatToString(modelRotation[0][0]) + "" "" + floatToString(modelRotation[0][1]) + "" "" + floatToString(modelRotation[0][2]) + "" "" + floatToString(modelRotation[1][0]) + "" "" + floatToString(modelRotation[1][1]) + "" "" + floatToString(modelRotation[1][2]) + "" "" + floatToString(modelRotation[2][0]) + "" "" + floatToString(modelRotation[2][1]) + "" "" + floatToString(modelRotation[2][2]));
                    if (piece.getStaircaseCutOutShape() != null) {
                        preferences.put(FURNITURE_STAIRCASE_CUT_OUT_SHAPE + i, piece.getStaircaseCutOutShape());
                    }
                    preferences.putBoolean(FURNITURE_BACK_FACE_SHOWN + i, piece.isBackFaceShown());
                    preferences.putFloat(FURNITURE_ICON_YAW + i, piece.getIconYaw());
                    preferences.putBoolean(FURNITURE_PROPORTIONAL + i, piece.isProportional());
                    i++;
                }
            }
        }
        // Remove obsolete keys
        for (; preferences.get(FURNITURE_NAME + i, null) != null; i++) {
            preferences.remove(FURNITURE_NAME + i);
            preferences.remove(FURNITURE_CATEGORY + i);
            preferences.remove(FURNITURE_ICON + i);
            preferences.remove(FURNITURE_MODEL + i);
            preferences.remove(FURNITURE_WIDTH + i);
            preferences.remove(FURNITURE_DEPTH + i);
            preferences.remove(FURNITURE_HEIGHT + i);
            preferences.remove(FURNITURE_MOVABLE + i);
            preferences.remove(FURNITURE_DOOR_OR_WINDOW + i);
            preferences.remove(FURNITURE_ELEVATION + i);
            preferences.remove(FURNITURE_COLOR + i);
            preferences.remove(FURNITURE_MODEL_ROTATION + i);
            preferences.remove(FURNITURE_STAIRCASE_CUT_OUT_SHAPE + i);
            preferences.remove(FURNITURE_BACK_FACE_SHOWN + i);
            preferences.remove(FURNITURE_ICON_YAW + i);
            preferences.remove(FURNITURE_PROPORTIONAL + i);
        }
        deleteObsoleteContent(furnitureContentURLs, FURNITURE_CONTENT_PREFIX);
    }

    /**
     * Returns the string value of the given float, except for -1.0, 1.0 or 0.0 where -1, 1 and 0 is returned.
     */
    private String floatToString(float f) {
        if (Math.abs(f) < 1E-6) {
            return ""0"";
        } else if (Math.abs(f - 1f) < 1E-6) {
            return ""1"";
        } else if (Math.abs(f + 1f) < 1E-6) {
            return ""-1"";
        } else {
            return String.valueOf(f);
        }
    }

    /**
     * Writes modifiable textures catalog in <code>preferences</code>.
     */
    private void writeModifiableTexturesCatalog(Preferences preferences) throws RecorderException {
        final Set<URL> texturesContentURLs = new HashSet<URL>();
        int i = 1;
        for (TexturesCategory category : getTexturesCatalog().getCategories()) {
            for (CatalogTexture texture : category.getTextures()) {
                if (texture.isModifiable()) {
                    preferences.put(TEXTURE_NAME + i, texture.getName());
                    preferences.put(TEXTURE_CATEGORY + i, category.getName());
                    putContent(preferences, TEXTURE_IMAGE + i, texture.getImage(), TEXTURE_CONTENT_PREFIX, texturesContentURLs);
                    preferences.putFloat(TEXTURE_WIDTH + i, texture.getWidth());
                    preferences.putFloat(TEXTURE_HEIGHT + i, texture.getHeight());
                    i++;
                }
            }
        }
        // Remove obsolete keys
        for (; preferences.get(TEXTURE_NAME + i, null) != null; i++) {
            preferences.remove(TEXTURE_NAME + i);
            preferences.remove(TEXTURE_CATEGORY + i);
            preferences.remove(TEXTURE_IMAGE + i);
            preferences.remove(TEXTURE_WIDTH + i);
            preferences.remove(TEXTURE_HEIGHT + i);
        }
        deleteObsoleteContent(texturesContentURLs, TEXTURE_CONTENT_PREFIX);
    }

    /**
     * Writes <code>key</code> <code>content</code> in <code>preferences</code>.
     */
    private void putContent(Preferences preferences, String key, Content content, String contentPrefix, Set<URL> furnitureContentURLs) throws RecorderException {
        if (content instanceof TemporaryURLContent) {
            URLContent urlContent = (URLContent) content;
            URLContent copiedContent;
            if (urlContent.isJAREntry()) {
                try {
                    // If content is a JAR entry copy the content of its URL and rebuild a new URL content from
                    // this copy and the entry name
                    copiedContent = copyToPreferencesURLContent(new URLContent(urlContent.getJAREntryURL()), contentPrefix);
                    copiedContent = new URLContent(new URL(""jar:"" + copiedContent.getURL() + ""!/"" + urlContent.getJAREntryName()));
                } catch (MalformedURLException ex) {
                    // Shouldn't happen
                    throw new RecorderException(""Can't build URL"", ex);
                }
            } else {
                copiedContent = copyToPreferencesURLContent(urlContent, contentPrefix);
            }
            putContent(preferences, key, copiedContent, contentPrefix, furnitureContentURLs);
        } else if (content instanceof URLContent) {
            URLContent urlContent = (URLContent) content;
            try {
                preferences.put(key, urlContent.getURL().toString().replace(getPreferencesFolder().toURI().toURL().toString(), ""file:""));
            } catch (IOException ex) {
                throw new RecorderException(""Can't save content"", ex);
            }
            // Add to furnitureContentURLs the URL to the application file
            if (urlContent.isJAREntry()) {
                furnitureContentURLs.add(urlContent.getJAREntryURL());
            } else {
                furnitureContentURLs.add(urlContent.getURL());
            }
        } else {
            putContent(preferences, key, copyToPreferencesURLContent(content, contentPrefix), contentPrefix, furnitureContentURLs);
        }
    }

    /**
     * Returns a content object that references a copy of <code>content</code> in
     * user preferences folder.
     */
    private URLContent copyToPreferencesURLContent(Content content, String contentPrefix) throws RecorderException {
        InputStream tempIn = null;
        OutputStream tempOut = null;
        try {
            File preferencesFile = createPreferencesFile(contentPrefix);
            tempIn = content.openStream();
            tempOut = new FileOutputStream(preferencesFile);
            byte[] buffer = new byte[8192];
            int size;
            while ((size = tempIn.read(buffer)) != -1) {
                tempOut.write(buffer, 0, size);
            }
            return new URLContent(preferencesFile.toURI().toURL());
        } catch (IOException ex) {
            throw new RecorderException(""Can't save content"", ex);
        } finally {
            try {
                if (tempIn != null) {
                    tempIn.close();
                }
                if (tempOut != null) {
                    tempOut.close();
                }
            } catch (IOException ex) {
                throw new RecorderException(""Can't close files"", ex);
            }
        }
    }

    /**
     * Returns the folder where language libraries files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getLanguageLibrariesPluginFolders() {
        try {
            return getApplicationSubfolders(LANGUAGE_LIBRARIES_PLUGIN_SUB_FOLDER);
        } catch (IOException ex) {
            return null;
        }
    }

    /**
     * Returns the folder where furniture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getFurnitureLibrariesPluginFolders() {
        try {
            return getApplicationSubfolders(FURNITURE_LIBRARIES_PLUGIN_SUB_FOLDER);
        } catch (IOException ex) {
            return null;
        }
    }

    /**
     * Returns the folder where texture catalog files must be placed
     * or <code>null</code> if that folder can't be retrieved.
     */
    private File[] getTexturesLibrariesPluginFolders() {
        try {
            return getApplicationSubfolders(TEXTURES_LIBRARIES_PLUGIN_SUB_FOLDER);
        } catch (IOException ex) {
            return null;
        }
    }

    /**
     * Returns the first Sweet Home 3D application folder.
     */
    public File getApplicationFolder() throws IOException {
        File[] applicationFolders = getApplicationFolders();
        if (applicationFolders.length == 0) {
            throw new IOException(""No application folder defined"");
        } else {
            return applicationFolders[0];
        }
    }

    /**
     * Returns Sweet Home 3D application folders.
     */
    public File[] getApplicationFolders() throws IOException {
        if (this.applicationFolders != null) {
            return this.applicationFolders;
        } else {
            return new File[] { OperatingSystem.getDefaultApplicationFolder() };
        }
    }

    /**
     * Returns subfolders of Sweet Home 3D application folders of a given name.
     */
    public File[] getApplicationSubfolders(String subfolder) throws IOException {
        File[] applicationFolders = getApplicationFolders();
        File[] applicationSubfolders = new File[applicationFolders.length];
        for (int i = 0; i < applicationFolders.length; i++) {
            applicationSubfolders[i] = new File(applicationFolders[i], subfolder);
        }
        return applicationSubfolders;
    }

    /**
     * Returns a new file in user preferences folder.
     */
    private File createPreferencesFile(String filePrefix) throws IOException {
        checkPreferencesFolder();
        // Return a new file in preferences folder
        return File.createTempFile(filePrefix, "".pref"", getPreferencesFolder());
    }

    /**
     * Creates preferences folder and its sub folders if it doesn't exist.
     */
    private void checkPreferencesFolder() throws IOException {
        File preferencesFolder = getPreferencesFolder();
        // Create preferences folder if it doesn't exist
        if (!preferencesFolder.exists() && !preferencesFolder.mkdirs()) {
            throw new IOException(""Couldn't create "" + preferencesFolder);
        }
        checkPreferencesSubFolder(getLanguageLibrariesPluginFolders());
        checkPreferencesSubFolder(getFurnitureLibrariesPluginFolders());
        checkPreferencesSubFolder(getTexturesLibrariesPluginFolders());
    }

    /**
     * Creates the first folder in the given folders.
     */
    private void checkPreferencesSubFolder(File[] librariesPluginFolders) {
        if (librariesPluginFolders != null && librariesPluginFolders.length > 0 && !librariesPluginFolders[0].exists()) {
            librariesPluginFolders[0].mkdirs();
        }
    }

    /**
     * Deletes from application folder the content files starting by <code>contentPrefix</code>
     * that don't belong to <code>contentURLs</code>.
     */
    private void deleteObsoleteContent(final Set<URL> contentURLs, final String contentPrefix) throws RecorderException {
        // Search obsolete contents
        File applicationFolder;
        try {
            applicationFolder = getPreferencesFolder();
        } catch (IOException ex) {
            throw new RecorderException(""Can't access to application folder"");
        }
        File[] obsoleteContentFiles = applicationFolder.listFiles(new FileFilter() {

            public boolean accept(File applicationFile) {
                try {
                    URL toURL = applicationFile.toURI().toURL();
                    return applicationFile.getName().startsWith(contentPrefix) && !contentURLs.contains(toURL);
                } catch (MalformedURLException ex) {
                    return false;
                }
            }
        });
        if (obsoleteContentFiles != null) {
            // Delete obsolete contents at program exit to ensure removed contents
            // can still be saved in homes that reference them
            for (File file : obsoleteContentFiles) {
                file.deleteOnExit();
            }
        }
    }

    /**
     * Returns the folder where files depending on preferences are stored.
     */
    private File getPreferencesFolder() throws IOException {
        if (this.preferencesFolder != null) {
            return this.preferencesFolder;
        } else {
            return OperatingSystem.getDefaultApplicationFolder();
        }
    }

    /**
     * Returns default Java preferences for current system user.
     * Caution : This method is called once in constructor so overriding implementations
     * shouldn't be based on the state of their fields.
     */
    protected Preferences getPreferences() {
        if (this.preferences != null) {
            return this.preferences;
        } else {
            return Preferences.userNodeForPackage(FileUserPreferences.class);
        }
    }

    /**
     * Sets which action tip should be ignored.
     */
    @Override
    public void setActionTipIgnored(String actionKey) {
        this.ignoredActionTips.put(actionKey, true);
        super.setActionTipIgnored(actionKey);
    }

    /**
     * Returns whether an action tip should be ignored or not.
     */
    @Override
    public boolean isActionTipIgnored(String actionKey) {
        Boolean ignoredActionTip = this.ignoredActionTips.get(actionKey);
        return ignoredActionTip != null && ignoredActionTip.booleanValue();
    }

    /**
     * Resets the display flag of action tips.
     */
    @Override
    public void resetIgnoredActionTips() {
        for (Iterator<Map.Entry<String, Boolean>> it = this.ignoredActionTips.entrySet().iterator(); it.hasNext(); ) {
            Entry<String, Boolean> ignoredActionTipEntry = it.next();
            ignoredActionTipEntry.setValue(false);
        }
        super.resetIgnoredActionTips();
    }

    /**
     * Returns <code>true</code> if the given language library exists in the first
     * language libraries folder.
     */
    public boolean languageLibraryExists(String name) throws RecorderException {
        File[] languageLibrariesPluginFolders = getLanguageLibrariesPluginFolders();
        if (languageLibrariesPluginFolders == null || languageLibrariesPluginFolders.length == 0) {
            throw new RecorderException(""Can't access to language libraries plugin folder"");
        } else {
            String libraryFileName = new File(name).getName();
            return new File(languageLibrariesPluginFolders[0], libraryFileName).exists();
        }
    }

    /**
     * Adds <code>languageLibraryName</code> to the first language libraries folder
     * to make the language library it contains available to supported languages.
     */
    public void addLanguageLibrary(String languageLibraryName) throws RecorderException {
        try {
            File[] languageLibrariesPluginFolders = getLanguageLibrariesPluginFolders();
            if (languageLibrariesPluginFolders == null || languageLibrariesPluginFolders.length == 0) {
                throw new RecorderException(""Can't access to language libraries plugin folder"");
            }
            File languageLibraryFile = new File(languageLibraryName);
            copyToLibraryFolder(languageLibraryFile, languageLibrariesPluginFolders[0]);
            updateSupportedLanguages();
        } catch (IOException ex) {
            throw new RecorderException(""Can't write "" + languageLibraryName + "" in language libraries plugin folder"", ex);
        }
    }

    /**
     * Returns <code>true</code> if the given furniture library file exists in the first
     * furniture libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean furnitureLibraryExists(String name) throws RecorderException {
        File[] furnitureLibrariesPluginFolders = getFurnitureLibrariesPluginFolders();
        if (furnitureLibrariesPluginFolders == null || furnitureLibrariesPluginFolders.length == 0) {
            throw new RecorderException(""Can't access to furniture libraries plugin folder"");
        } else {
            String libraryFileName = new File(name).getName();
            return new File(furnitureLibrariesPluginFolders[0], libraryFileName).exists();
        }
    }

    /**
     * Adds the file <code>furnitureLibraryName</code> to the first furniture libraries folder
     * to make the furniture library available to catalog.
     */
    @Override
    public void addFurnitureLibrary(String furnitureLibraryName) throws RecorderException {
        try {
            File[] furnitureLibrariesPluginFolders = getFurnitureLibrariesPluginFolders();
            if (furnitureLibrariesPluginFolders == null || furnitureLibrariesPluginFolders.length == 0) {
                throw new RecorderException(""Can't access to furniture libraries plugin folder"");
            }
            copyToLibraryFolder(new File(furnitureLibraryName), furnitureLibrariesPluginFolders[0]);
            updateFurnitureDefaultCatalog(this.catalogsLoader, this.updater);
        } catch (IOException ex) {
            throw new RecorderException(""Can't write "" + furnitureLibraryName + "" in furniture libraries plugin folder"", ex);
        }
    }

    /**
     * Returns <code>true</code> if the given textures library file exists in the first textures libraries folder.
     * @param name the name of the resource to check
     */
    @Override
    public boolean texturesLibraryExists(String name) throws RecorderException {
        File[] texturesLibrariesPluginFolders = getTexturesLibrariesPluginFolders();
        if (texturesLibrariesPluginFolders == null || texturesLibrariesPluginFolders.length == 0) {
            throw new RecorderException(""Can't access to textures libraries plugin folder"");
        } else {
            String libraryFileName = new File(name).getName();
            return new File(texturesLibrariesPluginFolders[0], libraryFileName).exists();
        }
    }

    /**
     * Adds the file <code>texturesLibraryName</code> to the first textures libraries folder
     * to make the textures library available to catalog.
     */
    @Override
    public void addTexturesLibrary(String texturesLibraryName) throws RecorderException {
        try {
            File[] texturesLibrariesPluginFolders = getTexturesLibrariesPluginFolders();
            if (texturesLibrariesPluginFolders == null || texturesLibrariesPluginFolders.length == 0) {
                throw new RecorderException(""Can't access to textures libraries plugin folder"");
            }
            copyToLibraryFolder(new File(texturesLibraryName), texturesLibrariesPluginFolders[0]);
            updateTexturesDefaultCatalog(this.catalogsLoader, this.updater);
        } catch (IOException ex) {
            throw new RecorderException(""Can't write "" + texturesLibraryName + "" in textures libraries plugin folder"", ex);
        }
    }

    /**
     * Copies a library file to a folder.
     */
    private void copyToLibraryFolder(File libraryFile, File folder) throws IOException {
        String libraryFileName = libraryFile.getName();
        File destinationFile = new File(folder, libraryFileName);
        if (destinationFile.exists()) {
            // Delete file to reinitialize handlers
            destinationFile.delete();
        }
        InputStream tempIn = null;
        OutputStream tempOut = null;
        try {
            tempIn = new BufferedInputStream(new FileInputStream(libraryFile));
            // Create folder if it doesn't exist
            folder.mkdirs();
            tempOut = new FileOutputStream(destinationFile);
            byte[] buffer = new byte[8192];
            int size;
            while ((size = tempIn.read(buffer)) != -1) {
                tempOut.write(buffer, 0, size);
            }
        } finally {
            if (tempIn != null) {
                tempIn.close();
            }
            if (tempOut != null) {
                tempOut.close();
            }
        }
    }

    /**
     * Preferences based on the <code>preferences.xml</code> file
     * stored in a preferences folder.
     * @author Emmanuel Puybaret
     */
    private class PortablePreferences extends AbstractPreferences {

        private static final String PREFERENCES_FILE = ""preferences.xml"";

        private Properties preferencesProperties;

        private boolean exist;

        private PortablePreferences() {
            super(null, """");
            this.preferencesProperties = new Properties();
            this.exist = readPreferences();
        }

        public boolean exist() {
            return this.exist;
        }

        @Override
        protected void syncSpi() throws BackingStoreException {
            this.preferencesProperties.clear();
            this.exist = readPreferences();
        }

        @Override
        protected void removeSpi(String key) {
            this.preferencesProperties.remove(key);
        }

        @Override
        protected void putSpi(String key, String value) {
            this.preferencesProperties.put(key, value);
        }

        @Override
        protected String[] keysSpi() throws BackingStoreException {
            return this.preferencesProperties.keySet().toArray(new String[0]);
        }

        @Override
        protected String getSpi(String key) {
            return (String) this.preferencesProperties.get(key);
        }

        @Override
        protected void flushSpi() throws BackingStoreException {
            try {
                writePreferences();
            } catch (IOException ex) {
                throw new BackingStoreException(ex);
            }
        }

        @Override
        protected void removeNodeSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected String[] childrenNamesSpi() throws BackingStoreException {
            throw new UnsupportedOperationException();
        }

        @Override
        protected AbstractPreferences childSpi(String name) {
            throw new UnsupportedOperationException();
        }

        /**
         * Reads user preferences.
         */
        private boolean readPreferences() {
            InputStream in = null;
            try {
                in = new FileInputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.loadFromXML(in);
                return true;
            } catch (IOException ex) {
                // Preferences don't exist
                return false;
            } finally {
                try {
                    if (in != null) {
                        in.close();
                    }
                } catch (IOException ex) {
                    // Let default preferences unchanged
                }
            }
        }

        /**
         * Writes user preferences.
         */
        private void writePreferences() throws IOException {
            OutputStream out = null;
            try {
                checkPreferencesFolder();
                out = new FileOutputStream(new File(getPreferencesFolder(), PREFERENCES_FILE));
                this.preferencesProperties.storeToXML(out, ""Portable user preferences 3.0"");
            } finally {
                if (out != null) {
                    out.close();
                    this.exist = true;
                }
            }
        }
    }
}
","// FileUserPreferences_4Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains one unit test case for the {@link FileUserPreferences#texturesLibraryExists(String)} method.
*/
class FileUserPreferences_4Test {","// FileUserPreferences_4Test.java
package com.eteks.sweethome3d.io;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.prefs.AbstractPreferences;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.eteks.sweethome3d.model.CatalogDoorOrWindow;
import com.eteks.sweethome3d.model.CatalogPieceOfFurniture;
import com.eteks.sweethome3d.model.CatalogTexture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.FurnitureCatalog;
import com.eteks.sweethome3d.model.FurnitureCategory;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.PatternsCatalog;
import com.eteks.sweethome3d.model.RecorderException;
import com.eteks.sweethome3d.model.Sash;
import com.eteks.sweethome3d.model.TexturesCatalog;
import com.eteks.sweethome3d.model.TexturesCategory;
import com.eteks.sweethome3d.model.UserPreferences;
import com.eteks.sweethome3d.tools.OperatingSystem;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileUserPreferences}.
* It contains one unit test case for the {@link FileUserPreferences#texturesLibraryExists(String)} method.
*/
class FileUserPreferences_4Test {
"
9e9ba64c-ab32-4f67-bfb5-0e6e63448b9d,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/viewcontroller/UserPreferencesController_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// UserPreferencesController.java
/*
 * UserPreferencesController.java 28 oct 2008
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;

/**
 * A MVC controller for user preferences view.
 * @author Emmanuel Puybaret
 */
public class UserPreferencesController implements Controller {

    /**
     * The properties that may be edited by the view associated to this controller.
     */
    public enum Property {

        LANGUAGE,
        UNIT,
        MAGNETISM_ENABLED,
        RULERS_VISIBLE,
        GRID_VISIBLE,
        FURNITURE_VIEWED_FROM_TOP,
        ROOM_FLOOR_COLORED_OR_TEXTURED,
        WALL_PATTERN,
        NEW_WALL_THICKNESS,
        NEW_WALL_HEIGHT,
        NEW_FLOOR_THICKNESS,
        FURNITURE_CATALOG_VIEWED_IN_TREE,
        NAVIGATION_PANEL_VISIBLE,
        AUTO_SAVE_DELAY_FOR_RECOVERY,
        AUTO_SAVE_FOR_RECOVERY_ENABLED
    }

    private final UserPreferences preferences;

    private final ViewFactory viewFactory;

    private final HomeController homeController;

    private final PropertyChangeSupport propertyChangeSupport;

    private DialogView userPreferencesView;

    private String language;

    private LengthUnit unit;

    private boolean furnitureCatalogViewedInTree;

    private boolean navigationPanelVisible;

    private boolean magnetismEnabled;

    private boolean rulersVisible;

    private boolean gridVisible;

    private boolean furnitureViewedFromTop;

    private boolean roomFloorColoredOrTextured;

    private TextureImage wallPattern;

    private float newWallThickness;

    private float newWallHeight;

    private float newFloorThickness;

    private int autoSaveDelayForRecovery;

    private boolean autoSaveForRecoveryEnabled;

    /**
     * Creates the controller of user preferences view.
     */
    public UserPreferencesController(UserPreferences preferences, ViewFactory viewFactory, ContentManager contentManager) {
        this(preferences, viewFactory, contentManager, null);
    }

    /**
     * Creates the controller of user preferences view.
     */
    public UserPreferencesController(UserPreferences preferences, ViewFactory viewFactory, ContentManager contentManager, HomeController homeController) {
        this.preferences = preferences;
        this.viewFactory = viewFactory;
        this.homeController = homeController;
        this.propertyChangeSupport = new PropertyChangeSupport(this);
        updateProperties();
    }

    /**
     * Returns the view associated with this controller.
     */
    public DialogView getView() {
        // Create view lazily only once it's needed
        if (this.userPreferencesView == null) {
            this.userPreferencesView = this.viewFactory.createUserPreferencesView(this.preferences, this);
        }
        return this.userPreferencesView;
    }

    /**
     * Displays the view controlled by this controller.
     */
    public void displayView(View parentView) {
        getView().displayView(parentView);
    }

    /**
     * Adds the property change <code>listener</code> in parameter to this controller.
     */
    public void addPropertyChangeListener(Property property, PropertyChangeListener listener) {
        this.propertyChangeSupport.addPropertyChangeListener(property.name(), listener);
    }

    /**
     * Removes the property change <code>listener</code> in parameter from this controller.
     */
    public void removePropertyChangeListener(Property property, PropertyChangeListener listener) {
        this.propertyChangeSupport.removePropertyChangeListener(property.name(), listener);
    }

    /**
     * Updates preferences properties edited by this controller.
     */
    protected void updateProperties() {
        setLanguage(this.preferences.getLanguage());
        setUnit(this.preferences.getLengthUnit());
        setFurnitureCatalogViewedInTree(this.preferences.isFurnitureCatalogViewedInTree());
        setNavigationPanelVisible(this.preferences.isNavigationPanelVisible());
        setMagnetismEnabled(this.preferences.isMagnetismEnabled());
        setGridVisible(this.preferences.isGridVisible());
        setRulersVisible(this.preferences.isRulersVisible());
        setFurnitureViewedFromTop(this.preferences.isFurnitureViewedFromTop());
        setRoomFloorColoredOrTextured(this.preferences.isRoomFloorColoredOrTextured());
        setWallPattern(this.preferences.getWallPattern());
        float minimumLength = getUnit().getMinimumLength();
        float maximumLength = getUnit().getMaximumLength();
        setNewWallThickness(Math.min(Math.max(minimumLength, this.preferences.getNewWallThickness()), maximumLength / 10));
        setNewWallHeight(Math.min(Math.max(minimumLength, this.preferences.getNewWallHeight()), maximumLength));
        setNewFloorThickness(Math.min(Math.max(minimumLength, this.preferences.getNewFloorThickness()), maximumLength / 10));
        setAutoSaveDelayForRecovery(this.preferences.getAutoSaveDelayForRecovery());
        setAutoSaveForRecoveryEnabled(this.preferences.getAutoSaveDelayForRecovery() > 0);
    }

    /**
     * Returns <code>true</code> if the given <code>property</code> is editable.
     * Depending on whether a property is editable or not, the view associated to this controller
     * may render it differently.
     * The implementation of this method always returns <code>true</code> except for <code>LANGUAGE</code> if it's not editable.
     */
    public boolean isPropertyEditable(Property property) {
        switch(property) {
            case LANGUAGE:
                return this.preferences.isLanguageEditable();
            default:
                return true;
        }
    }

    /**
     * Sets the edited language.
     */
    public void setLanguage(String language) {
        if (language != this.language) {
            String oldLanguage = this.language;
            this.language = language;
            this.propertyChangeSupport.firePropertyChange(Property.LANGUAGE.name(), oldLanguage, language);
        }
    }

    /**
     * Returns the edited language.
     */
    public String getLanguage() {
        return this.language;
    }

    /**
     * Sets the edited unit.
     */
    public void setUnit(LengthUnit unit) {
        if (unit != this.unit) {
            LengthUnit oldUnit = this.unit;
            this.unit = unit;
            this.propertyChangeSupport.firePropertyChange(Property.UNIT.name(), oldUnit, unit);
        }
    }

    /**
     * Returns the edited unit.
     */
    public LengthUnit getUnit() {
        return this.unit;
    }

    /**
     * Sets whether the furniture catalog should be viewed in a tree or a different way.
     */
    public void setFurnitureCatalogViewedInTree(boolean furnitureCatalogViewedInTree) {
        if (this.furnitureCatalogViewedInTree != furnitureCatalogViewedInTree) {
            this.furnitureCatalogViewedInTree = furnitureCatalogViewedInTree;
            this.propertyChangeSupport.firePropertyChange(Property.FURNITURE_CATALOG_VIEWED_IN_TREE.name(), !furnitureCatalogViewedInTree, furnitureCatalogViewedInTree);
        }
    }

    /**
     * Returns <code>true</code> if furniture catalog should be viewed in a tree.
     */
    public boolean isFurnitureCatalogViewedInTree() {
        return this.furnitureCatalogViewedInTree;
    }

    /**
     * Sets whether the navigation panel should be displayed or not.
     */
    public void setNavigationPanelVisible(boolean navigationPanelVisible) {
        if (this.navigationPanelVisible != navigationPanelVisible) {
            this.navigationPanelVisible = navigationPanelVisible;
            this.propertyChangeSupport.firePropertyChange(Property.NAVIGATION_PANEL_VISIBLE.name(), !navigationPanelVisible, navigationPanelVisible);
        }
    }

    /**
     * Returns <code>true</code> if the navigation panel should be displayed.
     */
    public boolean isNavigationPanelVisible() {
        return this.navigationPanelVisible;
    }

    /**
     * Sets whether magnetism is enabled or not.
     */
    public void setMagnetismEnabled(boolean magnetismEnabled) {
        if (magnetismEnabled != this.magnetismEnabled) {
            this.magnetismEnabled = magnetismEnabled;
            this.propertyChangeSupport.firePropertyChange(Property.MAGNETISM_ENABLED.name(), !magnetismEnabled, magnetismEnabled);
        }
    }

    /**
     * Returns whether magnetism is enabled or not.
     */
    public boolean isMagnetismEnabled() {
        return this.magnetismEnabled;
    }

    /**
     * Sets whether rulers are visible or not.
     */
    public void setRulersVisible(boolean rulersVisible) {
        if (rulersVisible != this.rulersVisible) {
            this.rulersVisible = rulersVisible;
            this.propertyChangeSupport.firePropertyChange(Property.RULERS_VISIBLE.name(), !rulersVisible, rulersVisible);
        }
    }

    /**
     * Returns whether rulers are visible or not.
     */
    public boolean isRulersVisible() {
        return this.rulersVisible;
    }

    /**
     * Sets whether grid is visible or not.
     */
    public void setGridVisible(boolean gridVisible) {
        if (gridVisible != this.gridVisible) {
            this.gridVisible = gridVisible;
            this.propertyChangeSupport.firePropertyChange(Property.GRID_VISIBLE.name(), !gridVisible, gridVisible);
        }
    }

    /**
     * Returns whether grid is visible or not.
     */
    public boolean isGridVisible() {
        return this.gridVisible;
    }

    /**
     * Sets how furniture should be displayed in plan.
     */
    public void setFurnitureViewedFromTop(boolean furnitureViewedFromTop) {
        if (this.furnitureViewedFromTop != furnitureViewedFromTop) {
            this.furnitureViewedFromTop = furnitureViewedFromTop;
            this.propertyChangeSupport.firePropertyChange(Property.FURNITURE_VIEWED_FROM_TOP.name(), !furnitureViewedFromTop, furnitureViewedFromTop);
        }
    }

    /**
     * Returns how furniture should be displayed in plan.
     */
    public boolean isFurnitureViewedFromTop() {
        return this.furnitureViewedFromTop;
    }

    /**
     * Sets whether floor texture is visible in plan or not.
     */
    public void setRoomFloorColoredOrTextured(boolean floorTextureVisible) {
        if (this.roomFloorColoredOrTextured != floorTextureVisible) {
            this.roomFloorColoredOrTextured = floorTextureVisible;
            this.propertyChangeSupport.firePropertyChange(Property.ROOM_FLOOR_COLORED_OR_TEXTURED.name(), !floorTextureVisible, floorTextureVisible);
        }
    }

    /**
     * Returns <code>true</code> if floor texture is visible in plan.
     */
    public boolean isRoomFloorColoredOrTextured() {
        return this.roomFloorColoredOrTextured;
    }

    /**
     * Sets how furniture should be displayed in plan, and notifies
     * listeners of this change.
     */
    public void setWallPattern(TextureImage wallPattern) {
        if (this.wallPattern != wallPattern) {
            TextureImage oldWallPattern = this.wallPattern;
            this.wallPattern = wallPattern;
            this.propertyChangeSupport.firePropertyChange(Property.WALL_PATTERN.name(), oldWallPattern, wallPattern);
        }
    }

    /**
     * Returns the wall pattern in plan.
     */
    public TextureImage getWallPattern() {
        return this.wallPattern;
    }

    /**
     * Sets the edited new wall thickness.
     */
    public void setNewWallThickness(float newWallThickness) {
        if (newWallThickness != this.newWallThickness) {
            float oldNewWallThickness = this.newWallThickness;
            this.newWallThickness = newWallThickness;
            this.propertyChangeSupport.firePropertyChange(Property.NEW_WALL_THICKNESS.name(), oldNewWallThickness, newWallThickness);
        }
    }

    /**
     * Returns the edited new wall thickness.
     */
    public float getNewWallThickness() {
        return this.newWallThickness;
    }

    /**
     * Sets the edited new wall height.
     */
    public void setNewWallHeight(float newWallHeight) {
        if (newWallHeight != this.newWallHeight) {
            float oldNewWallHeight = this.newWallHeight;
            this.newWallHeight = newWallHeight;
            this.propertyChangeSupport.firePropertyChange(Property.NEW_WALL_HEIGHT.name(), oldNewWallHeight, newWallHeight);
        }
    }

    /**
     * Returns the edited new wall height.
     */
    public float getNewWallHeight() {
        return this.newWallHeight;
    }

    /**
     * Sets the edited new floor thickness.
     */
    public void setNewFloorThickness(float newFloorThickness) {
        if (newFloorThickness != this.newFloorThickness) {
            float oldNewFloorThickness = this.newFloorThickness;
            this.newFloorThickness = newFloorThickness;
            this.propertyChangeSupport.firePropertyChange(Property.NEW_FLOOR_THICKNESS.name(), oldNewFloorThickness, newFloorThickness);
        }
    }

    /**
     * Returns the edited new floor thickness.
     */
    public float getNewFloorThickness() {
        return this.newFloorThickness;
    }

    /**
     * Sets the edited auto recovery save delay.
     */
    public void setAutoSaveDelayForRecovery(int autoSaveDelayForRecovery) {
        if (autoSaveDelayForRecovery != this.autoSaveDelayForRecovery) {
            float oldAutoSaveDelayForRecovery = this.autoSaveDelayForRecovery;
            this.autoSaveDelayForRecovery = autoSaveDelayForRecovery;
            this.propertyChangeSupport.firePropertyChange(Property.AUTO_SAVE_DELAY_FOR_RECOVERY.name(), oldAutoSaveDelayForRecovery, autoSaveDelayForRecovery);
        }
    }

    /**
     * Returns the edited auto recovery save delay.
     */
    public int getAutoSaveDelayForRecovery() {
        return this.autoSaveDelayForRecovery;
    }

    /**
     * Sets whether auto recovery save is enabled or not.
     */
    public void setAutoSaveForRecoveryEnabled(boolean autoSaveForRecoveryEnabled) {
        if (autoSaveForRecoveryEnabled != this.autoSaveForRecoveryEnabled) {
            this.autoSaveForRecoveryEnabled = autoSaveForRecoveryEnabled;
            this.propertyChangeSupport.firePropertyChange(Property.AUTO_SAVE_FOR_RECOVERY_ENABLED.name(), !autoSaveForRecoveryEnabled, autoSaveForRecoveryEnabled);
        }
    }

    /**
     * Returns <code>true</code> if auto recovery save is enabled.
     */
    public boolean isAutoSaveForRecoveryEnabled() {
        return this.autoSaveForRecoveryEnabled;
    }

    /**
     * Returns <code>true</code> if language libraries can be imported.
     */
    public boolean mayImportLanguageLibrary() {
        return this.homeController != null;
    }

    /**
     * Imports a language library chosen by the user.
     */
    public void importLanguageLibrary() {
        if (this.homeController != null) {
            this.homeController.importLanguageLibrary();
        }
    }

    /**
     * Controls the modification of user preferences.
     */
    public void modifyUserPreferences() {
        this.preferences.setLanguage(getLanguage());
        this.preferences.setUnit(getUnit());
        this.preferences.setFurnitureCatalogViewedInTree(isFurnitureCatalogViewedInTree());
        this.preferences.setNavigationPanelVisible(isNavigationPanelVisible());
        this.preferences.setMagnetismEnabled(isMagnetismEnabled());
        this.preferences.setRulersVisible(isRulersVisible());
        this.preferences.setGridVisible(isGridVisible());
        this.preferences.setFurnitureViewedFromTop(isFurnitureViewedFromTop());
        this.preferences.setFloorColoredOrTextured(isRoomFloorColoredOrTextured());
        this.preferences.setWallPattern(getWallPattern());
        this.preferences.setNewWallThickness(getNewWallThickness());
        this.preferences.setNewWallHeight(getNewWallHeight());
        this.preferences.setNewFloorThickness(getNewFloorThickness());
        this.preferences.setAutoSaveDelayForRecovery(isAutoSaveForRecoveryEnabled() ? getAutoSaveDelayForRecovery() : 0);
    }

    /**
     * Resets the displayed flags of action tips.
     */
    public void resetDisplayedActionTips() {
        this.preferences.resetIgnoredActionTips();
    }
}
","// UserPreferencesController_1Test.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains one unit test case for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesController_1Test {","// UserPreferencesController_1Test.java
package com.eteks.sweethome3d.viewcontroller;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import com.eteks.sweethome3d.model.LengthUnit;
import com.eteks.sweethome3d.model.TextureImage;
import com.eteks.sweethome3d.model.UserPreferences;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UserPreferencesController}.
* It contains one unit test case for the {@link UserPreferencesController#mayImportLanguageLibrary()} method.
*/
class UserPreferencesController_1Test {
"
f7e80380-30c0-4dc4-8869-ed08618b2c6b,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/TextureManager_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// TextureManager.java
/*
 * TextureManager.java 2 oct 2007
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Texture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.URLContent;
import com.sun.j3d.utils.image.TextureLoader;

/**
 * Singleton managing texture image cache.
 * @author Emmanuel Puybaret
 */
public class TextureManager {

    private static TextureManager instance;

    // Image used if an image content couldn't be loaded
    private final Texture errorTexture;

    // Image used while an image content is loaded
    private final Texture waitTexture;

    // Map storing loaded texture contents
    private final Map<Content, TextureKey> contentTextureKeys;

    // Map storing loaded textures
    private final Map<TextureKey, Texture> textures;

    // Map storing model nodes being loaded
    private Map<Content, List<TextureObserver>> loadingTextureObservers;

    // Executor used to load images
    private ExecutorService texturesLoader;

    private TextureManager() {
        this.errorTexture = getColoredImageTexture(Color.RED);
        this.waitTexture = getColoredImageTexture(Color.WHITE);
        this.contentTextureKeys = new WeakHashMap<Content, TextureKey>();
        this.textures = new WeakHashMap<TextureKey, Texture>();
        this.loadingTextureObservers = new HashMap<Content, List<TextureObserver>>();
    }

    /**
     * Returns an instance of this singleton.
     */
    public static TextureManager getInstance() {
        if (instance == null) {
            instance = new TextureManager();
        }
        return instance;
    }

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear() {
        if (this.texturesLoader != null) {
            this.texturesLoader.shutdownNow();
            this.texturesLoader = null;
        }
        synchronized (this.textures) {
            this.contentTextureKeys.clear();
            this.textures.clear();
        }
    }

    /**
     * Returns a texture image of one pixel of the given <code>color</code>.
     */
    private Texture getColoredImageTexture(Color color) {
        BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);
        Graphics g = image.getGraphics();
        g.setColor(color);
        g.drawLine(0, 0, 0, 0);
        g.dispose();
        Texture texture = new TextureLoader(image).getTexture();
        texture.setCapability(Texture.ALLOW_IMAGE_READ);
        texture.setCapability(Texture.ALLOW_FORMAT_READ);
        texture.getImage(0).setCapability(ImageComponent2D.ALLOW_IMAGE_READ);
        texture.getImage(0).setCapability(ImageComponent2D.ALLOW_FORMAT_READ);
        return texture;
    }

    /**
     * Reads a texture image from <code>content</code> notified to <code>textureObserver</code>
     * If the texture isn't loaded in cache yet, a one pixel white image texture will be notified
     * immediately to the given <code>textureObserver</code>, then a second notification will
     * be given in Event Dispatch Thread once the image texture is loaded. If the texture is in cache,
     * it will be notified immediately to the given <code>textureObserver</code>.
     * @param content an object containing an image
     * @param textureObserver the observer that will be notified once the texture is available
     */
    public void loadTexture(final Content content, final TextureObserver textureObserver) {
        loadTexture(content, false, textureObserver);
    }

    /**
     * Reads a texture image from <code>content</code> notified to <code>textureObserver</code>.
     * If the texture isn't loaded in cache yet and <code>synchronous</code> is false, a one pixel
     * white image texture will be notified immediately to the given <code>textureObserver</code>,
     * then a second notification will be given in Event Dispatch Thread once the image texture is loaded.
     * If the texture is in cache, it will be notified immediately to the given <code>textureObserver</code>.
     * @param content an object containing an image
     * @param synchronous if <code>true</code>, this method will return only once image content is loaded.
     * @param textureObserver the observer that will be notified once the texture is available
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadTexture(final Content content, boolean synchronous, final TextureObserver textureObserver) {
        Texture texture;
        TextureKey textureKey;
        synchronized (this.textures) {
            // Use one mutex for both maps
            textureKey = this.contentTextureKeys.get(content);
            if (textureKey != null) {
                texture = this.textures.get(textureKey);
            } else {
                texture = null;
            }
        }
        if (texture == null) {
            if (synchronous) {
                texture = shareTexture(loadTexture(content), content);
                // Notify loaded texture to observer
                textureObserver.textureUpdated(texture);
            } else if (!EventQueue.isDispatchThread()) {
                throw new IllegalStateException(""Asynchronous call out of Event Dispatch Thread"");
            } else {
                // Notify wait texture to observer
                textureObserver.textureUpdated(this.waitTexture);
                if (this.texturesLoader == null) {
                    this.texturesLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
                }
                List<TextureObserver> observers = this.loadingTextureObservers.get(content);
                if (observers != null) {
                    // If observers list exists, content texture is already being loaded
                    // register observer for future notification
                    observers.add(textureObserver);
                } else {
                    // Create a list of observers that will be notified once content texture is loaded
                    observers = new ArrayList<TextureObserver>();
                    observers.add(textureObserver);
                    this.loadingTextureObservers.put(content, observers);
                    // Load the image in a different thread
                    this.texturesLoader.execute(new Runnable() {

                        public void run() {
                            final Texture texture = shareTexture(loadTexture(content), content);
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    // Notify loaded texture to observer
                                    for (TextureObserver observer : loadingTextureObservers.remove(content)) {
                                        observer.textureUpdated(texture);
                                    }
                                }
                            });
                        }
                    });
                }
            }
        } else {
            // Notify cached texture to observer
            textureObserver.textureUpdated(texture);
        }
    }

    /**
     * Returns a texture created from the image from <code>content</code>.
     */
    public Texture loadTexture(final Content content) {
        BufferedImage image = null;
        try {
            // Read the image
            InputStream contentStream = content.openStream();
            image = ImageIO.read(contentStream);
            contentStream.close();
        } catch (IOException ex) {
            // Too bad, we'll use errorTexture
        }
        final Texture texture;
        if (image == null) {
            texture = errorTexture;
        } else {
            texture = new TextureLoader(image).getTexture();
            // Keep in user data the URL of the texture image
            if (content instanceof URLContent) {
                texture.setUserData(((URLContent) content).getURL());
            }
        }
        return texture;
    }

    /**
     * Returns either the <code>texture</code> in parameter or a shared texture
     * if the same texture as the one in parameter is already shared.
     */
    public Texture shareTexture(Texture texture) {
        return shareTexture(texture, null);
    }

    /**
     * Returns the texture matching <code>content</code>, either
     * the <code>texture</code> in parameter or a shared texture if the
     * same texture as the one in parameter is already shared.
     */
    private Texture shareTexture(final Texture texture, final Content content) {
        TextureKey textureKey = new TextureKey(texture);
        Texture sharedTexture;
        synchronized (this.textures) {
            // Use one mutex for both maps
            sharedTexture = this.textures.get(textureKey);
            if (sharedTexture == null) {
                sharedTexture = texture;
                setSharedTextureAttributesAndCapabilities(sharedTexture);
                this.textures.put(textureKey, sharedTexture);
            } else {
                // Search which key matches sharedTexture to keep unique keys
                for (TextureKey key : this.textures.keySet()) {
                    if (key.getTexture() == sharedTexture) {
                        textureKey = key;
                        break;
                    }
                }
            }
            if (content != null) {
                this.contentTextureKeys.put(content, textureKey);
            }
        }
        return sharedTexture;
    }

    /**
     * Sets the attributes and capabilities of a shared <code>texture</code>.
     */
    private void setSharedTextureAttributesAndCapabilities(Texture texture) {
        if (!texture.isLive()) {
            texture.setMinFilter(Texture.NICEST);
            texture.setMagFilter(Texture.NICEST);
            texture.setCapability(Texture.ALLOW_FORMAT_READ);
            texture.setCapability(Texture.ALLOW_IMAGE_READ);
            for (ImageComponent image : texture.getImages()) {
                if (!image.isLive()) {
                    image.setCapability(ImageComponent.ALLOW_FORMAT_READ);
                    image.setCapability(ImageComponent.ALLOW_IMAGE_READ);
                }
            }
        }
    }

    /**
     * Returns <code>true</code> if the texture is shared and its image contains
     * at least one transparent pixel.
     */
    public boolean isTextureTransparent(Texture texture) {
        synchronized (this.textures) {
            // Use one mutex for both maps
            // Search which key matches texture
            for (TextureKey key : textures.keySet()) {
                if (key.getTexture() == texture) {
                    return key.isTransparent();
                }
            }
            return texture.getFormat() == Texture.RGBA;
        }
    }

    /**
     * An observer that receives texture loading notifications.
     */
    public static interface TextureObserver {

        public void textureUpdated(Texture texture);
    }

    /**
     * Key used to ensure texture uniqueness in textures map.
     * Image bits of the texture are stored in a weak reference to avoid grabbing memory uselessly.
     */
    private static class TextureKey {

        private Texture texture;

        private WeakReference<int[]> imageBits;

        private int hashCodeCache;

        private boolean hashCodeSet;

        private boolean transparent;

        public TextureKey(Texture texture) {
            this.texture = texture;
        }

        public Texture getTexture() {
            return this.texture;
        }

        /**
         * Returns the pixels of the given <code>image</code>.
         */
        private int[] getImagePixels() {
            int[] imageBits = null;
            if (this.imageBits != null) {
                imageBits = this.imageBits.get();
            }
            if (imageBits == null) {
                BufferedImage image = ((ImageComponent2D) this.texture.getImage(0)).getImage();
                if (image.getType() != BufferedImage.TYPE_INT_RGB && image.getType() != BufferedImage.TYPE_INT_ARGB) {
                    // Transform as TYPE_INT_ARGB or TYPE_INT_RGB (much faster than calling image.getRGB())
                    BufferedImage tmp = new BufferedImage(image.getWidth(), image.getHeight(), this.texture.getFormat() == Texture.RGBA ? BufferedImage.TYPE_INT_ARGB : BufferedImage.TYPE_INT_RGB);
                    Graphics2D g = (Graphics2D) tmp.getGraphics();
                    g.drawImage(image, null, 0, 0);
                    g.dispose();
                    image = tmp;
                }
                imageBits = (int[]) image.getRaster().getDataElements(0, 0, image.getWidth(), image.getHeight(), null);
                this.transparent = image.getTransparency() != BufferedImage.OPAQUE;
                this.imageBits = new WeakReference<int[]>(imageBits);
            }
            return imageBits;
        }

        /**
         * Returns <code>true</code> if the image of the texture contains at least one transparent pixel.
         */
        public boolean isTransparent() {
            return this.transparent;
        }

        /**
         * Returns <code>true</code> if the image of this texture and
         * the image of the object in parameter are the same.
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            } else if (obj instanceof TextureKey) {
                TextureKey textureKey = (TextureKey) obj;
                if (this.texture == textureKey.texture) {
                    return true;
                } else if (hashCode() == textureKey.hashCode()) {
                    return Arrays.equals(getImagePixels(), textureKey.getImagePixels());
                }
            }
            return false;
        }

        @Override
        public int hashCode() {
            if (!this.hashCodeSet) {
                this.hashCodeCache = Arrays.hashCode(getImagePixels());
                this.hashCodeSet = true;
            }
            return this.hashCodeCache;
        }
    }
}
","// TextureManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Texture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.URLContent;
import com.sun.j3d.utils.image.TextureLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureManager}.
* It contains one unit test case for the {@link TextureManager#getInstance()} method.
*/
class TextureManager_0Test {","// TextureManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.imageio.ImageIO;
import javax.media.j3d.ImageComponent;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.Texture;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.tools.URLContent;
import com.sun.j3d.utils.image.TextureLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextureManager}.
* It contains one unit test case for the {@link TextureManager#getInstance()} method.
*/
class TextureManager_0Test {
"
503cc303-a717-480e-b052-5086f85d5bd4,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/Component3DManager_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Component3DManager.java
/*
 * Canvas3DManager.java 25 oct. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;

/**
 * Manager of <code>Canvas3D</code> instantiations and Java 3D error listeners.
 * Note: this class is compatible with Java 3D 1.3 at runtime but requires Java 3D 1.5 to compile.
 * @author Emmanuel Puybaret
 */
public class Component3DManager {

    private static final String CHECK_OFF_SCREEN_IMAGE_SUPPORT = ""com.eteks.sweethome3d.j3d.checkOffScreenSupport"";

    private static Component3DManager instance;

    private RenderingErrorObserver renderingErrorObserver;

    // The Java 3D listener matching renderingErrorObserver
    // (use Object class to ensure Component3DManager class can run with Java 3D 1.3.1)
    private Object renderingErrorListener;

    private Boolean offScreenImageSupported;

    private GraphicsConfiguration defaultScreenConfiguration;

    private Component3DManager() {
        if (!GraphicsEnvironment.isHeadless()) {
            GraphicsConfigTemplate3D template = createGraphicsConfigurationTemplate3D();
            GraphicsDevice defaultScreenDevice = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
            this.defaultScreenConfiguration = defaultScreenDevice.getBestConfiguration(template);
            if (this.defaultScreenConfiguration == null) {
                this.defaultScreenConfiguration = defaultScreenDevice.getBestConfiguration(new GraphicsConfigTemplate3D());
            }
        } else {
            this.offScreenImageSupported = Boolean.FALSE;
        }
    }

    /**
     * Returns the template to configure the graphics of canvas 3D.
     */
    private GraphicsConfigTemplate3D createGraphicsConfigurationTemplate3D() {
        System.setProperty(""j3d.implicitAntialiasing"", ""true"");
        // Retrieve graphics configuration once
        GraphicsConfigTemplate3D template = new GraphicsConfigTemplate3D();
        // Try to get antialiasing
        template.setSceneAntialiasing(GraphicsConfigTemplate3D.PREFERRED);
        // From http://www.java.net/node/683852
        // Check if the user has set the Java 3D stereo option.
        String stereo = System.getProperty(""j3d.stereo"");
        if (stereo != null) {
            if (""REQUIRED"".equals(stereo))
                template.setStereo(GraphicsConfigTemplate.REQUIRED);
            else if (""PREFERRED"".equals(stereo))
                template.setStereo(GraphicsConfigTemplate.PREFERRED);
        }
        return template;
    }

    /**
     * Returns an instance of this singleton.
     */
    public static Component3DManager getInstance() {
        if (instance == null) {
            instance = new Component3DManager();
        }
        return instance;
    }

    /**
     * Sets the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public void setRenderingErrorObserver(RenderingErrorObserver observer) {
        try {
            Class.forName(""javax.media.j3d.RenderingErrorListener"");
            this.renderingErrorListener = RenderingErrorListenerManager.setRenderingErrorObserver(observer, this.renderingErrorListener);
            this.renderingErrorObserver = observer;
        } catch (ClassNotFoundException ex) {
            // As RenderingErrorListener and addRenderingErrorListener are available since Java 3D 1.5,
            // use the default rendering error reporting if Sweet Home 3D is linked to a previous version
        }
    }

    /**
     * Returns the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public RenderingErrorObserver getRenderingErrorObserver() {
        return this.renderingErrorObserver;
    }

    /**
     * Returns <code>true</code> if offscreen is supported in Java 3D on user system.
     * Will always return <code>false</code> if <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * system is equal to <code>false</code>. By default, <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * is equal to <code>true</code>.
     */
    public boolean isOffScreenImageSupported() {
        if (this.offScreenImageSupported == null) {
            if (""false"".equalsIgnoreCase(System.getProperty(CHECK_OFF_SCREEN_IMAGE_SUPPORT, ""true""))) {
                this.offScreenImageSupported = Boolean.FALSE;
            } else {
                SimpleUniverse universe = null;
                try {
                    // Create a universe bound to no canvas 3D
                    ViewingPlatform viewingPlatform = new ViewingPlatform();
                    Viewer viewer = new Viewer(new Canvas3D[0]);
                    universe = new SimpleUniverse(viewingPlatform, viewer);
                    // Create a dummy 3D image to check if it can be rendered in current Java 3D configuration
                    getOffScreenImage(viewer.getView(), 1, 1);
                    this.offScreenImageSupported = Boolean.TRUE;
                } catch (IllegalRenderingStateException ex) {
                    this.offScreenImageSupported = Boolean.FALSE;
                } catch (NullPointerException ex) {
                    this.offScreenImageSupported = Boolean.FALSE;
                } catch (IllegalArgumentException ex) {
                    this.offScreenImageSupported = Boolean.FALSE;
                } finally {
                    if (universe != null) {
                        universe.cleanup();
                    }
                }
            }
        }
        return this.offScreenImageSupported;
    }

    /**
     * Returns a new <code>canva3D</code> instance that will call <code>renderingObserver</code>
     * methods during the rendering loop.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    private Canvas3D getCanvas3D(GraphicsConfiguration deviceConfiguration, boolean offscreen, final RenderingObserver renderingObserver) {
        GraphicsConfiguration configuration;
        if (GraphicsEnvironment.isHeadless()) {
            configuration = null;
        } else if (deviceConfiguration == null || deviceConfiguration.getDevice() == this.defaultScreenConfiguration.getDevice()) {
            configuration = this.defaultScreenConfiguration;
        } else {
            GraphicsConfigTemplate3D template = createGraphicsConfigurationTemplate3D();
            configuration = deviceConfiguration.getDevice().getBestConfiguration(template);
            if (configuration == null) {
                configuration = deviceConfiguration.getDevice().getBestConfiguration(new GraphicsConfigTemplate3D());
            }
        }
        if (configuration == null) {
            throw new IllegalRenderingStateException(""Can't create graphics environment for Canvas 3D"");
        }
        try {
            // Ensure unused canvases are freed
            System.gc();
            // Create a Java 3D canvas
            return new Canvas3D(configuration, offscreen) {

                @Override
                public void preRender() {
                    if (renderingObserver != null) {
                        renderingObserver.canvas3DPreRendered(this);
                    }
                }

                @Override
                public void postRender() {
                    if (renderingObserver != null) {
                        renderingObserver.canvas3DPostRendered(this);
                    }
                }

                @Override
                public void postSwap() {
                    if (renderingObserver != null) {
                        renderingObserver.canvas3DSwapped(this);
                    }
                }
            };
        } catch (IllegalArgumentException ex) {
            IllegalRenderingStateException ex2 = new IllegalRenderingStateException(""Can't create Canvas 3D"");
            ex2.initCause(ex);
            throw ex2;
        }
    }

    /**
     * Returns a new on screen <code>canva3D</code> instance. The returned canvas 3D will be associated
     * with the graphics configuration of the default screen device.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D() {
        return getOnscreenCanvas3D(null);
    }

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer. The returned canvas 3D will be associated with the
     * graphics configuration of the default screen device.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(RenderingObserver renderingObserver) {
        return getCanvas3D(null, false, renderingObserver);
    }

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(GraphicsConfiguration deviceConfiguration, RenderingObserver renderingObserver) {
        return getCanvas3D(deviceConfiguration, false, renderingObserver);
    }

    /**
     * Returns a new off screen <code>canva3D</code> at the given size.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     *    To avoid this exception, call {@link #isOffScreenImageSupported() isOffScreenImageSupported()} first.
     */
    public Canvas3D getOffScreenCanvas3D(int width, int height) {
        Canvas3D offScreenCanvas = getCanvas3D(null, true, null);
        // Configure canvas 3D for offscreen
        Screen3D screen3D = offScreenCanvas.getScreen3D();
        screen3D.setSize(width, height);
        screen3D.setPhysicalScreenWidth(2f);
        screen3D.setPhysicalScreenHeight(2f / width * height);
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        ImageComponent2D imageComponent2D = new ImageComponent2D(ImageComponent2D.FORMAT_RGB, image);
        imageComponent2D.setCapability(ImageComponent2D.ALLOW_IMAGE_READ);
        offScreenCanvas.setOffScreenBuffer(imageComponent2D);
        return offScreenCanvas;
    }

    /**
     * Returns an image at the given size of the 3D <code>view</code>.
     * This image is created with an off screen canvas.
     * @throws IllegalRenderingStateException  if the image couldn't be created.
     */
    public BufferedImage getOffScreenImage(View view, int width, int height) {
        Canvas3D offScreenCanvas = null;
        RenderingErrorObserver previousRenderingErrorObserver = getRenderingErrorObserver();
        try {
            // Replace current rendering error observer by a listener that counts down
            // a latch to check further if a rendering error happened during off screen rendering
            // (rendering error listener is called from a notification thread)
            final CountDownLatch latch = new CountDownLatch(1);
            setRenderingErrorObserver(new RenderingErrorObserver() {

                public void errorOccured(int errorCode, String errorMessage) {
                    latch.countDown();
                }
            });
            // Create an off screen canvas and bind it to view
            offScreenCanvas = getOffScreenCanvas3D(width, height);
            view.addCanvas3D(offScreenCanvas);
            // Render off screen canvas
            offScreenCanvas.renderOffScreenBuffer();
            offScreenCanvas.waitForOffScreenRendering();
            // If latch count becomes equal to 0 during the past instructions or in the coming 10 milliseconds,
            // this means that a rendering error happened
            if (latch.await(10, TimeUnit.MILLISECONDS)) {
                throw new IllegalRenderingStateException(""Off screen rendering unavailable"");
            }
            return offScreenCanvas.getOffScreenBuffer().getImage();
        } catch (InterruptedException ex) {
            IllegalRenderingStateException ex2 = new IllegalRenderingStateException(""Off screen rendering interrupted"");
            ex2.initCause(ex);
            throw ex2;
        } finally {
            if (offScreenCanvas != null) {
                view.removeCanvas3D(offScreenCanvas);
                try {
                    // Free off screen buffer and context
                    offScreenCanvas.setOffScreenBuffer(null);
                } catch (NullPointerException ex) {
                    // Java 3D 1.3 may throw an exception
                }
            }
            // Reset previous rendering error listener
            setRenderingErrorObserver(previousRenderingErrorObserver);
        }
    }

    /**
     * An observer that receives error notifications in Java 3D.
     */
    public static interface RenderingErrorObserver {

        void errorOccured(int errorCode, String errorMessage);
    }

    /**
     * Manages Java 3D 1.5 <code>RenderingErrorListener</code> change matching the given
     * rendering error observer.
     */
    private static class RenderingErrorListenerManager {

        public static Object setRenderingErrorObserver(final RenderingErrorObserver observer, Object previousRenderingErrorListener) {
            if (previousRenderingErrorListener != null) {
                VirtualUniverse.removeRenderingErrorListener((RenderingErrorListener) previousRenderingErrorListener);
            }
            RenderingErrorListener renderingErrorListener = new RenderingErrorListener() {

                public void errorOccurred(RenderingError error) {
                    observer.errorOccured(error.getErrorCode(), error.getErrorMessage());
                }
            };
            VirtualUniverse.addRenderingErrorListener(renderingErrorListener);
            return renderingErrorListener;
        }
    }

    /**
     * An observer that receives notifications during the different steps
     * of the loop rendering a canvas 3D.
     */
    public static interface RenderingObserver {

        /**
         * Called before <code>canvas3D</code> is rendered.
         */
        public void canvas3DPreRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> is rendered.
         */
        public void canvas3DPostRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> buffer is swapped.
         */
        public void canvas3DSwapped(Canvas3D canvas3D);
    }
}
","// Component3DManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains one unit test case for the {@link Component3DManager#getInstance()} method.
*/
class Component3DManager_0Test {","// Component3DManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains one unit test case for the {@link Component3DManager#getInstance()} method.
*/
class Component3DManager_0Test {
"
14ac64cf-b499-426f-a09c-d5ba521b6e62,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/Component3DManager_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// Component3DManager.java
/*
 * Canvas3DManager.java 25 oct. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;

/**
 * Manager of <code>Canvas3D</code> instantiations and Java 3D error listeners.
 * Note: this class is compatible with Java 3D 1.3 at runtime but requires Java 3D 1.5 to compile.
 * @author Emmanuel Puybaret
 */
public class Component3DManager {

    private static final String CHECK_OFF_SCREEN_IMAGE_SUPPORT = ""com.eteks.sweethome3d.j3d.checkOffScreenSupport"";

    private static Component3DManager instance;

    private RenderingErrorObserver renderingErrorObserver;

    // The Java 3D listener matching renderingErrorObserver
    // (use Object class to ensure Component3DManager class can run with Java 3D 1.3.1)
    private Object renderingErrorListener;

    private Boolean offScreenImageSupported;

    private GraphicsConfiguration defaultScreenConfiguration;

    private Component3DManager() {
        if (!GraphicsEnvironment.isHeadless()) {
            GraphicsConfigTemplate3D template = createGraphicsConfigurationTemplate3D();
            GraphicsDevice defaultScreenDevice = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
            this.defaultScreenConfiguration = defaultScreenDevice.getBestConfiguration(template);
            if (this.defaultScreenConfiguration == null) {
                this.defaultScreenConfiguration = defaultScreenDevice.getBestConfiguration(new GraphicsConfigTemplate3D());
            }
        } else {
            this.offScreenImageSupported = Boolean.FALSE;
        }
    }

    /**
     * Returns the template to configure the graphics of canvas 3D.
     */
    private GraphicsConfigTemplate3D createGraphicsConfigurationTemplate3D() {
        System.setProperty(""j3d.implicitAntialiasing"", ""true"");
        // Retrieve graphics configuration once
        GraphicsConfigTemplate3D template = new GraphicsConfigTemplate3D();
        // Try to get antialiasing
        template.setSceneAntialiasing(GraphicsConfigTemplate3D.PREFERRED);
        // From http://www.java.net/node/683852
        // Check if the user has set the Java 3D stereo option.
        String stereo = System.getProperty(""j3d.stereo"");
        if (stereo != null) {
            if (""REQUIRED"".equals(stereo))
                template.setStereo(GraphicsConfigTemplate.REQUIRED);
            else if (""PREFERRED"".equals(stereo))
                template.setStereo(GraphicsConfigTemplate.PREFERRED);
        }
        return template;
    }

    /**
     * Returns an instance of this singleton.
     */
    public static Component3DManager getInstance() {
        if (instance == null) {
            instance = new Component3DManager();
        }
        return instance;
    }

    /**
     * Sets the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public void setRenderingErrorObserver(RenderingErrorObserver observer) {
        try {
            Class.forName(""javax.media.j3d.RenderingErrorListener"");
            this.renderingErrorListener = RenderingErrorListenerManager.setRenderingErrorObserver(observer, this.renderingErrorListener);
            this.renderingErrorObserver = observer;
        } catch (ClassNotFoundException ex) {
            // As RenderingErrorListener and addRenderingErrorListener are available since Java 3D 1.5,
            // use the default rendering error reporting if Sweet Home 3D is linked to a previous version
        }
    }

    /**
     * Returns the current rendering error listener bound to <code>VirtualUniverse</code>.
     */
    public RenderingErrorObserver getRenderingErrorObserver() {
        return this.renderingErrorObserver;
    }

    /**
     * Returns <code>true</code> if offscreen is supported in Java 3D on user system.
     * Will always return <code>false</code> if <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * system is equal to <code>false</code>. By default, <code>com.eteks.sweethome3d.j3d.checkOffScreenSupport</code>
     * is equal to <code>true</code>.
     */
    public boolean isOffScreenImageSupported() {
        if (this.offScreenImageSupported == null) {
            if (""false"".equalsIgnoreCase(System.getProperty(CHECK_OFF_SCREEN_IMAGE_SUPPORT, ""true""))) {
                this.offScreenImageSupported = Boolean.FALSE;
            } else {
                SimpleUniverse universe = null;
                try {
                    // Create a universe bound to no canvas 3D
                    ViewingPlatform viewingPlatform = new ViewingPlatform();
                    Viewer viewer = new Viewer(new Canvas3D[0]);
                    universe = new SimpleUniverse(viewingPlatform, viewer);
                    // Create a dummy 3D image to check if it can be rendered in current Java 3D configuration
                    getOffScreenImage(viewer.getView(), 1, 1);
                    this.offScreenImageSupported = Boolean.TRUE;
                } catch (IllegalRenderingStateException ex) {
                    this.offScreenImageSupported = Boolean.FALSE;
                } catch (NullPointerException ex) {
                    this.offScreenImageSupported = Boolean.FALSE;
                } catch (IllegalArgumentException ex) {
                    this.offScreenImageSupported = Boolean.FALSE;
                } finally {
                    if (universe != null) {
                        universe.cleanup();
                    }
                }
            }
        }
        return this.offScreenImageSupported;
    }

    /**
     * Returns a new <code>canva3D</code> instance that will call <code>renderingObserver</code>
     * methods during the rendering loop.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    private Canvas3D getCanvas3D(GraphicsConfiguration deviceConfiguration, boolean offscreen, final RenderingObserver renderingObserver) {
        GraphicsConfiguration configuration;
        if (GraphicsEnvironment.isHeadless()) {
            configuration = null;
        } else if (deviceConfiguration == null || deviceConfiguration.getDevice() == this.defaultScreenConfiguration.getDevice()) {
            configuration = this.defaultScreenConfiguration;
        } else {
            GraphicsConfigTemplate3D template = createGraphicsConfigurationTemplate3D();
            configuration = deviceConfiguration.getDevice().getBestConfiguration(template);
            if (configuration == null) {
                configuration = deviceConfiguration.getDevice().getBestConfiguration(new GraphicsConfigTemplate3D());
            }
        }
        if (configuration == null) {
            throw new IllegalRenderingStateException(""Can't create graphics environment for Canvas 3D"");
        }
        try {
            // Ensure unused canvases are freed
            System.gc();
            // Create a Java 3D canvas
            return new Canvas3D(configuration, offscreen) {

                @Override
                public void preRender() {
                    if (renderingObserver != null) {
                        renderingObserver.canvas3DPreRendered(this);
                    }
                }

                @Override
                public void postRender() {
                    if (renderingObserver != null) {
                        renderingObserver.canvas3DPostRendered(this);
                    }
                }

                @Override
                public void postSwap() {
                    if (renderingObserver != null) {
                        renderingObserver.canvas3DSwapped(this);
                    }
                }
            };
        } catch (IllegalArgumentException ex) {
            IllegalRenderingStateException ex2 = new IllegalRenderingStateException(""Can't create Canvas 3D"");
            ex2.initCause(ex);
            throw ex2;
        }
    }

    /**
     * Returns a new on screen <code>canva3D</code> instance. The returned canvas 3D will be associated
     * with the graphics configuration of the default screen device.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D() {
        return getOnscreenCanvas3D(null);
    }

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer. The returned canvas 3D will be associated with the
     * graphics configuration of the default screen device.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(RenderingObserver renderingObserver) {
        return getCanvas3D(null, false, renderingObserver);
    }

    /**
     * Returns a new on screen <code>canva3D</code> instance which rendering will be observed
     * with the given rendering observer.
     * @param renderingObserver an observer of the 3D rendering process of the returned canvas.
     *            Caution: The methods of the observer will be called in 3D rendering loop thread.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     */
    public Canvas3D getOnscreenCanvas3D(GraphicsConfiguration deviceConfiguration, RenderingObserver renderingObserver) {
        return getCanvas3D(deviceConfiguration, false, renderingObserver);
    }

    /**
     * Returns a new off screen <code>canva3D</code> at the given size.
     * @throws IllegalRenderingStateException  if the canvas 3D couldn't be created.
     *    To avoid this exception, call {@link #isOffScreenImageSupported() isOffScreenImageSupported()} first.
     */
    public Canvas3D getOffScreenCanvas3D(int width, int height) {
        Canvas3D offScreenCanvas = getCanvas3D(null, true, null);
        // Configure canvas 3D for offscreen
        Screen3D screen3D = offScreenCanvas.getScreen3D();
        screen3D.setSize(width, height);
        screen3D.setPhysicalScreenWidth(2f);
        screen3D.setPhysicalScreenHeight(2f / width * height);
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        ImageComponent2D imageComponent2D = new ImageComponent2D(ImageComponent2D.FORMAT_RGB, image);
        imageComponent2D.setCapability(ImageComponent2D.ALLOW_IMAGE_READ);
        offScreenCanvas.setOffScreenBuffer(imageComponent2D);
        return offScreenCanvas;
    }

    /**
     * Returns an image at the given size of the 3D <code>view</code>.
     * This image is created with an off screen canvas.
     * @throws IllegalRenderingStateException  if the image couldn't be created.
     */
    public BufferedImage getOffScreenImage(View view, int width, int height) {
        Canvas3D offScreenCanvas = null;
        RenderingErrorObserver previousRenderingErrorObserver = getRenderingErrorObserver();
        try {
            // Replace current rendering error observer by a listener that counts down
            // a latch to check further if a rendering error happened during off screen rendering
            // (rendering error listener is called from a notification thread)
            final CountDownLatch latch = new CountDownLatch(1);
            setRenderingErrorObserver(new RenderingErrorObserver() {

                public void errorOccured(int errorCode, String errorMessage) {
                    latch.countDown();
                }
            });
            // Create an off screen canvas and bind it to view
            offScreenCanvas = getOffScreenCanvas3D(width, height);
            view.addCanvas3D(offScreenCanvas);
            // Render off screen canvas
            offScreenCanvas.renderOffScreenBuffer();
            offScreenCanvas.waitForOffScreenRendering();
            // If latch count becomes equal to 0 during the past instructions or in the coming 10 milliseconds,
            // this means that a rendering error happened
            if (latch.await(10, TimeUnit.MILLISECONDS)) {
                throw new IllegalRenderingStateException(""Off screen rendering unavailable"");
            }
            return offScreenCanvas.getOffScreenBuffer().getImage();
        } catch (InterruptedException ex) {
            IllegalRenderingStateException ex2 = new IllegalRenderingStateException(""Off screen rendering interrupted"");
            ex2.initCause(ex);
            throw ex2;
        } finally {
            if (offScreenCanvas != null) {
                view.removeCanvas3D(offScreenCanvas);
                try {
                    // Free off screen buffer and context
                    offScreenCanvas.setOffScreenBuffer(null);
                } catch (NullPointerException ex) {
                    // Java 3D 1.3 may throw an exception
                }
            }
            // Reset previous rendering error listener
            setRenderingErrorObserver(previousRenderingErrorObserver);
        }
    }

    /**
     * An observer that receives error notifications in Java 3D.
     */
    public static interface RenderingErrorObserver {

        void errorOccured(int errorCode, String errorMessage);
    }

    /**
     * Manages Java 3D 1.5 <code>RenderingErrorListener</code> change matching the given
     * rendering error observer.
     */
    private static class RenderingErrorListenerManager {

        public static Object setRenderingErrorObserver(final RenderingErrorObserver observer, Object previousRenderingErrorListener) {
            if (previousRenderingErrorListener != null) {
                VirtualUniverse.removeRenderingErrorListener((RenderingErrorListener) previousRenderingErrorListener);
            }
            RenderingErrorListener renderingErrorListener = new RenderingErrorListener() {

                public void errorOccurred(RenderingError error) {
                    observer.errorOccured(error.getErrorCode(), error.getErrorMessage());
                }
            };
            VirtualUniverse.addRenderingErrorListener(renderingErrorListener);
            return renderingErrorListener;
        }
    }

    /**
     * An observer that receives notifications during the different steps
     * of the loop rendering a canvas 3D.
     */
    public static interface RenderingObserver {

        /**
         * Called before <code>canvas3D</code> is rendered.
         */
        public void canvas3DPreRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> is rendered.
         */
        public void canvas3DPostRendered(Canvas3D canvas3D);

        /**
         * Called after <code>canvas3D</code> buffer is swapped.
         */
        public void canvas3DSwapped(Canvas3D canvas3D);
    }
}
","// Component3DManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains one unit test case for the {@link Component3DManager#getOnscreenCanvas3D(RenderingObserver)} method.
*/
class Component3DManager_1Test {","// Component3DManager_1Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.GraphicsConfigTemplate;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.GraphicsConfigTemplate3D;
import javax.media.j3d.IllegalRenderingStateException;
import javax.media.j3d.ImageComponent2D;
import javax.media.j3d.RenderingError;
import javax.media.j3d.RenderingErrorListener;
import javax.media.j3d.Screen3D;
import javax.media.j3d.View;
import javax.media.j3d.VirtualUniverse;
import com.sun.j3d.utils.universe.SimpleUniverse;
import com.sun.j3d.utils.universe.Viewer;
import com.sun.j3d.utils.universe.ViewingPlatform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Component3DManager}.
* It contains one unit test case for the {@link Component3DManager#getOnscreenCanvas3D(RenderingObserver)} method.
*/
class Component3DManager_1Test {
"
aceb438a-04e5-4f4c-97cd-4352f5997982,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ModelManager.java
/*
 * ModelManager.java 4 juil. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
        // This class is a singleton
        this.loadedModelNodes = new WeakHashMap<Content, BranchGroup>();
        this.loadingModelObservers = new HashMap<Content, List<ModelObserver>>();
        this.parsedShapes = new WeakHashMap<String, Shape>();
        // Load other optional Loader classes
        List<Class<Loader>> loaderClasses = new ArrayList<Class<Loader>>();
        String loaderClassNames = System.getProperty(ADDITIONAL_LOADER_CLASSES);
        if (loaderClassNames != null) {
            for (String loaderClassName : loaderClassNames.split(""\\s|:"")) {
                try {
                    loaderClasses.add(getLoaderClass(loaderClassName));
                } catch (IllegalArgumentException ex) {
                    System.err.println(""Invalid loader class "" + loaderClassName + "":\n"" + ex.getMessage());
                }
            }
        }
        this.additionalLoaderClasses = loaderClasses.toArray(new Class[loaderClasses.size()]);
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName) {
        try {
            Class<Loader> loaderClass = (Class<Loader>) getClass().getClassLoader().loadClass(loaderClassName);
            if (!Loader.class.isAssignableFrom(loaderClass)) {
                throw new IllegalArgumentException(loaderClassName + "" not a subclass of "" + Loader.class.getName());
            } else if (Modifier.isAbstract(loaderClass.getModifiers()) || !Modifier.isPublic(loaderClass.getModifiers())) {
                throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
            }
            Constructor<Loader> constructor = loaderClass.getConstructor(new Class[0]);
            // Try to instantiate it now to see if it won't cause any problem
            constructor.newInstance(new Object[0]);
            return loaderClass;
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (NoSuchMethodException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (InvocationTargetException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            throw new IllegalArgumentException(loaderClassName + "" constructor not accessible"");
        } catch (InstantiationException ex) {
            throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
        }
    }

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance() {
        if (instance == null) {
            instance = new ModelManager();
        }
        return instance;
    }

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear() {
        if (this.modelsLoader != null) {
            this.modelsLoader.shutdownNow();
            this.modelsLoader = null;
        }
        synchronized (this.loadedModelNodes) {
            this.loadedModelNodes.clear();
        }
    }

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize() {
        return MINIMUM_SIZE;
    }

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node) {
        return getSize(node, new Transform3D());
    }

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation) {
        BoundingBox bounds = getBounds(node, transformation);
        Point3d lower = new Point3d();
        bounds.getLower(lower);
        Point3d upper = new Point3d();
        bounds.getUpper(upper);
        return new Vector3f(Math.max(getMinimumSize(), (float) (upper.x - lower.x)), Math.max(getMinimumSize(), (float) (upper.y - lower.y)), Math.max(getMinimumSize(), (float) (upper.z - lower.z)));
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node) {
        return getBounds(node, new Transform3D());
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation) {
        BoundingBox objectBounds = new BoundingBox(new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));
        computeBounds(node, objectBounds, transformation, !isOrthogonalRotation(transformation));
        Point3d lower = new Point3d();
        objectBounds.getLower(lower);
        if (lower.x == Double.POSITIVE_INFINITY) {
            throw new IllegalArgumentException(""Node has no bounds"");
        }
        return objectBounds;
    }

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90 degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation) {
        Matrix3f matrix = new Matrix3f();
        transformation.get(matrix);
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                // Return false if the matrix contains a value different from 0 1 or -1
                if (Math.abs(matrix.getElement(i, j)) > 1E-6 && Math.abs(matrix.getElement(i, j) - 1) > 1E-6 && Math.abs(matrix.getElement(i, j) + 1) > 1E-6) {
                    return false;
                }
            }
        }
        return true;
    }

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute the bounds of all the node children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeBounds((Node) enumeration.nextElement(), bounds, parentTransformations, transformShapeGeometry);
            }
        } else if (node instanceof Link) {
            computeBounds(((Link) node).getSharedGroup(), bounds, parentTransformations, transformShapeGeometry);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Bounds shapeBounds;
            if (transformShapeGeometry) {
                shapeBounds = computeTransformedGeometryBounds(shape, parentTransformations);
            } else {
                shapeBounds = shape.getBounds();
                shapeBounds.transform(parentTransformations);
            }
            bounds.combine(shapeBounds);
        }
    }

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation) {
        Point3d lower = new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
        Point3d upper = new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
        for (int i = 0, n = shape.numGeometries(); i < n; i++) {
            Geometry geometry = shape.getGeometry(i);
            if (geometry instanceof GeometryArray) {
                GeometryArray geometryArray = (GeometryArray) geometry;
                int vertexCount = geometryArray.getVertexCount();
                Point3f vertex = new Point3f();
                if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                    if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                        float[] vertexData = geometryArray.getInterleavedVertices();
                        int vertexSize = vertexData.length / vertexCount;
                        for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                            vertex.x = vertexData[j];
                            vertex.y = vertexData[j + 1];
                            vertex.z = vertexData[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    } else {
                        float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                        for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                            vertex.x = vertexCoordinates[j];
                            vertex.y = vertexCoordinates[j + 1];
                            vertex.z = vertexCoordinates[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    }
                } else {
                    for (int index = 0; index < vertexCount; index++) {
                        geometryArray.getCoordinate(index, vertex);
                        updateBounds(vertex, transformation, lower, upper);
                    }
                }
            } else {
                Bounds shapeBounds = shape.getBounds();
                shapeBounds.transform(transformation);
                return shapeBounds;
            }
        }
        Bounds shapeBounds = new BoundingBox(lower, upper);
        return shapeBounds;
    }

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper) {
        transformation.transform(vertex);
        if (lower.x > vertex.x) {
            lower.x = vertex.x;
        }
        if (lower.y > vertex.y) {
            lower.y = vertex.y;
        }
        if (lower.z > vertex.z) {
            lower.z = vertex.z;
        }
        if (upper.x < vertex.x) {
            upper.x = vertex.x;
        }
        if (upper.y < vertex.y) {
            upper.y = vertex.y;
        }
        if (upper.z < vertex.z) {
            upper.z = vertex.z;
        }
    }

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width) {
        return new TransformGroup(getNormalizedTransform(node, modelRotation, width));
    }

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width) {
        // Get model bounding box size
        BoundingBox modelBounds = getBounds(node);
        Point3d lower = new Point3d();
        modelBounds.getLower(lower);
        Point3d upper = new Point3d();
        modelBounds.getUpper(upper);
        // Translate model to its center
        Transform3D translation = new Transform3D();
        translation.setTranslation(new Vector3d(-lower.x - (upper.x - lower.x) / 2, -lower.y - (upper.y - lower.y) / 2, -lower.z - (upper.z - lower.z) / 2));
        Transform3D modelTransform;
        if (modelRotation != null) {
            // Get model bounding box size with model rotation
            Matrix3f modelRotationMatrix = new Matrix3f(modelRotation[0][0], modelRotation[0][1], modelRotation[0][2], modelRotation[1][0], modelRotation[1][1], modelRotation[1][2], modelRotation[2][0], modelRotation[2][1], modelRotation[2][2]);
            modelTransform = new Transform3D();
            modelTransform.setRotation(modelRotationMatrix);
            modelTransform.mul(translation);
            BoundingBox rotatedModelBounds = getBounds(node, modelTransform);
            rotatedModelBounds.getLower(lower);
            rotatedModelBounds.getUpper(upper);
        } else {
            modelTransform = translation;
        }
        // Scale model to make it fill a 1 unit wide box
        Transform3D scaleOneTransform = new Transform3D();
        scaleOneTransform.setScale(new Vector3d(width / Math.max(getMinimumSize(), upper.x - lower.x), width / Math.max(getMinimumSize(), upper.y - lower.y), width / Math.max(getMinimumSize(), upper.z - lower.z)));
        scaleOneTransform.mul(modelTransform);
        return scaleOneTransform;
    }

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver) {
        loadModel(content, false, modelObserver);
    }

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver) {
        BranchGroup modelRoot;
        synchronized (this.loadedModelNodes) {
            modelRoot = this.loadedModelNodes.get(content);
        }
        if (modelRoot != null) {
            // Notify cached model to observer with a clone of the model
            modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
        } else if (synchronous) {
            try {
                modelRoot = loadModel(content);
                synchronized (this.loadedModelNodes) {
                    // Store in cache model node for future copies
                    this.loadedModelNodes.put(content, (BranchGroup) modelRoot);
                }
                modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
            } catch (IOException ex) {
                modelObserver.modelError(ex);
            }
        } else if (!EventQueue.isDispatchThread()) {
            throw new IllegalStateException(""Asynchronous call out of Event Dispatch Thread"");
        } else {
            if (this.modelsLoader == null) {
                this.modelsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            }
            List<ModelObserver> observers = this.loadingModelObservers.get(content);
            if (observers != null) {
                // If observers list exists, content model is already being loaded
                // register observer for future notification
                observers.add(modelObserver);
            } else {
                // Create a list of observers that will be notified once content model is loaded
                observers = new ArrayList<ModelObserver>();
                observers.add(modelObserver);
                this.loadingModelObservers.put(content, observers);
                // Load the model in an other thread
                this.modelsLoader.execute(new Runnable() {

                    public void run() {
                        try {
                            final BranchGroup loadedModel = loadModel(content);
                            synchronized (loadedModelNodes) {
                                // Update loaded models cache and notify registered observers
                                loadedModelNodes.put(content, loadedModel);
                            }
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelUpdated((BranchGroup) cloneNode(loadedModel));
                                    }
                                }
                            });
                        } catch (final IOException ex) {
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelError(ex);
                                    }
                                }
                            });
                        }
                    }
                });
            }
        }
    }

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node) {
        // Clone node in a synchronized block because cloneNodeComponent is not thread safe
        synchronized (this.loadedModelNodes) {
            return cloneNode(node, new HashMap<SharedGroup, SharedGroup>());
        }
    }

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups) {
        if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Shape3D clonedShape = (Shape3D) shape.cloneNode(false);
            Appearance appearance = shape.getAppearance();
            if (appearance != null) {
                // Force only duplication of node's appearance except its texture
                Appearance clonedAppearance = (Appearance) appearance.cloneNodeComponent(true);
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    clonedAppearance.setTexture(texture);
                }
                clonedShape.setAppearance(clonedAppearance);
            }
            return clonedShape;
        } else if (node instanceof Link) {
            Link clonedLink = (Link) node.cloneNode(true);
            // Force duplication of shared groups too
            SharedGroup sharedGroup = clonedLink.getSharedGroup();
            if (sharedGroup != null) {
                SharedGroup clonedSharedGroup = clonedSharedGroups.get(sharedGroup);
                if (clonedSharedGroup == null) {
                    clonedSharedGroup = (SharedGroup) cloneNode(sharedGroup, clonedSharedGroups);
                    clonedSharedGroups.put(sharedGroup, clonedSharedGroup);
                }
                clonedLink.setSharedGroup(clonedSharedGroup);
            }
            return clonedLink;
        } else {
            Node clonedNode = node.cloneNode(true);
            if (node instanceof Group) {
                Group group = (Group) node;
                Group clonedGroup = (Group) clonedNode;
                for (int i = 0, n = group.numChildren(); i < n; i++) {
                    Node clonedChild = cloneNode(group.getChild(i), clonedSharedGroups);
                    clonedGroup.addChild(clonedChild);
                }
            }
            return clonedNode;
        }
    }

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException {
        // Ensure we use a URLContent object
        URLContent urlContent;
        if (content instanceof URLContent) {
            urlContent = (URLContent) content;
        } else {
            urlContent = TemporaryURLContent.copyToTemporaryURLContent(content);
        }
        Loader3DS loader3DSWithNoStackTraces = new Loader3DS() {

            @Override
            public Scene load(URL url) throws FileNotFoundException, IncorrectFormatException {
                try {
                    // Check magic number 0x4D4D
                    InputStream in = url.openStream();
                    int b1 = in.read();
                    int b2 = in.read();
                    if (b1 != 0x4D || b2 != 0x4D) {
                        throw new IncorrectFormatException(""Bad magic number"");
                    }
                    in.close();
                } catch (FileNotFoundException ex) {
                    throw ex;
                } catch (IOException ex) {
                    throw new ParsingErrorException(""Can't read url "" + url);
                }
                PrintStream defaultSystemErrorStream = System.err;
                try {
                    // Ignore stack traces on System.err during 3DS file loading
                    System.setErr(new PrintStream(new OutputStream() {

                        @Override
                        public void write(int b) throws IOException {
                            // Do nothing
                        }
                    }));
                    // Default load
                    return super.load(url);
                } finally {
                    // Reset default err print stream
                    System.setErr(defaultSystemErrorStream);
                }
            }
        };
        Loader[] defaultLoaders = new Loader[] { new OBJLoader(), new DAELoader(), loader3DSWithNoStackTraces, new Lw3dLoader() };
        Loader[] loaders = new Loader[defaultLoaders.length + this.additionalLoaderClasses.length];
        System.arraycopy(defaultLoaders, 0, loaders, 0, defaultLoaders.length);
        for (int i = 0; i < this.additionalLoaderClasses.length; i++) {
            try {
                loaders[defaultLoaders.length + i] = this.additionalLoaderClasses[i].newInstance();
            } catch (InstantiationException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            } catch (IllegalAccessException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            }
        }
        Exception lastException = null;
        for (Loader loader : loaders) {
            try {
                // Ask loader to ignore lights, fogs...
                loader.setFlags(loader.getFlags() & ~(Loader.LOAD_LIGHT_NODES | Loader.LOAD_FOG_NODES | Loader.LOAD_BACKGROUND_NODES | Loader.LOAD_VIEW_GROUPS));
                // Return the first scene that can be loaded from model URL content
                Scene scene = loader.load(urlContent.getURL());
                BranchGroup modelNode = scene.getSceneGroup();
                // If model doesn't have any child, consider the file as wrong
                if (modelNode.numChildren() == 0) {
                    throw new IllegalArgumentException(""Empty model"");
                }
                // Update transparency of scene window panes shapes
                updateShapeNamesAndWindowPanesTransparency(scene);
                // Turn off lights because some loaders don't take into account the ~LOAD_LIGHT_NODES flag
                turnOffLightsShareAndModulateTextures(modelNode);
                return modelNode;
            } catch (IllegalArgumentException ex) {
                lastException = ex;
            } catch (IncorrectFormatException ex) {
                lastException = ex;
            } catch (ParsingErrorException ex) {
                lastException = ex;
            } catch (IOException ex) {
                lastException = ex;
            } catch (RuntimeException ex) {
                // Take into account exceptions of Java 3D 1.5 ImageException class
                // in such a way program can run in Java 3D 1.3.1
                if (ex.getClass().getName().equals(""com.sun.j3d.utils.image.ImageException"")) {
                    lastException = ex;
                } else {
                    throw ex;
                }
            }
        }
        if (lastException instanceof IOException) {
            throw (IOException) lastException;
        } else if (lastException instanceof IncorrectFormatException) {
            IOException incorrectFormatException = new IOException(""Incorrect format"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else if (lastException instanceof ParsingErrorException) {
            IOException incorrectFormatException = new IOException(""Parsing error"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else {
            IOException otherException = new IOException();
            otherException.initCause(lastException);
            throw otherException;
        }
    }

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene) {
        Map<String, Object> namedObjects = scene.getNamedObjects();
        for (Map.Entry<String, Object> entry : namedObjects.entrySet()) {
            if (entry.getValue() instanceof Shape3D) {
                String shapeName = entry.getKey();
                // Assign shape name to its user data
                Shape3D shape = (Shape3D) entry.getValue();
                shape.setUserData(shapeName);
                if (shapeName.startsWith(WINDOW_PANE_SHAPE_PREFIX)) {
                    Appearance appearance = shape.getAppearance();
                    if (appearance == null) {
                        appearance = new Appearance();
                        shape.setAppearance(appearance);
                    }
                    if (appearance.getTransparencyAttributes() == null) {
                        appearance.setTransparencyAttributes(WINDOW_PANE_TRANSPARENCY_ATTRIBUTES);
                    }
                }
            }
        }
    }

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node) {
        if (node instanceof Group) {
            // Enumerate children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                turnOffLightsShareAndModulateTextures((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            turnOffLightsShareAndModulateTextures(((Link) node).getSharedGroup());
        } else if (node instanceof Light) {
            ((Light) node).setEnable(false);
        } else if (node instanceof Shape3D) {
            Appearance appearance = ((Shape3D) node).getAppearance();
            if (appearance != null) {
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    // Share textures data as much as possible
                    Texture sharedTexture = TextureManager.getInstance().shareTexture(texture);
                    if (sharedTexture != texture) {
                        appearance.setTexture(sharedTexture);
                    }
                    TextureAttributes textureAttributes = appearance.getTextureAttributes();
                    if (textureAttributes == null) {
                        // Mix texture and shape color
                        textureAttributes = new TextureAttributes();
                        textureAttributes.setTextureMode(TextureAttributes.MODULATE);
                        appearance.setTextureAttributes(textureAttributes);
                        // Check shape color is white
                        Material material = appearance.getMaterial();
                        if (material == null) {
                            appearance.setMaterial((Material) DEFAULT_MATERIAL.cloneNodeComponent(true));
                        } else {
                            Color3f color = new Color3f();
                            DEFAULT_MATERIAL.getDiffuseColor(color);
                            material.setDiffuseColor(color);
                            DEFAULT_MATERIAL.getAmbientColor(color);
                            material.setAmbientColor(color);
                        }
                    }
                    // If texture image supports transparency
                    if (TextureManager.getInstance().isTextureTransparent(sharedTexture)) {
                        if (appearance.getTransparencyAttributes() == null) {
                            // Add transparency attributes to ensure transparency works
                            appearance.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.NICEST, 0));
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node) {
        Area modelAreaOnFloor;
        int vertexCount = getVertexCount(node);
        if (vertexCount < 10000) {
            modelAreaOnFloor = new Area();
            computeAreaOnFloor(node, modelAreaOnFloor, new Transform3D());
        } else {
            List<float[]> vertices = new ArrayList<float[]>(vertexCount);
            computeVerticesOnFloor(node, vertices, new Transform3D());
            float[][] surroundingPolygon = getSurroundingPolygon(vertices.toArray(new float[vertices.size()][]));
            GeneralPath generalPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, surroundingPolygon.length);
            generalPath.moveTo(surroundingPolygon[0][0], surroundingPolygon[0][1]);
            for (int i = 0; i < surroundingPolygon.length; i++) {
                generalPath.lineTo(surroundingPolygon[i][0], surroundingPolygon[i][1]);
            }
            generalPath.closePath();
            modelAreaOnFloor = new Area(generalPath);
        }
        return modelAreaOnFloor;
    }

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node) {
        int count = 0;
        if (node instanceof Group) {
            // Enumerate all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                count += getVertexCount((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            count = getVertexCount(((Link) node).getSharedGroup());
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            if (renderingAttributes == null || renderingAttributes.getVisible()) {
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        count += ((GeometryArray) geometry).getVertexCount();
                    }
                }
            }
        }
        return count;
    }

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeVerticesOnFloor((Node) enumeration.nextElement(), vertices, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeVerticesOnFloor(((Link) node).getSharedGroup(), vertices, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        GeometryArray geometryArray = (GeometryArray) geometry;
                        int vertexCount = geometryArray.getVertexCount();
                        Point3f vertex = new Point3f();
                        if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                            if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                                float[] vertexData = geometryArray.getInterleavedVertices();
                                int vertexSize = vertexData.length / vertexCount;
                                // Store vertices coordinates
                                for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                                    vertex.x = vertexData[j];
                                    vertex.y = vertexData[j + 1];
                                    vertex.z = vertexData[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            } else {
                                // Store vertices coordinates
                                float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                                for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                                    vertex.x = vertexCoordinates[j];
                                    vertex.y = vertexCoordinates[j + 1];
                                    vertex.z = vertexCoordinates[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            }
                        } else {
                            // Store vertices coordinates
                            for (int index = 0, j = 0; index < vertexCount; j++, index++) {
                                geometryArray.getCoordinate(j, vertex);
                                parentTransformations.transform(vertex);
                                vertices.add(new float[] { vertex.x, vertex.z });
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeAreaOnFloor((Node) enumeration.nextElement(), nodeArea, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeAreaOnFloor(((Link) node).getSharedGroup(), nodeArea, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    computeGeometryAreaOnFloor(shape.getGeometry(i), parentTransformations, nodeArea);
                }
            }
        }
    }

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea) {
        if (geometry instanceof GeometryArray) {
            GeometryArray geometryArray = (GeometryArray) geometry;
            int vertexCount = geometryArray.getVertexCount();
            float[] vertices = new float[vertexCount * 2];
            Point3f vertex = new Point3f();
            if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                    float[] vertexData = geometryArray.getInterleavedVertices();
                    int vertexSize = vertexData.length / vertexCount;
                    // Store vertices coordinates
                    for (int index = 0, i = vertexSize - 3; index < vertices.length; i += vertexSize) {
                        vertex.x = vertexData[i];
                        vertex.y = vertexData[i + 1];
                        vertex.z = vertexData[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                } else {
                    // Store vertices coordinates
                    float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                    for (int index = 0, i = 0; index < vertices.length; i += 3) {
                        vertex.x = vertexCoordinates[i];
                        vertex.y = vertexCoordinates[i + 1];
                        vertex.z = vertexCoordinates[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                }
            } else {
                // Store vertices coordinates
                for (int index = 0, i = 0; index < vertices.length; i++) {
                    geometryArray.getCoordinate(i, vertex);
                    parentTransformations.transform(vertex);
                    vertices[index++] = vertex.x;
                    vertices[index++] = vertex.z;
                }
            }
            // Create path from triangles or quadrilaterals of geometry
            GeneralPath geometryPath = null;
            if (geometryArray instanceof IndexedGeometryArray) {
                if (geometryArray instanceof IndexedTriangleArray) {
                    IndexedTriangleArray triangleArray = (IndexedTriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0, n = triangleArray.getIndexCount(); i < n; i += 3) {
                        addIndexedTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedQuadArray) {
                    IndexedQuadArray quadArray = (IndexedQuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0, n = quadArray.getIndexCount(); i < n; i += 4) {
                        addIndexedQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedGeometryStripArray) {
                    IndexedGeometryStripArray geometryStripArray = (IndexedGeometryStripArray) geometryArray;
                    int[] stripIndexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripIndexCounts(stripIndexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof IndexedTriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof IndexedTriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2; i < n; i++) {
                                addIndexedTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    }
                }
            } else {
                if (geometryArray instanceof TriangleArray) {
                    TriangleArray triangleArray = (TriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0; i < vertexCount; i += 3) {
                        addTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof QuadArray) {
                    QuadArray quadArray = (QuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0; i < vertexCount; i += 4) {
                        addQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof GeometryStripArray) {
                    GeometryStripArray geometryStripArray = (GeometryStripArray) geometryArray;
                    int[] stripVertexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripVertexCounts(stripVertexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof TriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof TriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2; i < n; i++) {
                                addTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    }
                }
            }
            if (geometryPath != null) {
                nodeArea.add(new Area(geometryPath));
            }
        }
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        addTriangleToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), vertices, geometryPath, triangleIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        addQuadrilateralToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), geometryArray.getCoordinateIndex(vertexIndex4), vertices, geometryPath, quadrilateralIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (triangleIndex > 0 && triangleIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.closePath();
        }
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (quadrilateralIndex > 0 && quadrilateralIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.lineTo(vertices[2 * vertexIndex4], vertices[2 * vertexIndex4 + 1]);
            geometryPath.closePath();
        }
    }

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices) {
        Arrays.sort(vertices, new Comparator<float[]>() {

            public int compare(float[] vertex1, float[] vertex2) {
                if (vertex1[0] == vertex2[0]) {
                    return (int) Math.signum(vertex2[1] - vertex1[1]);
                } else {
                    return (int) Math.signum(vertex2[0] - vertex1[0]);
                }
            }
        });
        float[][] polygon = new float[vertices.length][];
        // The output array polygon [] will be used as the stack
        // indices for bottom and top of the stack
        int bottom = 0, top = -1;
        // array scan index
        int i;
        // Get the indices of points with min x-coord and min|max y-coord
        int minMin = 0, minMax;
        float xmin = vertices[0][0];
        for (i = 1; i < vertices.length; i++) {
            if (vertices[i][0] != xmin) {
                break;
            }
        }
        minMax = i - 1;
        if (minMax == vertices.length - 1) {
            // Degenerate case: all x-coords == xmin
            polygon[++top] = vertices[minMin];
            if (vertices[minMax][1] != vertices[minMin][1]) {
                // A nontrivial segment
                polygon[++top] = vertices[minMax];
            }
            // Add polygon end point
            polygon[++top] = vertices[minMin];
            float[][] surroundingPolygon = new float[top + 1][];
            System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        }
        // Get the indices of points with max x-coord and min|max y-coord
        int maxMin, maxMax = vertices.length - 1;
        float xMax = vertices[vertices.length - 1][0];
        for (i = vertices.length - 2; i >= 0; i--) {
            if (vertices[i][0] != xMax) {
                break;
            }
        }
        maxMin = i + 1;
        // Compute the lower hull on the stack polygon
        // push minmin point onto stack
        polygon[++top] = vertices[minMin];
        i = minMax;
        while (++i <= maxMin) {
            // The lower line joins points [minmin] with points [maxmin]
            if (isLeft(vertices[minMin], vertices[maxMin], vertices[i]) >= 0 && i < maxMin) {
                // ignore points [i] above or on the lower line
                continue;
            }
            while (// There are at least 2 points on the stack
            top > 0) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0)
                    // points [i] is a new hull vertex
                    break;
                else
                    // pop top point off stack
                    top--;
            }
            // push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        // Next, compute the upper hull on the stack polygon above the bottom hull
        // If distinct xmax points
        if (maxMax != maxMin) {
            // Push maxmax point onto stack
            polygon[++top] = vertices[maxMax];
        }
        // The bottom point of the upper hull stack
        bottom = top;
        i = maxMin;
        while (--i >= minMax) {
            // The upper line joins points [maxmax] with points [minmax]
            if (isLeft(vertices[maxMax], vertices[minMax], vertices[i]) >= 0 && i > minMax) {
                // Ignore points [i] below or on the upper line
                continue;
            }
            // At least 2 points on the upper stack
            while (top > bottom) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0) {
                    // points [i] is a new hull vertex
                    break;
                } else {
                    // Pop top point off stack
                    top--;
                }
            }
            // Push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        if (minMax != minMin) {
            // Push joining endpoint onto stack
            polygon[++top] = vertices[minMin];
        }
        float[][] surroundingPolygon = new float[top + 1][];
        System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        return surroundingPolygon;
    }

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2) {
        return (vertex1[0] - vertex0[0]) * (vertex2[1] - vertex0[1]) - (vertex2[0] - vertex0[0]) * (vertex1[1] - vertex0[1]);
    }

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase) {
        if (staircase.getStaircaseCutOutShape() == null) {
            throw new IllegalArgumentException(""No cut out shape associated to piece"");
        }
        Shape shape = parseShape(staircase.getStaircaseCutOutShape());
        Area staircaseArea = new Area(shape);
        if (staircase.isModelMirrored()) {
            staircaseArea = getMirroredArea(staircaseArea);
        }
        AffineTransform staircaseTransform = AffineTransform.getTranslateInstance(staircase.getX() - staircase.getWidth() / 2, staircase.getY() - staircase.getDepth() / 2);
        staircaseTransform.concatenate(AffineTransform.getRotateInstance(staircase.getAngle(), staircase.getWidth() / 2, staircase.getDepth() / 2));
        staircaseTransform.concatenate(AffineTransform.getScaleInstance(staircase.getWidth(), staircase.getDepth()));
        staircaseArea.transform(staircaseTransform);
        return staircaseArea;
    }

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area) {
        // As applying a -1 scale transform reverses the holes / non holes interpretation of the points,
        // we have to create a mirrored shape by parsing points
        GeneralPath mirrorPath = new GeneralPath();
        float[] point = new float[6];
        for (PathIterator it = area.getPathIterator(null); !it.isDone(); it.next()) {
            switch(it.currentSegment(point)) {
                case PathIterator.SEG_MOVETO:
                    mirrorPath.moveTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_LINETO:
                    mirrorPath.lineTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_QUADTO:
                    mirrorPath.quadTo(1 - point[0], point[1], 1 - point[2], point[3]);
                    break;
                case PathIterator.SEG_CUBICTO:
                    mirrorPath.curveTo(1 - point[0], point[1], 1 - point[2], point[3], 1 - point[4], point[5]);
                    break;
                case PathIterator.SEG_CLOSE:
                    mirrorPath.closePath();
                    break;
            }
        }
        return new Area(mirrorPath);
    }

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape) {
        Shape shape = parsedShapes.get(svgPathShape);
        if (shape == null) {
            try {
                shape = SVGPathSupport.parsePathShape(svgPathShape);
            } catch (LinkageError ex) {
                // Fallback to default square shape if batik classes aren't in classpath
                shape = new Rectangle2D.Float(0, 0, 1, 1);
            }
            parsedShapes.put(svgPathShape, shape);
        }
        return shape;
    }

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#getInstance()} method.
*/
class ModelManager_0Test {","// ModelManager_0Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#getInstance()} method.
*/
class ModelManager_0Test {
"
6c99a4ec-2501-469a-b0a0-a7603ca391c7,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_5Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ModelManager.java
/*
 * ModelManager.java 4 juil. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
        // This class is a singleton
        this.loadedModelNodes = new WeakHashMap<Content, BranchGroup>();
        this.loadingModelObservers = new HashMap<Content, List<ModelObserver>>();
        this.parsedShapes = new WeakHashMap<String, Shape>();
        // Load other optional Loader classes
        List<Class<Loader>> loaderClasses = new ArrayList<Class<Loader>>();
        String loaderClassNames = System.getProperty(ADDITIONAL_LOADER_CLASSES);
        if (loaderClassNames != null) {
            for (String loaderClassName : loaderClassNames.split(""\\s|:"")) {
                try {
                    loaderClasses.add(getLoaderClass(loaderClassName));
                } catch (IllegalArgumentException ex) {
                    System.err.println(""Invalid loader class "" + loaderClassName + "":\n"" + ex.getMessage());
                }
            }
        }
        this.additionalLoaderClasses = loaderClasses.toArray(new Class[loaderClasses.size()]);
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName) {
        try {
            Class<Loader> loaderClass = (Class<Loader>) getClass().getClassLoader().loadClass(loaderClassName);
            if (!Loader.class.isAssignableFrom(loaderClass)) {
                throw new IllegalArgumentException(loaderClassName + "" not a subclass of "" + Loader.class.getName());
            } else if (Modifier.isAbstract(loaderClass.getModifiers()) || !Modifier.isPublic(loaderClass.getModifiers())) {
                throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
            }
            Constructor<Loader> constructor = loaderClass.getConstructor(new Class[0]);
            // Try to instantiate it now to see if it won't cause any problem
            constructor.newInstance(new Object[0]);
            return loaderClass;
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (NoSuchMethodException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (InvocationTargetException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            throw new IllegalArgumentException(loaderClassName + "" constructor not accessible"");
        } catch (InstantiationException ex) {
            throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
        }
    }

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance() {
        if (instance == null) {
            instance = new ModelManager();
        }
        return instance;
    }

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear() {
        if (this.modelsLoader != null) {
            this.modelsLoader.shutdownNow();
            this.modelsLoader = null;
        }
        synchronized (this.loadedModelNodes) {
            this.loadedModelNodes.clear();
        }
    }

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize() {
        return MINIMUM_SIZE;
    }

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node) {
        return getSize(node, new Transform3D());
    }

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation) {
        BoundingBox bounds = getBounds(node, transformation);
        Point3d lower = new Point3d();
        bounds.getLower(lower);
        Point3d upper = new Point3d();
        bounds.getUpper(upper);
        return new Vector3f(Math.max(getMinimumSize(), (float) (upper.x - lower.x)), Math.max(getMinimumSize(), (float) (upper.y - lower.y)), Math.max(getMinimumSize(), (float) (upper.z - lower.z)));
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node) {
        return getBounds(node, new Transform3D());
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation) {
        BoundingBox objectBounds = new BoundingBox(new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));
        computeBounds(node, objectBounds, transformation, !isOrthogonalRotation(transformation));
        Point3d lower = new Point3d();
        objectBounds.getLower(lower);
        if (lower.x == Double.POSITIVE_INFINITY) {
            throw new IllegalArgumentException(""Node has no bounds"");
        }
        return objectBounds;
    }

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90 degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation) {
        Matrix3f matrix = new Matrix3f();
        transformation.get(matrix);
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                // Return false if the matrix contains a value different from 0 1 or -1
                if (Math.abs(matrix.getElement(i, j)) > 1E-6 && Math.abs(matrix.getElement(i, j) - 1) > 1E-6 && Math.abs(matrix.getElement(i, j) + 1) > 1E-6) {
                    return false;
                }
            }
        }
        return true;
    }

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute the bounds of all the node children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeBounds((Node) enumeration.nextElement(), bounds, parentTransformations, transformShapeGeometry);
            }
        } else if (node instanceof Link) {
            computeBounds(((Link) node).getSharedGroup(), bounds, parentTransformations, transformShapeGeometry);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Bounds shapeBounds;
            if (transformShapeGeometry) {
                shapeBounds = computeTransformedGeometryBounds(shape, parentTransformations);
            } else {
                shapeBounds = shape.getBounds();
                shapeBounds.transform(parentTransformations);
            }
            bounds.combine(shapeBounds);
        }
    }

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation) {
        Point3d lower = new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
        Point3d upper = new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
        for (int i = 0, n = shape.numGeometries(); i < n; i++) {
            Geometry geometry = shape.getGeometry(i);
            if (geometry instanceof GeometryArray) {
                GeometryArray geometryArray = (GeometryArray) geometry;
                int vertexCount = geometryArray.getVertexCount();
                Point3f vertex = new Point3f();
                if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                    if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                        float[] vertexData = geometryArray.getInterleavedVertices();
                        int vertexSize = vertexData.length / vertexCount;
                        for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                            vertex.x = vertexData[j];
                            vertex.y = vertexData[j + 1];
                            vertex.z = vertexData[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    } else {
                        float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                        for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                            vertex.x = vertexCoordinates[j];
                            vertex.y = vertexCoordinates[j + 1];
                            vertex.z = vertexCoordinates[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    }
                } else {
                    for (int index = 0; index < vertexCount; index++) {
                        geometryArray.getCoordinate(index, vertex);
                        updateBounds(vertex, transformation, lower, upper);
                    }
                }
            } else {
                Bounds shapeBounds = shape.getBounds();
                shapeBounds.transform(transformation);
                return shapeBounds;
            }
        }
        Bounds shapeBounds = new BoundingBox(lower, upper);
        return shapeBounds;
    }

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper) {
        transformation.transform(vertex);
        if (lower.x > vertex.x) {
            lower.x = vertex.x;
        }
        if (lower.y > vertex.y) {
            lower.y = vertex.y;
        }
        if (lower.z > vertex.z) {
            lower.z = vertex.z;
        }
        if (upper.x < vertex.x) {
            upper.x = vertex.x;
        }
        if (upper.y < vertex.y) {
            upper.y = vertex.y;
        }
        if (upper.z < vertex.z) {
            upper.z = vertex.z;
        }
    }

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width) {
        return new TransformGroup(getNormalizedTransform(node, modelRotation, width));
    }

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width) {
        // Get model bounding box size
        BoundingBox modelBounds = getBounds(node);
        Point3d lower = new Point3d();
        modelBounds.getLower(lower);
        Point3d upper = new Point3d();
        modelBounds.getUpper(upper);
        // Translate model to its center
        Transform3D translation = new Transform3D();
        translation.setTranslation(new Vector3d(-lower.x - (upper.x - lower.x) / 2, -lower.y - (upper.y - lower.y) / 2, -lower.z - (upper.z - lower.z) / 2));
        Transform3D modelTransform;
        if (modelRotation != null) {
            // Get model bounding box size with model rotation
            Matrix3f modelRotationMatrix = new Matrix3f(modelRotation[0][0], modelRotation[0][1], modelRotation[0][2], modelRotation[1][0], modelRotation[1][1], modelRotation[1][2], modelRotation[2][0], modelRotation[2][1], modelRotation[2][2]);
            modelTransform = new Transform3D();
            modelTransform.setRotation(modelRotationMatrix);
            modelTransform.mul(translation);
            BoundingBox rotatedModelBounds = getBounds(node, modelTransform);
            rotatedModelBounds.getLower(lower);
            rotatedModelBounds.getUpper(upper);
        } else {
            modelTransform = translation;
        }
        // Scale model to make it fill a 1 unit wide box
        Transform3D scaleOneTransform = new Transform3D();
        scaleOneTransform.setScale(new Vector3d(width / Math.max(getMinimumSize(), upper.x - lower.x), width / Math.max(getMinimumSize(), upper.y - lower.y), width / Math.max(getMinimumSize(), upper.z - lower.z)));
        scaleOneTransform.mul(modelTransform);
        return scaleOneTransform;
    }

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver) {
        loadModel(content, false, modelObserver);
    }

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver) {
        BranchGroup modelRoot;
        synchronized (this.loadedModelNodes) {
            modelRoot = this.loadedModelNodes.get(content);
        }
        if (modelRoot != null) {
            // Notify cached model to observer with a clone of the model
            modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
        } else if (synchronous) {
            try {
                modelRoot = loadModel(content);
                synchronized (this.loadedModelNodes) {
                    // Store in cache model node for future copies
                    this.loadedModelNodes.put(content, (BranchGroup) modelRoot);
                }
                modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
            } catch (IOException ex) {
                modelObserver.modelError(ex);
            }
        } else if (!EventQueue.isDispatchThread()) {
            throw new IllegalStateException(""Asynchronous call out of Event Dispatch Thread"");
        } else {
            if (this.modelsLoader == null) {
                this.modelsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            }
            List<ModelObserver> observers = this.loadingModelObservers.get(content);
            if (observers != null) {
                // If observers list exists, content model is already being loaded
                // register observer for future notification
                observers.add(modelObserver);
            } else {
                // Create a list of observers that will be notified once content model is loaded
                observers = new ArrayList<ModelObserver>();
                observers.add(modelObserver);
                this.loadingModelObservers.put(content, observers);
                // Load the model in an other thread
                this.modelsLoader.execute(new Runnable() {

                    public void run() {
                        try {
                            final BranchGroup loadedModel = loadModel(content);
                            synchronized (loadedModelNodes) {
                                // Update loaded models cache and notify registered observers
                                loadedModelNodes.put(content, loadedModel);
                            }
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelUpdated((BranchGroup) cloneNode(loadedModel));
                                    }
                                }
                            });
                        } catch (final IOException ex) {
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelError(ex);
                                    }
                                }
                            });
                        }
                    }
                });
            }
        }
    }

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node) {
        // Clone node in a synchronized block because cloneNodeComponent is not thread safe
        synchronized (this.loadedModelNodes) {
            return cloneNode(node, new HashMap<SharedGroup, SharedGroup>());
        }
    }

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups) {
        if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Shape3D clonedShape = (Shape3D) shape.cloneNode(false);
            Appearance appearance = shape.getAppearance();
            if (appearance != null) {
                // Force only duplication of node's appearance except its texture
                Appearance clonedAppearance = (Appearance) appearance.cloneNodeComponent(true);
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    clonedAppearance.setTexture(texture);
                }
                clonedShape.setAppearance(clonedAppearance);
            }
            return clonedShape;
        } else if (node instanceof Link) {
            Link clonedLink = (Link) node.cloneNode(true);
            // Force duplication of shared groups too
            SharedGroup sharedGroup = clonedLink.getSharedGroup();
            if (sharedGroup != null) {
                SharedGroup clonedSharedGroup = clonedSharedGroups.get(sharedGroup);
                if (clonedSharedGroup == null) {
                    clonedSharedGroup = (SharedGroup) cloneNode(sharedGroup, clonedSharedGroups);
                    clonedSharedGroups.put(sharedGroup, clonedSharedGroup);
                }
                clonedLink.setSharedGroup(clonedSharedGroup);
            }
            return clonedLink;
        } else {
            Node clonedNode = node.cloneNode(true);
            if (node instanceof Group) {
                Group group = (Group) node;
                Group clonedGroup = (Group) clonedNode;
                for (int i = 0, n = group.numChildren(); i < n; i++) {
                    Node clonedChild = cloneNode(group.getChild(i), clonedSharedGroups);
                    clonedGroup.addChild(clonedChild);
                }
            }
            return clonedNode;
        }
    }

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException {
        // Ensure we use a URLContent object
        URLContent urlContent;
        if (content instanceof URLContent) {
            urlContent = (URLContent) content;
        } else {
            urlContent = TemporaryURLContent.copyToTemporaryURLContent(content);
        }
        Loader3DS loader3DSWithNoStackTraces = new Loader3DS() {

            @Override
            public Scene load(URL url) throws FileNotFoundException, IncorrectFormatException {
                try {
                    // Check magic number 0x4D4D
                    InputStream in = url.openStream();
                    int b1 = in.read();
                    int b2 = in.read();
                    if (b1 != 0x4D || b2 != 0x4D) {
                        throw new IncorrectFormatException(""Bad magic number"");
                    }
                    in.close();
                } catch (FileNotFoundException ex) {
                    throw ex;
                } catch (IOException ex) {
                    throw new ParsingErrorException(""Can't read url "" + url);
                }
                PrintStream defaultSystemErrorStream = System.err;
                try {
                    // Ignore stack traces on System.err during 3DS file loading
                    System.setErr(new PrintStream(new OutputStream() {

                        @Override
                        public void write(int b) throws IOException {
                            // Do nothing
                        }
                    }));
                    // Default load
                    return super.load(url);
                } finally {
                    // Reset default err print stream
                    System.setErr(defaultSystemErrorStream);
                }
            }
        };
        Loader[] defaultLoaders = new Loader[] { new OBJLoader(), new DAELoader(), loader3DSWithNoStackTraces, new Lw3dLoader() };
        Loader[] loaders = new Loader[defaultLoaders.length + this.additionalLoaderClasses.length];
        System.arraycopy(defaultLoaders, 0, loaders, 0, defaultLoaders.length);
        for (int i = 0; i < this.additionalLoaderClasses.length; i++) {
            try {
                loaders[defaultLoaders.length + i] = this.additionalLoaderClasses[i].newInstance();
            } catch (InstantiationException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            } catch (IllegalAccessException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            }
        }
        Exception lastException = null;
        for (Loader loader : loaders) {
            try {
                // Ask loader to ignore lights, fogs...
                loader.setFlags(loader.getFlags() & ~(Loader.LOAD_LIGHT_NODES | Loader.LOAD_FOG_NODES | Loader.LOAD_BACKGROUND_NODES | Loader.LOAD_VIEW_GROUPS));
                // Return the first scene that can be loaded from model URL content
                Scene scene = loader.load(urlContent.getURL());
                BranchGroup modelNode = scene.getSceneGroup();
                // If model doesn't have any child, consider the file as wrong
                if (modelNode.numChildren() == 0) {
                    throw new IllegalArgumentException(""Empty model"");
                }
                // Update transparency of scene window panes shapes
                updateShapeNamesAndWindowPanesTransparency(scene);
                // Turn off lights because some loaders don't take into account the ~LOAD_LIGHT_NODES flag
                turnOffLightsShareAndModulateTextures(modelNode);
                return modelNode;
            } catch (IllegalArgumentException ex) {
                lastException = ex;
            } catch (IncorrectFormatException ex) {
                lastException = ex;
            } catch (ParsingErrorException ex) {
                lastException = ex;
            } catch (IOException ex) {
                lastException = ex;
            } catch (RuntimeException ex) {
                // Take into account exceptions of Java 3D 1.5 ImageException class
                // in such a way program can run in Java 3D 1.3.1
                if (ex.getClass().getName().equals(""com.sun.j3d.utils.image.ImageException"")) {
                    lastException = ex;
                } else {
                    throw ex;
                }
            }
        }
        if (lastException instanceof IOException) {
            throw (IOException) lastException;
        } else if (lastException instanceof IncorrectFormatException) {
            IOException incorrectFormatException = new IOException(""Incorrect format"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else if (lastException instanceof ParsingErrorException) {
            IOException incorrectFormatException = new IOException(""Parsing error"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else {
            IOException otherException = new IOException();
            otherException.initCause(lastException);
            throw otherException;
        }
    }

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene) {
        Map<String, Object> namedObjects = scene.getNamedObjects();
        for (Map.Entry<String, Object> entry : namedObjects.entrySet()) {
            if (entry.getValue() instanceof Shape3D) {
                String shapeName = entry.getKey();
                // Assign shape name to its user data
                Shape3D shape = (Shape3D) entry.getValue();
                shape.setUserData(shapeName);
                if (shapeName.startsWith(WINDOW_PANE_SHAPE_PREFIX)) {
                    Appearance appearance = shape.getAppearance();
                    if (appearance == null) {
                        appearance = new Appearance();
                        shape.setAppearance(appearance);
                    }
                    if (appearance.getTransparencyAttributes() == null) {
                        appearance.setTransparencyAttributes(WINDOW_PANE_TRANSPARENCY_ATTRIBUTES);
                    }
                }
            }
        }
    }

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node) {
        if (node instanceof Group) {
            // Enumerate children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                turnOffLightsShareAndModulateTextures((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            turnOffLightsShareAndModulateTextures(((Link) node).getSharedGroup());
        } else if (node instanceof Light) {
            ((Light) node).setEnable(false);
        } else if (node instanceof Shape3D) {
            Appearance appearance = ((Shape3D) node).getAppearance();
            if (appearance != null) {
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    // Share textures data as much as possible
                    Texture sharedTexture = TextureManager.getInstance().shareTexture(texture);
                    if (sharedTexture != texture) {
                        appearance.setTexture(sharedTexture);
                    }
                    TextureAttributes textureAttributes = appearance.getTextureAttributes();
                    if (textureAttributes == null) {
                        // Mix texture and shape color
                        textureAttributes = new TextureAttributes();
                        textureAttributes.setTextureMode(TextureAttributes.MODULATE);
                        appearance.setTextureAttributes(textureAttributes);
                        // Check shape color is white
                        Material material = appearance.getMaterial();
                        if (material == null) {
                            appearance.setMaterial((Material) DEFAULT_MATERIAL.cloneNodeComponent(true));
                        } else {
                            Color3f color = new Color3f();
                            DEFAULT_MATERIAL.getDiffuseColor(color);
                            material.setDiffuseColor(color);
                            DEFAULT_MATERIAL.getAmbientColor(color);
                            material.setAmbientColor(color);
                        }
                    }
                    // If texture image supports transparency
                    if (TextureManager.getInstance().isTextureTransparent(sharedTexture)) {
                        if (appearance.getTransparencyAttributes() == null) {
                            // Add transparency attributes to ensure transparency works
                            appearance.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.NICEST, 0));
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node) {
        Area modelAreaOnFloor;
        int vertexCount = getVertexCount(node);
        if (vertexCount < 10000) {
            modelAreaOnFloor = new Area();
            computeAreaOnFloor(node, modelAreaOnFloor, new Transform3D());
        } else {
            List<float[]> vertices = new ArrayList<float[]>(vertexCount);
            computeVerticesOnFloor(node, vertices, new Transform3D());
            float[][] surroundingPolygon = getSurroundingPolygon(vertices.toArray(new float[vertices.size()][]));
            GeneralPath generalPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, surroundingPolygon.length);
            generalPath.moveTo(surroundingPolygon[0][0], surroundingPolygon[0][1]);
            for (int i = 0; i < surroundingPolygon.length; i++) {
                generalPath.lineTo(surroundingPolygon[i][0], surroundingPolygon[i][1]);
            }
            generalPath.closePath();
            modelAreaOnFloor = new Area(generalPath);
        }
        return modelAreaOnFloor;
    }

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node) {
        int count = 0;
        if (node instanceof Group) {
            // Enumerate all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                count += getVertexCount((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            count = getVertexCount(((Link) node).getSharedGroup());
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            if (renderingAttributes == null || renderingAttributes.getVisible()) {
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        count += ((GeometryArray) geometry).getVertexCount();
                    }
                }
            }
        }
        return count;
    }

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeVerticesOnFloor((Node) enumeration.nextElement(), vertices, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeVerticesOnFloor(((Link) node).getSharedGroup(), vertices, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        GeometryArray geometryArray = (GeometryArray) geometry;
                        int vertexCount = geometryArray.getVertexCount();
                        Point3f vertex = new Point3f();
                        if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                            if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                                float[] vertexData = geometryArray.getInterleavedVertices();
                                int vertexSize = vertexData.length / vertexCount;
                                // Store vertices coordinates
                                for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                                    vertex.x = vertexData[j];
                                    vertex.y = vertexData[j + 1];
                                    vertex.z = vertexData[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            } else {
                                // Store vertices coordinates
                                float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                                for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                                    vertex.x = vertexCoordinates[j];
                                    vertex.y = vertexCoordinates[j + 1];
                                    vertex.z = vertexCoordinates[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            }
                        } else {
                            // Store vertices coordinates
                            for (int index = 0, j = 0; index < vertexCount; j++, index++) {
                                geometryArray.getCoordinate(j, vertex);
                                parentTransformations.transform(vertex);
                                vertices.add(new float[] { vertex.x, vertex.z });
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeAreaOnFloor((Node) enumeration.nextElement(), nodeArea, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeAreaOnFloor(((Link) node).getSharedGroup(), nodeArea, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    computeGeometryAreaOnFloor(shape.getGeometry(i), parentTransformations, nodeArea);
                }
            }
        }
    }

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea) {
        if (geometry instanceof GeometryArray) {
            GeometryArray geometryArray = (GeometryArray) geometry;
            int vertexCount = geometryArray.getVertexCount();
            float[] vertices = new float[vertexCount * 2];
            Point3f vertex = new Point3f();
            if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                    float[] vertexData = geometryArray.getInterleavedVertices();
                    int vertexSize = vertexData.length / vertexCount;
                    // Store vertices coordinates
                    for (int index = 0, i = vertexSize - 3; index < vertices.length; i += vertexSize) {
                        vertex.x = vertexData[i];
                        vertex.y = vertexData[i + 1];
                        vertex.z = vertexData[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                } else {
                    // Store vertices coordinates
                    float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                    for (int index = 0, i = 0; index < vertices.length; i += 3) {
                        vertex.x = vertexCoordinates[i];
                        vertex.y = vertexCoordinates[i + 1];
                        vertex.z = vertexCoordinates[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                }
            } else {
                // Store vertices coordinates
                for (int index = 0, i = 0; index < vertices.length; i++) {
                    geometryArray.getCoordinate(i, vertex);
                    parentTransformations.transform(vertex);
                    vertices[index++] = vertex.x;
                    vertices[index++] = vertex.z;
                }
            }
            // Create path from triangles or quadrilaterals of geometry
            GeneralPath geometryPath = null;
            if (geometryArray instanceof IndexedGeometryArray) {
                if (geometryArray instanceof IndexedTriangleArray) {
                    IndexedTriangleArray triangleArray = (IndexedTriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0, n = triangleArray.getIndexCount(); i < n; i += 3) {
                        addIndexedTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedQuadArray) {
                    IndexedQuadArray quadArray = (IndexedQuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0, n = quadArray.getIndexCount(); i < n; i += 4) {
                        addIndexedQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedGeometryStripArray) {
                    IndexedGeometryStripArray geometryStripArray = (IndexedGeometryStripArray) geometryArray;
                    int[] stripIndexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripIndexCounts(stripIndexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof IndexedTriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof IndexedTriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2; i < n; i++) {
                                addIndexedTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    }
                }
            } else {
                if (geometryArray instanceof TriangleArray) {
                    TriangleArray triangleArray = (TriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0; i < vertexCount; i += 3) {
                        addTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof QuadArray) {
                    QuadArray quadArray = (QuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0; i < vertexCount; i += 4) {
                        addQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof GeometryStripArray) {
                    GeometryStripArray geometryStripArray = (GeometryStripArray) geometryArray;
                    int[] stripVertexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripVertexCounts(stripVertexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof TriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof TriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2; i < n; i++) {
                                addTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    }
                }
            }
            if (geometryPath != null) {
                nodeArea.add(new Area(geometryPath));
            }
        }
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        addTriangleToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), vertices, geometryPath, triangleIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        addQuadrilateralToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), geometryArray.getCoordinateIndex(vertexIndex4), vertices, geometryPath, quadrilateralIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (triangleIndex > 0 && triangleIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.closePath();
        }
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (quadrilateralIndex > 0 && quadrilateralIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.lineTo(vertices[2 * vertexIndex4], vertices[2 * vertexIndex4 + 1]);
            geometryPath.closePath();
        }
    }

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices) {
        Arrays.sort(vertices, new Comparator<float[]>() {

            public int compare(float[] vertex1, float[] vertex2) {
                if (vertex1[0] == vertex2[0]) {
                    return (int) Math.signum(vertex2[1] - vertex1[1]);
                } else {
                    return (int) Math.signum(vertex2[0] - vertex1[0]);
                }
            }
        });
        float[][] polygon = new float[vertices.length][];
        // The output array polygon [] will be used as the stack
        // indices for bottom and top of the stack
        int bottom = 0, top = -1;
        // array scan index
        int i;
        // Get the indices of points with min x-coord and min|max y-coord
        int minMin = 0, minMax;
        float xmin = vertices[0][0];
        for (i = 1; i < vertices.length; i++) {
            if (vertices[i][0] != xmin) {
                break;
            }
        }
        minMax = i - 1;
        if (minMax == vertices.length - 1) {
            // Degenerate case: all x-coords == xmin
            polygon[++top] = vertices[minMin];
            if (vertices[minMax][1] != vertices[minMin][1]) {
                // A nontrivial segment
                polygon[++top] = vertices[minMax];
            }
            // Add polygon end point
            polygon[++top] = vertices[minMin];
            float[][] surroundingPolygon = new float[top + 1][];
            System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        }
        // Get the indices of points with max x-coord and min|max y-coord
        int maxMin, maxMax = vertices.length - 1;
        float xMax = vertices[vertices.length - 1][0];
        for (i = vertices.length - 2; i >= 0; i--) {
            if (vertices[i][0] != xMax) {
                break;
            }
        }
        maxMin = i + 1;
        // Compute the lower hull on the stack polygon
        // push minmin point onto stack
        polygon[++top] = vertices[minMin];
        i = minMax;
        while (++i <= maxMin) {
            // The lower line joins points [minmin] with points [maxmin]
            if (isLeft(vertices[minMin], vertices[maxMin], vertices[i]) >= 0 && i < maxMin) {
                // ignore points [i] above or on the lower line
                continue;
            }
            while (// There are at least 2 points on the stack
            top > 0) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0)
                    // points [i] is a new hull vertex
                    break;
                else
                    // pop top point off stack
                    top--;
            }
            // push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        // Next, compute the upper hull on the stack polygon above the bottom hull
        // If distinct xmax points
        if (maxMax != maxMin) {
            // Push maxmax point onto stack
            polygon[++top] = vertices[maxMax];
        }
        // The bottom point of the upper hull stack
        bottom = top;
        i = maxMin;
        while (--i >= minMax) {
            // The upper line joins points [maxmax] with points [minmax]
            if (isLeft(vertices[maxMax], vertices[minMax], vertices[i]) >= 0 && i > minMax) {
                // Ignore points [i] below or on the upper line
                continue;
            }
            // At least 2 points on the upper stack
            while (top > bottom) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0) {
                    // points [i] is a new hull vertex
                    break;
                } else {
                    // Pop top point off stack
                    top--;
                }
            }
            // Push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        if (minMax != minMin) {
            // Push joining endpoint onto stack
            polygon[++top] = vertices[minMin];
        }
        float[][] surroundingPolygon = new float[top + 1][];
        System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        return surroundingPolygon;
    }

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2) {
        return (vertex1[0] - vertex0[0]) * (vertex2[1] - vertex0[1]) - (vertex2[0] - vertex0[0]) * (vertex1[1] - vertex0[1]);
    }

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase) {
        if (staircase.getStaircaseCutOutShape() == null) {
            throw new IllegalArgumentException(""No cut out shape associated to piece"");
        }
        Shape shape = parseShape(staircase.getStaircaseCutOutShape());
        Area staircaseArea = new Area(shape);
        if (staircase.isModelMirrored()) {
            staircaseArea = getMirroredArea(staircaseArea);
        }
        AffineTransform staircaseTransform = AffineTransform.getTranslateInstance(staircase.getX() - staircase.getWidth() / 2, staircase.getY() - staircase.getDepth() / 2);
        staircaseTransform.concatenate(AffineTransform.getRotateInstance(staircase.getAngle(), staircase.getWidth() / 2, staircase.getDepth() / 2));
        staircaseTransform.concatenate(AffineTransform.getScaleInstance(staircase.getWidth(), staircase.getDepth()));
        staircaseArea.transform(staircaseTransform);
        return staircaseArea;
    }

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area) {
        // As applying a -1 scale transform reverses the holes / non holes interpretation of the points,
        // we have to create a mirrored shape by parsing points
        GeneralPath mirrorPath = new GeneralPath();
        float[] point = new float[6];
        for (PathIterator it = area.getPathIterator(null); !it.isDone(); it.next()) {
            switch(it.currentSegment(point)) {
                case PathIterator.SEG_MOVETO:
                    mirrorPath.moveTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_LINETO:
                    mirrorPath.lineTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_QUADTO:
                    mirrorPath.quadTo(1 - point[0], point[1], 1 - point[2], point[3]);
                    break;
                case PathIterator.SEG_CUBICTO:
                    mirrorPath.curveTo(1 - point[0], point[1], 1 - point[2], point[3], 1 - point[4], point[5]);
                    break;
                case PathIterator.SEG_CLOSE:
                    mirrorPath.closePath();
                    break;
            }
        }
        return new Area(mirrorPath);
    }

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape) {
        Shape shape = parsedShapes.get(svgPathShape);
        if (shape == null) {
            try {
                shape = SVGPathSupport.parsePathShape(svgPathShape);
            } catch (LinkageError ex) {
                // Fallback to default square shape if batik classes aren't in classpath
                shape = new Rectangle2D.Float(0, 0, 1, 1);
            }
            parsedShapes.put(svgPathShape, shape);
        }
        return shape;
    }

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_5Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#getNormalizedTransformGroup(Node, float[][], float)} method.
*/
class ModelManager_5Test {","// ModelManager_5Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#getNormalizedTransformGroup(Node, float[][], float)} method.
*/
class ModelManager_5Test {
"
94915479-f8a6-4a0b-9d03-488fbb589430,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_6Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ModelManager.java
/*
 * ModelManager.java 4 juil. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
        // This class is a singleton
        this.loadedModelNodes = new WeakHashMap<Content, BranchGroup>();
        this.loadingModelObservers = new HashMap<Content, List<ModelObserver>>();
        this.parsedShapes = new WeakHashMap<String, Shape>();
        // Load other optional Loader classes
        List<Class<Loader>> loaderClasses = new ArrayList<Class<Loader>>();
        String loaderClassNames = System.getProperty(ADDITIONAL_LOADER_CLASSES);
        if (loaderClassNames != null) {
            for (String loaderClassName : loaderClassNames.split(""\\s|:"")) {
                try {
                    loaderClasses.add(getLoaderClass(loaderClassName));
                } catch (IllegalArgumentException ex) {
                    System.err.println(""Invalid loader class "" + loaderClassName + "":\n"" + ex.getMessage());
                }
            }
        }
        this.additionalLoaderClasses = loaderClasses.toArray(new Class[loaderClasses.size()]);
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName) {
        try {
            Class<Loader> loaderClass = (Class<Loader>) getClass().getClassLoader().loadClass(loaderClassName);
            if (!Loader.class.isAssignableFrom(loaderClass)) {
                throw new IllegalArgumentException(loaderClassName + "" not a subclass of "" + Loader.class.getName());
            } else if (Modifier.isAbstract(loaderClass.getModifiers()) || !Modifier.isPublic(loaderClass.getModifiers())) {
                throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
            }
            Constructor<Loader> constructor = loaderClass.getConstructor(new Class[0]);
            // Try to instantiate it now to see if it won't cause any problem
            constructor.newInstance(new Object[0]);
            return loaderClass;
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (NoSuchMethodException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (InvocationTargetException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            throw new IllegalArgumentException(loaderClassName + "" constructor not accessible"");
        } catch (InstantiationException ex) {
            throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
        }
    }

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance() {
        if (instance == null) {
            instance = new ModelManager();
        }
        return instance;
    }

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear() {
        if (this.modelsLoader != null) {
            this.modelsLoader.shutdownNow();
            this.modelsLoader = null;
        }
        synchronized (this.loadedModelNodes) {
            this.loadedModelNodes.clear();
        }
    }

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize() {
        return MINIMUM_SIZE;
    }

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node) {
        return getSize(node, new Transform3D());
    }

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation) {
        BoundingBox bounds = getBounds(node, transformation);
        Point3d lower = new Point3d();
        bounds.getLower(lower);
        Point3d upper = new Point3d();
        bounds.getUpper(upper);
        return new Vector3f(Math.max(getMinimumSize(), (float) (upper.x - lower.x)), Math.max(getMinimumSize(), (float) (upper.y - lower.y)), Math.max(getMinimumSize(), (float) (upper.z - lower.z)));
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node) {
        return getBounds(node, new Transform3D());
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation) {
        BoundingBox objectBounds = new BoundingBox(new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));
        computeBounds(node, objectBounds, transformation, !isOrthogonalRotation(transformation));
        Point3d lower = new Point3d();
        objectBounds.getLower(lower);
        if (lower.x == Double.POSITIVE_INFINITY) {
            throw new IllegalArgumentException(""Node has no bounds"");
        }
        return objectBounds;
    }

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90 degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation) {
        Matrix3f matrix = new Matrix3f();
        transformation.get(matrix);
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                // Return false if the matrix contains a value different from 0 1 or -1
                if (Math.abs(matrix.getElement(i, j)) > 1E-6 && Math.abs(matrix.getElement(i, j) - 1) > 1E-6 && Math.abs(matrix.getElement(i, j) + 1) > 1E-6) {
                    return false;
                }
            }
        }
        return true;
    }

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute the bounds of all the node children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeBounds((Node) enumeration.nextElement(), bounds, parentTransformations, transformShapeGeometry);
            }
        } else if (node instanceof Link) {
            computeBounds(((Link) node).getSharedGroup(), bounds, parentTransformations, transformShapeGeometry);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Bounds shapeBounds;
            if (transformShapeGeometry) {
                shapeBounds = computeTransformedGeometryBounds(shape, parentTransformations);
            } else {
                shapeBounds = shape.getBounds();
                shapeBounds.transform(parentTransformations);
            }
            bounds.combine(shapeBounds);
        }
    }

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation) {
        Point3d lower = new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
        Point3d upper = new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
        for (int i = 0, n = shape.numGeometries(); i < n; i++) {
            Geometry geometry = shape.getGeometry(i);
            if (geometry instanceof GeometryArray) {
                GeometryArray geometryArray = (GeometryArray) geometry;
                int vertexCount = geometryArray.getVertexCount();
                Point3f vertex = new Point3f();
                if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                    if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                        float[] vertexData = geometryArray.getInterleavedVertices();
                        int vertexSize = vertexData.length / vertexCount;
                        for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                            vertex.x = vertexData[j];
                            vertex.y = vertexData[j + 1];
                            vertex.z = vertexData[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    } else {
                        float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                        for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                            vertex.x = vertexCoordinates[j];
                            vertex.y = vertexCoordinates[j + 1];
                            vertex.z = vertexCoordinates[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    }
                } else {
                    for (int index = 0; index < vertexCount; index++) {
                        geometryArray.getCoordinate(index, vertex);
                        updateBounds(vertex, transformation, lower, upper);
                    }
                }
            } else {
                Bounds shapeBounds = shape.getBounds();
                shapeBounds.transform(transformation);
                return shapeBounds;
            }
        }
        Bounds shapeBounds = new BoundingBox(lower, upper);
        return shapeBounds;
    }

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper) {
        transformation.transform(vertex);
        if (lower.x > vertex.x) {
            lower.x = vertex.x;
        }
        if (lower.y > vertex.y) {
            lower.y = vertex.y;
        }
        if (lower.z > vertex.z) {
            lower.z = vertex.z;
        }
        if (upper.x < vertex.x) {
            upper.x = vertex.x;
        }
        if (upper.y < vertex.y) {
            upper.y = vertex.y;
        }
        if (upper.z < vertex.z) {
            upper.z = vertex.z;
        }
    }

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width) {
        return new TransformGroup(getNormalizedTransform(node, modelRotation, width));
    }

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width) {
        // Get model bounding box size
        BoundingBox modelBounds = getBounds(node);
        Point3d lower = new Point3d();
        modelBounds.getLower(lower);
        Point3d upper = new Point3d();
        modelBounds.getUpper(upper);
        // Translate model to its center
        Transform3D translation = new Transform3D();
        translation.setTranslation(new Vector3d(-lower.x - (upper.x - lower.x) / 2, -lower.y - (upper.y - lower.y) / 2, -lower.z - (upper.z - lower.z) / 2));
        Transform3D modelTransform;
        if (modelRotation != null) {
            // Get model bounding box size with model rotation
            Matrix3f modelRotationMatrix = new Matrix3f(modelRotation[0][0], modelRotation[0][1], modelRotation[0][2], modelRotation[1][0], modelRotation[1][1], modelRotation[1][2], modelRotation[2][0], modelRotation[2][1], modelRotation[2][2]);
            modelTransform = new Transform3D();
            modelTransform.setRotation(modelRotationMatrix);
            modelTransform.mul(translation);
            BoundingBox rotatedModelBounds = getBounds(node, modelTransform);
            rotatedModelBounds.getLower(lower);
            rotatedModelBounds.getUpper(upper);
        } else {
            modelTransform = translation;
        }
        // Scale model to make it fill a 1 unit wide box
        Transform3D scaleOneTransform = new Transform3D();
        scaleOneTransform.setScale(new Vector3d(width / Math.max(getMinimumSize(), upper.x - lower.x), width / Math.max(getMinimumSize(), upper.y - lower.y), width / Math.max(getMinimumSize(), upper.z - lower.z)));
        scaleOneTransform.mul(modelTransform);
        return scaleOneTransform;
    }

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver) {
        loadModel(content, false, modelObserver);
    }

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver) {
        BranchGroup modelRoot;
        synchronized (this.loadedModelNodes) {
            modelRoot = this.loadedModelNodes.get(content);
        }
        if (modelRoot != null) {
            // Notify cached model to observer with a clone of the model
            modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
        } else if (synchronous) {
            try {
                modelRoot = loadModel(content);
                synchronized (this.loadedModelNodes) {
                    // Store in cache model node for future copies
                    this.loadedModelNodes.put(content, (BranchGroup) modelRoot);
                }
                modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
            } catch (IOException ex) {
                modelObserver.modelError(ex);
            }
        } else if (!EventQueue.isDispatchThread()) {
            throw new IllegalStateException(""Asynchronous call out of Event Dispatch Thread"");
        } else {
            if (this.modelsLoader == null) {
                this.modelsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            }
            List<ModelObserver> observers = this.loadingModelObservers.get(content);
            if (observers != null) {
                // If observers list exists, content model is already being loaded
                // register observer for future notification
                observers.add(modelObserver);
            } else {
                // Create a list of observers that will be notified once content model is loaded
                observers = new ArrayList<ModelObserver>();
                observers.add(modelObserver);
                this.loadingModelObservers.put(content, observers);
                // Load the model in an other thread
                this.modelsLoader.execute(new Runnable() {

                    public void run() {
                        try {
                            final BranchGroup loadedModel = loadModel(content);
                            synchronized (loadedModelNodes) {
                                // Update loaded models cache and notify registered observers
                                loadedModelNodes.put(content, loadedModel);
                            }
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelUpdated((BranchGroup) cloneNode(loadedModel));
                                    }
                                }
                            });
                        } catch (final IOException ex) {
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelError(ex);
                                    }
                                }
                            });
                        }
                    }
                });
            }
        }
    }

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node) {
        // Clone node in a synchronized block because cloneNodeComponent is not thread safe
        synchronized (this.loadedModelNodes) {
            return cloneNode(node, new HashMap<SharedGroup, SharedGroup>());
        }
    }

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups) {
        if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Shape3D clonedShape = (Shape3D) shape.cloneNode(false);
            Appearance appearance = shape.getAppearance();
            if (appearance != null) {
                // Force only duplication of node's appearance except its texture
                Appearance clonedAppearance = (Appearance) appearance.cloneNodeComponent(true);
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    clonedAppearance.setTexture(texture);
                }
                clonedShape.setAppearance(clonedAppearance);
            }
            return clonedShape;
        } else if (node instanceof Link) {
            Link clonedLink = (Link) node.cloneNode(true);
            // Force duplication of shared groups too
            SharedGroup sharedGroup = clonedLink.getSharedGroup();
            if (sharedGroup != null) {
                SharedGroup clonedSharedGroup = clonedSharedGroups.get(sharedGroup);
                if (clonedSharedGroup == null) {
                    clonedSharedGroup = (SharedGroup) cloneNode(sharedGroup, clonedSharedGroups);
                    clonedSharedGroups.put(sharedGroup, clonedSharedGroup);
                }
                clonedLink.setSharedGroup(clonedSharedGroup);
            }
            return clonedLink;
        } else {
            Node clonedNode = node.cloneNode(true);
            if (node instanceof Group) {
                Group group = (Group) node;
                Group clonedGroup = (Group) clonedNode;
                for (int i = 0, n = group.numChildren(); i < n; i++) {
                    Node clonedChild = cloneNode(group.getChild(i), clonedSharedGroups);
                    clonedGroup.addChild(clonedChild);
                }
            }
            return clonedNode;
        }
    }

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException {
        // Ensure we use a URLContent object
        URLContent urlContent;
        if (content instanceof URLContent) {
            urlContent = (URLContent) content;
        } else {
            urlContent = TemporaryURLContent.copyToTemporaryURLContent(content);
        }
        Loader3DS loader3DSWithNoStackTraces = new Loader3DS() {

            @Override
            public Scene load(URL url) throws FileNotFoundException, IncorrectFormatException {
                try {
                    // Check magic number 0x4D4D
                    InputStream in = url.openStream();
                    int b1 = in.read();
                    int b2 = in.read();
                    if (b1 != 0x4D || b2 != 0x4D) {
                        throw new IncorrectFormatException(""Bad magic number"");
                    }
                    in.close();
                } catch (FileNotFoundException ex) {
                    throw ex;
                } catch (IOException ex) {
                    throw new ParsingErrorException(""Can't read url "" + url);
                }
                PrintStream defaultSystemErrorStream = System.err;
                try {
                    // Ignore stack traces on System.err during 3DS file loading
                    System.setErr(new PrintStream(new OutputStream() {

                        @Override
                        public void write(int b) throws IOException {
                            // Do nothing
                        }
                    }));
                    // Default load
                    return super.load(url);
                } finally {
                    // Reset default err print stream
                    System.setErr(defaultSystemErrorStream);
                }
            }
        };
        Loader[] defaultLoaders = new Loader[] { new OBJLoader(), new DAELoader(), loader3DSWithNoStackTraces, new Lw3dLoader() };
        Loader[] loaders = new Loader[defaultLoaders.length + this.additionalLoaderClasses.length];
        System.arraycopy(defaultLoaders, 0, loaders, 0, defaultLoaders.length);
        for (int i = 0; i < this.additionalLoaderClasses.length; i++) {
            try {
                loaders[defaultLoaders.length + i] = this.additionalLoaderClasses[i].newInstance();
            } catch (InstantiationException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            } catch (IllegalAccessException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            }
        }
        Exception lastException = null;
        for (Loader loader : loaders) {
            try {
                // Ask loader to ignore lights, fogs...
                loader.setFlags(loader.getFlags() & ~(Loader.LOAD_LIGHT_NODES | Loader.LOAD_FOG_NODES | Loader.LOAD_BACKGROUND_NODES | Loader.LOAD_VIEW_GROUPS));
                // Return the first scene that can be loaded from model URL content
                Scene scene = loader.load(urlContent.getURL());
                BranchGroup modelNode = scene.getSceneGroup();
                // If model doesn't have any child, consider the file as wrong
                if (modelNode.numChildren() == 0) {
                    throw new IllegalArgumentException(""Empty model"");
                }
                // Update transparency of scene window panes shapes
                updateShapeNamesAndWindowPanesTransparency(scene);
                // Turn off lights because some loaders don't take into account the ~LOAD_LIGHT_NODES flag
                turnOffLightsShareAndModulateTextures(modelNode);
                return modelNode;
            } catch (IllegalArgumentException ex) {
                lastException = ex;
            } catch (IncorrectFormatException ex) {
                lastException = ex;
            } catch (ParsingErrorException ex) {
                lastException = ex;
            } catch (IOException ex) {
                lastException = ex;
            } catch (RuntimeException ex) {
                // Take into account exceptions of Java 3D 1.5 ImageException class
                // in such a way program can run in Java 3D 1.3.1
                if (ex.getClass().getName().equals(""com.sun.j3d.utils.image.ImageException"")) {
                    lastException = ex;
                } else {
                    throw ex;
                }
            }
        }
        if (lastException instanceof IOException) {
            throw (IOException) lastException;
        } else if (lastException instanceof IncorrectFormatException) {
            IOException incorrectFormatException = new IOException(""Incorrect format"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else if (lastException instanceof ParsingErrorException) {
            IOException incorrectFormatException = new IOException(""Parsing error"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else {
            IOException otherException = new IOException();
            otherException.initCause(lastException);
            throw otherException;
        }
    }

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene) {
        Map<String, Object> namedObjects = scene.getNamedObjects();
        for (Map.Entry<String, Object> entry : namedObjects.entrySet()) {
            if (entry.getValue() instanceof Shape3D) {
                String shapeName = entry.getKey();
                // Assign shape name to its user data
                Shape3D shape = (Shape3D) entry.getValue();
                shape.setUserData(shapeName);
                if (shapeName.startsWith(WINDOW_PANE_SHAPE_PREFIX)) {
                    Appearance appearance = shape.getAppearance();
                    if (appearance == null) {
                        appearance = new Appearance();
                        shape.setAppearance(appearance);
                    }
                    if (appearance.getTransparencyAttributes() == null) {
                        appearance.setTransparencyAttributes(WINDOW_PANE_TRANSPARENCY_ATTRIBUTES);
                    }
                }
            }
        }
    }

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node) {
        if (node instanceof Group) {
            // Enumerate children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                turnOffLightsShareAndModulateTextures((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            turnOffLightsShareAndModulateTextures(((Link) node).getSharedGroup());
        } else if (node instanceof Light) {
            ((Light) node).setEnable(false);
        } else if (node instanceof Shape3D) {
            Appearance appearance = ((Shape3D) node).getAppearance();
            if (appearance != null) {
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    // Share textures data as much as possible
                    Texture sharedTexture = TextureManager.getInstance().shareTexture(texture);
                    if (sharedTexture != texture) {
                        appearance.setTexture(sharedTexture);
                    }
                    TextureAttributes textureAttributes = appearance.getTextureAttributes();
                    if (textureAttributes == null) {
                        // Mix texture and shape color
                        textureAttributes = new TextureAttributes();
                        textureAttributes.setTextureMode(TextureAttributes.MODULATE);
                        appearance.setTextureAttributes(textureAttributes);
                        // Check shape color is white
                        Material material = appearance.getMaterial();
                        if (material == null) {
                            appearance.setMaterial((Material) DEFAULT_MATERIAL.cloneNodeComponent(true));
                        } else {
                            Color3f color = new Color3f();
                            DEFAULT_MATERIAL.getDiffuseColor(color);
                            material.setDiffuseColor(color);
                            DEFAULT_MATERIAL.getAmbientColor(color);
                            material.setAmbientColor(color);
                        }
                    }
                    // If texture image supports transparency
                    if (TextureManager.getInstance().isTextureTransparent(sharedTexture)) {
                        if (appearance.getTransparencyAttributes() == null) {
                            // Add transparency attributes to ensure transparency works
                            appearance.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.NICEST, 0));
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node) {
        Area modelAreaOnFloor;
        int vertexCount = getVertexCount(node);
        if (vertexCount < 10000) {
            modelAreaOnFloor = new Area();
            computeAreaOnFloor(node, modelAreaOnFloor, new Transform3D());
        } else {
            List<float[]> vertices = new ArrayList<float[]>(vertexCount);
            computeVerticesOnFloor(node, vertices, new Transform3D());
            float[][] surroundingPolygon = getSurroundingPolygon(vertices.toArray(new float[vertices.size()][]));
            GeneralPath generalPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, surroundingPolygon.length);
            generalPath.moveTo(surroundingPolygon[0][0], surroundingPolygon[0][1]);
            for (int i = 0; i < surroundingPolygon.length; i++) {
                generalPath.lineTo(surroundingPolygon[i][0], surroundingPolygon[i][1]);
            }
            generalPath.closePath();
            modelAreaOnFloor = new Area(generalPath);
        }
        return modelAreaOnFloor;
    }

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node) {
        int count = 0;
        if (node instanceof Group) {
            // Enumerate all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                count += getVertexCount((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            count = getVertexCount(((Link) node).getSharedGroup());
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            if (renderingAttributes == null || renderingAttributes.getVisible()) {
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        count += ((GeometryArray) geometry).getVertexCount();
                    }
                }
            }
        }
        return count;
    }

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeVerticesOnFloor((Node) enumeration.nextElement(), vertices, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeVerticesOnFloor(((Link) node).getSharedGroup(), vertices, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        GeometryArray geometryArray = (GeometryArray) geometry;
                        int vertexCount = geometryArray.getVertexCount();
                        Point3f vertex = new Point3f();
                        if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                            if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                                float[] vertexData = geometryArray.getInterleavedVertices();
                                int vertexSize = vertexData.length / vertexCount;
                                // Store vertices coordinates
                                for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                                    vertex.x = vertexData[j];
                                    vertex.y = vertexData[j + 1];
                                    vertex.z = vertexData[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            } else {
                                // Store vertices coordinates
                                float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                                for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                                    vertex.x = vertexCoordinates[j];
                                    vertex.y = vertexCoordinates[j + 1];
                                    vertex.z = vertexCoordinates[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            }
                        } else {
                            // Store vertices coordinates
                            for (int index = 0, j = 0; index < vertexCount; j++, index++) {
                                geometryArray.getCoordinate(j, vertex);
                                parentTransformations.transform(vertex);
                                vertices.add(new float[] { vertex.x, vertex.z });
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeAreaOnFloor((Node) enumeration.nextElement(), nodeArea, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeAreaOnFloor(((Link) node).getSharedGroup(), nodeArea, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    computeGeometryAreaOnFloor(shape.getGeometry(i), parentTransformations, nodeArea);
                }
            }
        }
    }

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea) {
        if (geometry instanceof GeometryArray) {
            GeometryArray geometryArray = (GeometryArray) geometry;
            int vertexCount = geometryArray.getVertexCount();
            float[] vertices = new float[vertexCount * 2];
            Point3f vertex = new Point3f();
            if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                    float[] vertexData = geometryArray.getInterleavedVertices();
                    int vertexSize = vertexData.length / vertexCount;
                    // Store vertices coordinates
                    for (int index = 0, i = vertexSize - 3; index < vertices.length; i += vertexSize) {
                        vertex.x = vertexData[i];
                        vertex.y = vertexData[i + 1];
                        vertex.z = vertexData[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                } else {
                    // Store vertices coordinates
                    float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                    for (int index = 0, i = 0; index < vertices.length; i += 3) {
                        vertex.x = vertexCoordinates[i];
                        vertex.y = vertexCoordinates[i + 1];
                        vertex.z = vertexCoordinates[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                }
            } else {
                // Store vertices coordinates
                for (int index = 0, i = 0; index < vertices.length; i++) {
                    geometryArray.getCoordinate(i, vertex);
                    parentTransformations.transform(vertex);
                    vertices[index++] = vertex.x;
                    vertices[index++] = vertex.z;
                }
            }
            // Create path from triangles or quadrilaterals of geometry
            GeneralPath geometryPath = null;
            if (geometryArray instanceof IndexedGeometryArray) {
                if (geometryArray instanceof IndexedTriangleArray) {
                    IndexedTriangleArray triangleArray = (IndexedTriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0, n = triangleArray.getIndexCount(); i < n; i += 3) {
                        addIndexedTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedQuadArray) {
                    IndexedQuadArray quadArray = (IndexedQuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0, n = quadArray.getIndexCount(); i < n; i += 4) {
                        addIndexedQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedGeometryStripArray) {
                    IndexedGeometryStripArray geometryStripArray = (IndexedGeometryStripArray) geometryArray;
                    int[] stripIndexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripIndexCounts(stripIndexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof IndexedTriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof IndexedTriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2; i < n; i++) {
                                addIndexedTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    }
                }
            } else {
                if (geometryArray instanceof TriangleArray) {
                    TriangleArray triangleArray = (TriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0; i < vertexCount; i += 3) {
                        addTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof QuadArray) {
                    QuadArray quadArray = (QuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0; i < vertexCount; i += 4) {
                        addQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof GeometryStripArray) {
                    GeometryStripArray geometryStripArray = (GeometryStripArray) geometryArray;
                    int[] stripVertexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripVertexCounts(stripVertexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof TriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof TriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2; i < n; i++) {
                                addTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    }
                }
            }
            if (geometryPath != null) {
                nodeArea.add(new Area(geometryPath));
            }
        }
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        addTriangleToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), vertices, geometryPath, triangleIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        addQuadrilateralToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), geometryArray.getCoordinateIndex(vertexIndex4), vertices, geometryPath, quadrilateralIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (triangleIndex > 0 && triangleIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.closePath();
        }
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (quadrilateralIndex > 0 && quadrilateralIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.lineTo(vertices[2 * vertexIndex4], vertices[2 * vertexIndex4 + 1]);
            geometryPath.closePath();
        }
    }

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices) {
        Arrays.sort(vertices, new Comparator<float[]>() {

            public int compare(float[] vertex1, float[] vertex2) {
                if (vertex1[0] == vertex2[0]) {
                    return (int) Math.signum(vertex2[1] - vertex1[1]);
                } else {
                    return (int) Math.signum(vertex2[0] - vertex1[0]);
                }
            }
        });
        float[][] polygon = new float[vertices.length][];
        // The output array polygon [] will be used as the stack
        // indices for bottom and top of the stack
        int bottom = 0, top = -1;
        // array scan index
        int i;
        // Get the indices of points with min x-coord and min|max y-coord
        int minMin = 0, minMax;
        float xmin = vertices[0][0];
        for (i = 1; i < vertices.length; i++) {
            if (vertices[i][0] != xmin) {
                break;
            }
        }
        minMax = i - 1;
        if (minMax == vertices.length - 1) {
            // Degenerate case: all x-coords == xmin
            polygon[++top] = vertices[minMin];
            if (vertices[minMax][1] != vertices[minMin][1]) {
                // A nontrivial segment
                polygon[++top] = vertices[minMax];
            }
            // Add polygon end point
            polygon[++top] = vertices[minMin];
            float[][] surroundingPolygon = new float[top + 1][];
            System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        }
        // Get the indices of points with max x-coord and min|max y-coord
        int maxMin, maxMax = vertices.length - 1;
        float xMax = vertices[vertices.length - 1][0];
        for (i = vertices.length - 2; i >= 0; i--) {
            if (vertices[i][0] != xMax) {
                break;
            }
        }
        maxMin = i + 1;
        // Compute the lower hull on the stack polygon
        // push minmin point onto stack
        polygon[++top] = vertices[minMin];
        i = minMax;
        while (++i <= maxMin) {
            // The lower line joins points [minmin] with points [maxmin]
            if (isLeft(vertices[minMin], vertices[maxMin], vertices[i]) >= 0 && i < maxMin) {
                // ignore points [i] above or on the lower line
                continue;
            }
            while (// There are at least 2 points on the stack
            top > 0) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0)
                    // points [i] is a new hull vertex
                    break;
                else
                    // pop top point off stack
                    top--;
            }
            // push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        // Next, compute the upper hull on the stack polygon above the bottom hull
        // If distinct xmax points
        if (maxMax != maxMin) {
            // Push maxmax point onto stack
            polygon[++top] = vertices[maxMax];
        }
        // The bottom point of the upper hull stack
        bottom = top;
        i = maxMin;
        while (--i >= minMax) {
            // The upper line joins points [maxmax] with points [minmax]
            if (isLeft(vertices[maxMax], vertices[minMax], vertices[i]) >= 0 && i > minMax) {
                // Ignore points [i] below or on the upper line
                continue;
            }
            // At least 2 points on the upper stack
            while (top > bottom) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0) {
                    // points [i] is a new hull vertex
                    break;
                } else {
                    // Pop top point off stack
                    top--;
                }
            }
            // Push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        if (minMax != minMin) {
            // Push joining endpoint onto stack
            polygon[++top] = vertices[minMin];
        }
        float[][] surroundingPolygon = new float[top + 1][];
        System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        return surroundingPolygon;
    }

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2) {
        return (vertex1[0] - vertex0[0]) * (vertex2[1] - vertex0[1]) - (vertex2[0] - vertex0[0]) * (vertex1[1] - vertex0[1]);
    }

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase) {
        if (staircase.getStaircaseCutOutShape() == null) {
            throw new IllegalArgumentException(""No cut out shape associated to piece"");
        }
        Shape shape = parseShape(staircase.getStaircaseCutOutShape());
        Area staircaseArea = new Area(shape);
        if (staircase.isModelMirrored()) {
            staircaseArea = getMirroredArea(staircaseArea);
        }
        AffineTransform staircaseTransform = AffineTransform.getTranslateInstance(staircase.getX() - staircase.getWidth() / 2, staircase.getY() - staircase.getDepth() / 2);
        staircaseTransform.concatenate(AffineTransform.getRotateInstance(staircase.getAngle(), staircase.getWidth() / 2, staircase.getDepth() / 2));
        staircaseTransform.concatenate(AffineTransform.getScaleInstance(staircase.getWidth(), staircase.getDepth()));
        staircaseArea.transform(staircaseTransform);
        return staircaseArea;
    }

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area) {
        // As applying a -1 scale transform reverses the holes / non holes interpretation of the points,
        // we have to create a mirrored shape by parsing points
        GeneralPath mirrorPath = new GeneralPath();
        float[] point = new float[6];
        for (PathIterator it = area.getPathIterator(null); !it.isDone(); it.next()) {
            switch(it.currentSegment(point)) {
                case PathIterator.SEG_MOVETO:
                    mirrorPath.moveTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_LINETO:
                    mirrorPath.lineTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_QUADTO:
                    mirrorPath.quadTo(1 - point[0], point[1], 1 - point[2], point[3]);
                    break;
                case PathIterator.SEG_CUBICTO:
                    mirrorPath.curveTo(1 - point[0], point[1], 1 - point[2], point[3], 1 - point[4], point[5]);
                    break;
                case PathIterator.SEG_CLOSE:
                    mirrorPath.closePath();
                    break;
            }
        }
        return new Area(mirrorPath);
    }

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape) {
        Shape shape = parsedShapes.get(svgPathShape);
        if (shape == null) {
            try {
                shape = SVGPathSupport.parsePathShape(svgPathShape);
            } catch (LinkageError ex) {
                // Fallback to default square shape if batik classes aren't in classpath
                shape = new Rectangle2D.Float(0, 0, 1, 1);
            }
            parsedShapes.put(svgPathShape, shape);
        }
        return shape;
    }

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_6Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#getNormalizedTransform(Node, float[][], float)} method.
*/
class ModelManager_6Test {","// ModelManager_6Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#getNormalizedTransform(Node, float[][], float)} method.
*/
class ModelManager_6Test {
"
830db831-1b02-4ddd-9139-201dfbff663b,/EvoSuiteBenchmark/original/103_sweethome3d/src/main/java/com/eteks/sweethome3d/j3d/ModelManager_8Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// ModelManager.java
/*
 * ModelManager.java 4 juil. 07
 *
 * Sweet Home 3D, Copyright (c) 2007 Emmanuel PUYBARET / eTeks <info@eteks.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;

/**
 * Singleton managing 3D models cache.
 * This manager supports 3D models with an OBJ, DAE, 3DS or LWS format by default.
 * Additional classes implementing Java 3D <code>Loader</code> interface may be
 * specified in the <code>com.eteks.sweethome3d.j3d.additionalLoaderClasses</code>
 * (separated by a space or a colon :) to enable the support of other formats.<br>
 * Note: this class is compatible with Java 3D 1.3.
 * @author Emmanuel Puybaret
 */
public class ModelManager {

    /**
     * <code>Shape3D</code> user data prefix for window pane shapes.
     */
    public static final String WINDOW_PANE_SHAPE_PREFIX = ""sweethome3d_window_pane"";

    /**
     * <code>Shape3D</code> user data prefix for mirror shapes.
     */
    public static final String MIRROR_SHAPE_PREFIX = ""sweethome3d_window_mirror"";

    /**
     * <code>Shape3D</code> user data prefix for lights.
     */
    public static final String LIGHT_SHAPE_PREFIX = ""sweethome3d_light"";

    private static final TransparencyAttributes WINDOW_PANE_TRANSPARENCY_ATTRIBUTES = new TransparencyAttributes(TransparencyAttributes.NICEST, 0.5f);

    private static final Material DEFAULT_MATERIAL = new Material();

    private static final float MINIMUM_SIZE = 0.001f;

    private static final String ADDITIONAL_LOADER_CLASSES = ""com.eteks.sweethome3d.j3d.additionalLoaderClasses"";

    private static ModelManager instance;

    // Map storing loaded model nodes
    private Map<Content, BranchGroup> loadedModelNodes;

    // Map storing model nodes being loaded
    private Map<Content, List<ModelObserver>> loadingModelObservers;

    // Executor used to load models
    private ExecutorService modelsLoader;

    // List of additional loader classes
    private Class<Loader>[] additionalLoaderClasses;

    // SVG path Shapes
    private final Map<String, Shape> parsedShapes;

    private ModelManager() {
        // This class is a singleton
        this.loadedModelNodes = new WeakHashMap<Content, BranchGroup>();
        this.loadingModelObservers = new HashMap<Content, List<ModelObserver>>();
        this.parsedShapes = new WeakHashMap<String, Shape>();
        // Load other optional Loader classes
        List<Class<Loader>> loaderClasses = new ArrayList<Class<Loader>>();
        String loaderClassNames = System.getProperty(ADDITIONAL_LOADER_CLASSES);
        if (loaderClassNames != null) {
            for (String loaderClassName : loaderClassNames.split(""\\s|:"")) {
                try {
                    loaderClasses.add(getLoaderClass(loaderClassName));
                } catch (IllegalArgumentException ex) {
                    System.err.println(""Invalid loader class "" + loaderClassName + "":\n"" + ex.getMessage());
                }
            }
        }
        this.additionalLoaderClasses = loaderClasses.toArray(new Class[loaderClasses.size()]);
    }

    /**
     * Returns the class of name <code>loaderClassName</code>.
     */
    @SuppressWarnings(""unchecked"")
    private Class<Loader> getLoaderClass(String loaderClassName) {
        try {
            Class<Loader> loaderClass = (Class<Loader>) getClass().getClassLoader().loadClass(loaderClassName);
            if (!Loader.class.isAssignableFrom(loaderClass)) {
                throw new IllegalArgumentException(loaderClassName + "" not a subclass of "" + Loader.class.getName());
            } else if (Modifier.isAbstract(loaderClass.getModifiers()) || !Modifier.isPublic(loaderClass.getModifiers())) {
                throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
            }
            Constructor<Loader> constructor = loaderClass.getConstructor(new Class[0]);
            // Try to instantiate it now to see if it won't cause any problem
            constructor.newInstance(new Object[0]);
            return loaderClass;
        } catch (ClassNotFoundException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (NoSuchMethodException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (InvocationTargetException ex) {
            throw new IllegalArgumentException(ex.getMessage(), ex);
        } catch (IllegalAccessException ex) {
            throw new IllegalArgumentException(loaderClassName + "" constructor not accessible"");
        } catch (InstantiationException ex) {
            throw new IllegalArgumentException(loaderClassName + "" not a public static class"");
        }
    }

    /**
     * Returns an instance of this singleton.
     */
    public static ModelManager getInstance() {
        if (instance == null) {
            instance = new ModelManager();
        }
        return instance;
    }

    /**
     * Shutdowns the multithreaded service that load textures.
     */
    public void clear() {
        if (this.modelsLoader != null) {
            this.modelsLoader.shutdownNow();
            this.modelsLoader = null;
        }
        synchronized (this.loadedModelNodes) {
            this.loadedModelNodes.clear();
        }
    }

    /**
     * Returns the minimum size of a model.
     */
    float getMinimumSize() {
        return MINIMUM_SIZE;
    }

    /**
     * Returns the size of 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node) {
        return getSize(node, new Transform3D());
    }

    /**
     * Returns the size of 3D shapes of <code>node</code> after an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public Vector3f getSize(Node node, Transform3D transformation) {
        BoundingBox bounds = getBounds(node, transformation);
        Point3d lower = new Point3d();
        bounds.getLower(lower);
        Point3d upper = new Point3d();
        bounds.getUpper(upper);
        return new Vector3f(Math.max(getMinimumSize(), (float) (upper.x - lower.x)), Math.max(getMinimumSize(), (float) (upper.y - lower.y)), Math.max(getMinimumSize(), (float) (upper.z - lower.z)));
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code>.
     * This method computes the exact box that contains all the shapes,
     * contrary to <code>node.getBounds()</code> that returns a bounding
     * sphere for a scene.
     */
    public BoundingBox getBounds(Node node) {
        return getBounds(node, new Transform3D());
    }

    /**
     * Returns the bounds of the 3D shapes of <code>node</code> with an additional <code>transformation</code>.
     * This method computes the exact box that contains all the shapes, contrary to <code>node.getBounds()</code>
     * that returns a bounding sphere for a scene.
     */
    public BoundingBox getBounds(Node node, Transform3D transformation) {
        BoundingBox objectBounds = new BoundingBox(new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));
        computeBounds(node, objectBounds, transformation, !isOrthogonalRotation(transformation));
        Point3d lower = new Point3d();
        objectBounds.getLower(lower);
        if (lower.x == Double.POSITIVE_INFINITY) {
            throw new IllegalArgumentException(""Node has no bounds"");
        }
        return objectBounds;
    }

    /**
     * Returns <code>true</code> if the rotation matrix matches only rotations of
     * a multiple of 90 degrees around x, y or z axis.
     */
    private boolean isOrthogonalRotation(Transform3D transformation) {
        Matrix3f matrix = new Matrix3f();
        transformation.get(matrix);
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                // Return false if the matrix contains a value different from 0 1 or -1
                if (Math.abs(matrix.getElement(i, j)) > 1E-6 && Math.abs(matrix.getElement(i, j) - 1) > 1E-6 && Math.abs(matrix.getElement(i, j) + 1) > 1E-6) {
                    return false;
                }
            }
        }
        return true;
    }

    private void computeBounds(Node node, BoundingBox bounds, Transform3D parentTransformations, boolean transformShapeGeometry) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute the bounds of all the node children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeBounds((Node) enumeration.nextElement(), bounds, parentTransformations, transformShapeGeometry);
            }
        } else if (node instanceof Link) {
            computeBounds(((Link) node).getSharedGroup(), bounds, parentTransformations, transformShapeGeometry);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Bounds shapeBounds;
            if (transformShapeGeometry) {
                shapeBounds = computeTransformedGeometryBounds(shape, parentTransformations);
            } else {
                shapeBounds = shape.getBounds();
                shapeBounds.transform(parentTransformations);
            }
            bounds.combine(shapeBounds);
        }
    }

    private Bounds computeTransformedGeometryBounds(Shape3D shape, Transform3D transformation) {
        Point3d lower = new Point3d(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
        Point3d upper = new Point3d(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);
        for (int i = 0, n = shape.numGeometries(); i < n; i++) {
            Geometry geometry = shape.getGeometry(i);
            if (geometry instanceof GeometryArray) {
                GeometryArray geometryArray = (GeometryArray) geometry;
                int vertexCount = geometryArray.getVertexCount();
                Point3f vertex = new Point3f();
                if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                    if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                        float[] vertexData = geometryArray.getInterleavedVertices();
                        int vertexSize = vertexData.length / vertexCount;
                        for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                            vertex.x = vertexData[j];
                            vertex.y = vertexData[j + 1];
                            vertex.z = vertexData[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    } else {
                        float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                        for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                            vertex.x = vertexCoordinates[j];
                            vertex.y = vertexCoordinates[j + 1];
                            vertex.z = vertexCoordinates[j + 2];
                            updateBounds(vertex, transformation, lower, upper);
                        }
                    }
                } else {
                    for (int index = 0; index < vertexCount; index++) {
                        geometryArray.getCoordinate(index, vertex);
                        updateBounds(vertex, transformation, lower, upper);
                    }
                }
            } else {
                Bounds shapeBounds = shape.getBounds();
                shapeBounds.transform(transformation);
                return shapeBounds;
            }
        }
        Bounds shapeBounds = new BoundingBox(lower, upper);
        return shapeBounds;
    }

    private void updateBounds(Point3f vertex, Transform3D transformation, Point3d lower, Point3d upper) {
        transformation.transform(vertex);
        if (lower.x > vertex.x) {
            lower.x = vertex.x;
        }
        if (lower.y > vertex.y) {
            lower.y = vertex.y;
        }
        if (lower.z > vertex.z) {
            lower.z = vertex.z;
        }
        if (upper.x < vertex.x) {
            upper.x = vertex.x;
        }
        if (upper.y < vertex.y) {
            upper.y = vertex.y;
        }
        if (upper.z < vertex.z) {
            upper.z = vertex.z;
        }
    }

    /**
     * Returns a transform group that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public TransformGroup getNormalizedTransformGroup(Node node, float[][] modelRotation, float width) {
        return new TransformGroup(getNormalizedTransform(node, modelRotation, width));
    }

    /**
     * Returns a transform that will transform the model <code>node</code>
     * to let it fill a box of the given <code>width</code> centered on the origin.
     * @param node     the root of a model with any size and location
     * @param modelRotation the rotation applied to the model before normalization
     *                 or <code>null</code> if no transformation should be applied to node.
     * @param width    the width of the box
     */
    public Transform3D getNormalizedTransform(Node node, float[][] modelRotation, float width) {
        // Get model bounding box size
        BoundingBox modelBounds = getBounds(node);
        Point3d lower = new Point3d();
        modelBounds.getLower(lower);
        Point3d upper = new Point3d();
        modelBounds.getUpper(upper);
        // Translate model to its center
        Transform3D translation = new Transform3D();
        translation.setTranslation(new Vector3d(-lower.x - (upper.x - lower.x) / 2, -lower.y - (upper.y - lower.y) / 2, -lower.z - (upper.z - lower.z) / 2));
        Transform3D modelTransform;
        if (modelRotation != null) {
            // Get model bounding box size with model rotation
            Matrix3f modelRotationMatrix = new Matrix3f(modelRotation[0][0], modelRotation[0][1], modelRotation[0][2], modelRotation[1][0], modelRotation[1][1], modelRotation[1][2], modelRotation[2][0], modelRotation[2][1], modelRotation[2][2]);
            modelTransform = new Transform3D();
            modelTransform.setRotation(modelRotationMatrix);
            modelTransform.mul(translation);
            BoundingBox rotatedModelBounds = getBounds(node, modelTransform);
            rotatedModelBounds.getLower(lower);
            rotatedModelBounds.getUpper(upper);
        } else {
            modelTransform = translation;
        }
        // Scale model to make it fill a 1 unit wide box
        Transform3D scaleOneTransform = new Transform3D();
        scaleOneTransform.setScale(new Vector3d(width / Math.max(getMinimumSize(), upper.x - lower.x), width / Math.max(getMinimumSize(), upper.y - lower.y), width / Math.max(getMinimumSize(), upper.z - lower.z)));
        scaleOneTransform.mul(modelTransform);
        return scaleOneTransform;
    }

    /**
     * Reads asynchronously a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens
     * @throws IllegalStateException if the current thread isn't the Event Dispatch Thread.
     */
    public void loadModel(Content content, ModelObserver modelObserver) {
        loadModel(content, false, modelObserver);
    }

    /**
     * Reads a 3D node from <code>content</code> with supported loaders
     * and notifies the loaded model to the given <code>modelObserver</code> once available.
     * @param content an object containing a model
     * @param synchronous if <code>true</code>, this method will return only once model content is loaded
     * @param modelObserver the observer that will be notified once the model is available
     *    or if an error happens. When the model is loaded synchronously, the observer will be notified
     *    in the same thread as the caller, otherwise the observer will be notified in the Event
     *    Dispatch Thread and this method must be called in Event Dispatch Thread too.
     * @throws IllegalStateException if synchronous is <code>false</code> and the current thread isn't
     *    the Event Dispatch Thread.
     */
    public void loadModel(final Content content, boolean synchronous, ModelObserver modelObserver) {
        BranchGroup modelRoot;
        synchronized (this.loadedModelNodes) {
            modelRoot = this.loadedModelNodes.get(content);
        }
        if (modelRoot != null) {
            // Notify cached model to observer with a clone of the model
            modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
        } else if (synchronous) {
            try {
                modelRoot = loadModel(content);
                synchronized (this.loadedModelNodes) {
                    // Store in cache model node for future copies
                    this.loadedModelNodes.put(content, (BranchGroup) modelRoot);
                }
                modelObserver.modelUpdated((BranchGroup) cloneNode(modelRoot));
            } catch (IOException ex) {
                modelObserver.modelError(ex);
            }
        } else if (!EventQueue.isDispatchThread()) {
            throw new IllegalStateException(""Asynchronous call out of Event Dispatch Thread"");
        } else {
            if (this.modelsLoader == null) {
                this.modelsLoader = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            }
            List<ModelObserver> observers = this.loadingModelObservers.get(content);
            if (observers != null) {
                // If observers list exists, content model is already being loaded
                // register observer for future notification
                observers.add(modelObserver);
            } else {
                // Create a list of observers that will be notified once content model is loaded
                observers = new ArrayList<ModelObserver>();
                observers.add(modelObserver);
                this.loadingModelObservers.put(content, observers);
                // Load the model in an other thread
                this.modelsLoader.execute(new Runnable() {

                    public void run() {
                        try {
                            final BranchGroup loadedModel = loadModel(content);
                            synchronized (loadedModelNodes) {
                                // Update loaded models cache and notify registered observers
                                loadedModelNodes.put(content, loadedModel);
                            }
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelUpdated((BranchGroup) cloneNode(loadedModel));
                                    }
                                }
                            });
                        } catch (final IOException ex) {
                            EventQueue.invokeLater(new Runnable() {

                                public void run() {
                                    for (final ModelObserver observer : loadingModelObservers.remove(content)) {
                                        observer.modelError(ex);
                                    }
                                }
                            });
                        }
                    }
                });
            }
        }
    }

    /**
     * Returns a clone of the given <code>node</code>.
     * All the children and the attributes of the given node are duplicated except the geometries
     * and the texture images of shapes.
     */
    public Node cloneNode(Node node) {
        // Clone node in a synchronized block because cloneNodeComponent is not thread safe
        synchronized (this.loadedModelNodes) {
            return cloneNode(node, new HashMap<SharedGroup, SharedGroup>());
        }
    }

    private Node cloneNode(Node node, Map<SharedGroup, SharedGroup> clonedSharedGroups) {
        if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Shape3D clonedShape = (Shape3D) shape.cloneNode(false);
            Appearance appearance = shape.getAppearance();
            if (appearance != null) {
                // Force only duplication of node's appearance except its texture
                Appearance clonedAppearance = (Appearance) appearance.cloneNodeComponent(true);
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    clonedAppearance.setTexture(texture);
                }
                clonedShape.setAppearance(clonedAppearance);
            }
            return clonedShape;
        } else if (node instanceof Link) {
            Link clonedLink = (Link) node.cloneNode(true);
            // Force duplication of shared groups too
            SharedGroup sharedGroup = clonedLink.getSharedGroup();
            if (sharedGroup != null) {
                SharedGroup clonedSharedGroup = clonedSharedGroups.get(sharedGroup);
                if (clonedSharedGroup == null) {
                    clonedSharedGroup = (SharedGroup) cloneNode(sharedGroup, clonedSharedGroups);
                    clonedSharedGroups.put(sharedGroup, clonedSharedGroup);
                }
                clonedLink.setSharedGroup(clonedSharedGroup);
            }
            return clonedLink;
        } else {
            Node clonedNode = node.cloneNode(true);
            if (node instanceof Group) {
                Group group = (Group) node;
                Group clonedGroup = (Group) clonedNode;
                for (int i = 0, n = group.numChildren(); i < n; i++) {
                    Node clonedChild = cloneNode(group.getChild(i), clonedSharedGroups);
                    clonedGroup.addChild(clonedChild);
                }
            }
            return clonedNode;
        }
    }

    /**
     * Returns the node loaded synchronously from <code>content</code> with supported loaders.
     * This method is threadsafe and may be called from any thread.
     * @param content an object containing a model
     */
    public BranchGroup loadModel(Content content) throws IOException {
        // Ensure we use a URLContent object
        URLContent urlContent;
        if (content instanceof URLContent) {
            urlContent = (URLContent) content;
        } else {
            urlContent = TemporaryURLContent.copyToTemporaryURLContent(content);
        }
        Loader3DS loader3DSWithNoStackTraces = new Loader3DS() {

            @Override
            public Scene load(URL url) throws FileNotFoundException, IncorrectFormatException {
                try {
                    // Check magic number 0x4D4D
                    InputStream in = url.openStream();
                    int b1 = in.read();
                    int b2 = in.read();
                    if (b1 != 0x4D || b2 != 0x4D) {
                        throw new IncorrectFormatException(""Bad magic number"");
                    }
                    in.close();
                } catch (FileNotFoundException ex) {
                    throw ex;
                } catch (IOException ex) {
                    throw new ParsingErrorException(""Can't read url "" + url);
                }
                PrintStream defaultSystemErrorStream = System.err;
                try {
                    // Ignore stack traces on System.err during 3DS file loading
                    System.setErr(new PrintStream(new OutputStream() {

                        @Override
                        public void write(int b) throws IOException {
                            // Do nothing
                        }
                    }));
                    // Default load
                    return super.load(url);
                } finally {
                    // Reset default err print stream
                    System.setErr(defaultSystemErrorStream);
                }
            }
        };
        Loader[] defaultLoaders = new Loader[] { new OBJLoader(), new DAELoader(), loader3DSWithNoStackTraces, new Lw3dLoader() };
        Loader[] loaders = new Loader[defaultLoaders.length + this.additionalLoaderClasses.length];
        System.arraycopy(defaultLoaders, 0, loaders, 0, defaultLoaders.length);
        for (int i = 0; i < this.additionalLoaderClasses.length; i++) {
            try {
                loaders[defaultLoaders.length + i] = this.additionalLoaderClasses[i].newInstance();
            } catch (InstantiationException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            } catch (IllegalAccessException ex) {
                // Can't happen: getLoaderClass checked this class is instantiable
                throw new InternalError(ex.getMessage());
            }
        }
        Exception lastException = null;
        for (Loader loader : loaders) {
            try {
                // Ask loader to ignore lights, fogs...
                loader.setFlags(loader.getFlags() & ~(Loader.LOAD_LIGHT_NODES | Loader.LOAD_FOG_NODES | Loader.LOAD_BACKGROUND_NODES | Loader.LOAD_VIEW_GROUPS));
                // Return the first scene that can be loaded from model URL content
                Scene scene = loader.load(urlContent.getURL());
                BranchGroup modelNode = scene.getSceneGroup();
                // If model doesn't have any child, consider the file as wrong
                if (modelNode.numChildren() == 0) {
                    throw new IllegalArgumentException(""Empty model"");
                }
                // Update transparency of scene window panes shapes
                updateShapeNamesAndWindowPanesTransparency(scene);
                // Turn off lights because some loaders don't take into account the ~LOAD_LIGHT_NODES flag
                turnOffLightsShareAndModulateTextures(modelNode);
                return modelNode;
            } catch (IllegalArgumentException ex) {
                lastException = ex;
            } catch (IncorrectFormatException ex) {
                lastException = ex;
            } catch (ParsingErrorException ex) {
                lastException = ex;
            } catch (IOException ex) {
                lastException = ex;
            } catch (RuntimeException ex) {
                // Take into account exceptions of Java 3D 1.5 ImageException class
                // in such a way program can run in Java 3D 1.3.1
                if (ex.getClass().getName().equals(""com.sun.j3d.utils.image.ImageException"")) {
                    lastException = ex;
                } else {
                    throw ex;
                }
            }
        }
        if (lastException instanceof IOException) {
            throw (IOException) lastException;
        } else if (lastException instanceof IncorrectFormatException) {
            IOException incorrectFormatException = new IOException(""Incorrect format"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else if (lastException instanceof ParsingErrorException) {
            IOException incorrectFormatException = new IOException(""Parsing error"");
            incorrectFormatException.initCause(lastException);
            throw incorrectFormatException;
        } else {
            IOException otherException = new IOException();
            otherException.initCause(lastException);
            throw otherException;
        }
    }

    /**
     * Updates the name of scene shapes and transparency window panes shapes.
     */
    @SuppressWarnings(""unchecked"")
    private void updateShapeNamesAndWindowPanesTransparency(Scene scene) {
        Map<String, Object> namedObjects = scene.getNamedObjects();
        for (Map.Entry<String, Object> entry : namedObjects.entrySet()) {
            if (entry.getValue() instanceof Shape3D) {
                String shapeName = entry.getKey();
                // Assign shape name to its user data
                Shape3D shape = (Shape3D) entry.getValue();
                shape.setUserData(shapeName);
                if (shapeName.startsWith(WINDOW_PANE_SHAPE_PREFIX)) {
                    Appearance appearance = shape.getAppearance();
                    if (appearance == null) {
                        appearance = new Appearance();
                        shape.setAppearance(appearance);
                    }
                    if (appearance.getTransparencyAttributes() == null) {
                        appearance.setTransparencyAttributes(WINDOW_PANE_TRANSPARENCY_ATTRIBUTES);
                    }
                }
            }
        }
    }

    /**
     * Turns off light nodes of <code>node</code> children,
     * and modulates textures if needed.
     */
    private void turnOffLightsShareAndModulateTextures(Node node) {
        if (node instanceof Group) {
            // Enumerate children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                turnOffLightsShareAndModulateTextures((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            turnOffLightsShareAndModulateTextures(((Link) node).getSharedGroup());
        } else if (node instanceof Light) {
            ((Light) node).setEnable(false);
        } else if (node instanceof Shape3D) {
            Appearance appearance = ((Shape3D) node).getAppearance();
            if (appearance != null) {
                Texture texture = appearance.getTexture();
                if (texture != null) {
                    // Share textures data as much as possible
                    Texture sharedTexture = TextureManager.getInstance().shareTexture(texture);
                    if (sharedTexture != texture) {
                        appearance.setTexture(sharedTexture);
                    }
                    TextureAttributes textureAttributes = appearance.getTextureAttributes();
                    if (textureAttributes == null) {
                        // Mix texture and shape color
                        textureAttributes = new TextureAttributes();
                        textureAttributes.setTextureMode(TextureAttributes.MODULATE);
                        appearance.setTextureAttributes(textureAttributes);
                        // Check shape color is white
                        Material material = appearance.getMaterial();
                        if (material == null) {
                            appearance.setMaterial((Material) DEFAULT_MATERIAL.cloneNodeComponent(true));
                        } else {
                            Color3f color = new Color3f();
                            DEFAULT_MATERIAL.getDiffuseColor(color);
                            material.setDiffuseColor(color);
                            DEFAULT_MATERIAL.getAmbientColor(color);
                            material.setAmbientColor(color);
                        }
                    }
                    // If texture image supports transparency
                    if (TextureManager.getInstance().isTextureTransparent(sharedTexture)) {
                        if (appearance.getTransparencyAttributes() == null) {
                            // Add transparency attributes to ensure transparency works
                            appearance.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.NICEST, 0));
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the 2D area of the 3D shapes children of the given <code>node</code>
     * projected on the floor (plan y = 0).
     */
    public Area getAreaOnFloor(Node node) {
        Area modelAreaOnFloor;
        int vertexCount = getVertexCount(node);
        if (vertexCount < 10000) {
            modelAreaOnFloor = new Area();
            computeAreaOnFloor(node, modelAreaOnFloor, new Transform3D());
        } else {
            List<float[]> vertices = new ArrayList<float[]>(vertexCount);
            computeVerticesOnFloor(node, vertices, new Transform3D());
            float[][] surroundingPolygon = getSurroundingPolygon(vertices.toArray(new float[vertices.size()][]));
            GeneralPath generalPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, surroundingPolygon.length);
            generalPath.moveTo(surroundingPolygon[0][0], surroundingPolygon[0][1]);
            for (int i = 0; i < surroundingPolygon.length; i++) {
                generalPath.lineTo(surroundingPolygon[i][0], surroundingPolygon[i][1]);
            }
            generalPath.closePath();
            modelAreaOnFloor = new Area(generalPath);
        }
        return modelAreaOnFloor;
    }

    /**
     * Returns the total count of vertices in all geometries.
     */
    private int getVertexCount(Node node) {
        int count = 0;
        if (node instanceof Group) {
            // Enumerate all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                count += getVertexCount((Node) enumeration.nextElement());
            }
        } else if (node instanceof Link) {
            count = getVertexCount(((Link) node).getSharedGroup());
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            if (renderingAttributes == null || renderingAttributes.getVisible()) {
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        count += ((GeometryArray) geometry).getVertexCount();
                    }
                }
            }
        }
        return count;
    }

    /**
     * Computes the vertices coordinates projected on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeVerticesOnFloor(Node node, List<float[]> vertices, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeVerticesOnFloor((Node) enumeration.nextElement(), vertices, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeVerticesOnFloor(((Link) node).getSharedGroup(), vertices, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    Geometry geometry = shape.getGeometry(i);
                    if (geometry instanceof GeometryArray) {
                        GeometryArray geometryArray = (GeometryArray) geometry;
                        int vertexCount = geometryArray.getVertexCount();
                        Point3f vertex = new Point3f();
                        if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                            if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                                float[] vertexData = geometryArray.getInterleavedVertices();
                                int vertexSize = vertexData.length / vertexCount;
                                // Store vertices coordinates
                                for (int index = 0, j = vertexSize - 3; index < vertexCount; j += vertexSize, index++) {
                                    vertex.x = vertexData[j];
                                    vertex.y = vertexData[j + 1];
                                    vertex.z = vertexData[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            } else {
                                // Store vertices coordinates
                                float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                                for (int index = 0, j = 0; index < vertexCount; j += 3, index++) {
                                    vertex.x = vertexCoordinates[j];
                                    vertex.y = vertexCoordinates[j + 1];
                                    vertex.z = vertexCoordinates[j + 2];
                                    parentTransformations.transform(vertex);
                                    vertices.add(new float[] { vertex.x, vertex.z });
                                }
                            }
                        } else {
                            // Store vertices coordinates
                            for (int index = 0, j = 0; index < vertexCount; j++, index++) {
                                geometryArray.getCoordinate(j, vertex);
                                parentTransformations.transform(vertex);
                                vertices.add(new float[] { vertex.x, vertex.z });
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Computes the 2D area on floor of the 3D shapes children of <code>node</code>.
     */
    private void computeAreaOnFloor(Node node, Area nodeArea, Transform3D parentTransformations) {
        if (node instanceof Group) {
            if (node instanceof TransformGroup) {
                parentTransformations = new Transform3D(parentTransformations);
                Transform3D transform = new Transform3D();
                ((TransformGroup) node).getTransform(transform);
                parentTransformations.mul(transform);
            }
            // Compute all children
            Enumeration<?> enumeration = ((Group) node).getAllChildren();
            while (enumeration.hasMoreElements()) {
                computeAreaOnFloor((Node) enumeration.nextElement(), nodeArea, parentTransformations);
            }
        } else if (node instanceof Link) {
            computeAreaOnFloor(((Link) node).getSharedGroup(), nodeArea, parentTransformations);
        } else if (node instanceof Shape3D) {
            Shape3D shape = (Shape3D) node;
            Appearance appearance = shape.getAppearance();
            RenderingAttributes renderingAttributes = appearance != null ? appearance.getRenderingAttributes() : null;
            TransparencyAttributes transparencyAttributes = appearance != null ? appearance.getTransparencyAttributes() : null;
            if ((renderingAttributes == null || renderingAttributes.getVisible()) && (transparencyAttributes == null || transparencyAttributes.getTransparency() < 1)) {
                // Compute shape geometries area
                for (int i = 0, n = shape.numGeometries(); i < n; i++) {
                    computeGeometryAreaOnFloor(shape.getGeometry(i), parentTransformations, nodeArea);
                }
            }
        }
    }

    /**
     * Computes the area on floor of a 3D geometry.
     */
    private void computeGeometryAreaOnFloor(Geometry geometry, Transform3D parentTransformations, Area nodeArea) {
        if (geometry instanceof GeometryArray) {
            GeometryArray geometryArray = (GeometryArray) geometry;
            int vertexCount = geometryArray.getVertexCount();
            float[] vertices = new float[vertexCount * 2];
            Point3f vertex = new Point3f();
            if ((geometryArray.getVertexFormat() & GeometryArray.BY_REFERENCE) != 0) {
                if ((geometryArray.getVertexFormat() & GeometryArray.INTERLEAVED) != 0) {
                    float[] vertexData = geometryArray.getInterleavedVertices();
                    int vertexSize = vertexData.length / vertexCount;
                    // Store vertices coordinates
                    for (int index = 0, i = vertexSize - 3; index < vertices.length; i += vertexSize) {
                        vertex.x = vertexData[i];
                        vertex.y = vertexData[i + 1];
                        vertex.z = vertexData[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                } else {
                    // Store vertices coordinates
                    float[] vertexCoordinates = geometryArray.getCoordRefFloat();
                    for (int index = 0, i = 0; index < vertices.length; i += 3) {
                        vertex.x = vertexCoordinates[i];
                        vertex.y = vertexCoordinates[i + 1];
                        vertex.z = vertexCoordinates[i + 2];
                        parentTransformations.transform(vertex);
                        vertices[index++] = vertex.x;
                        vertices[index++] = vertex.z;
                    }
                }
            } else {
                // Store vertices coordinates
                for (int index = 0, i = 0; index < vertices.length; i++) {
                    geometryArray.getCoordinate(i, vertex);
                    parentTransformations.transform(vertex);
                    vertices[index++] = vertex.x;
                    vertices[index++] = vertex.z;
                }
            }
            // Create path from triangles or quadrilaterals of geometry
            GeneralPath geometryPath = null;
            if (geometryArray instanceof IndexedGeometryArray) {
                if (geometryArray instanceof IndexedTriangleArray) {
                    IndexedTriangleArray triangleArray = (IndexedTriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0, n = triangleArray.getIndexCount(); i < n; i += 3) {
                        addIndexedTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedQuadArray) {
                    IndexedQuadArray quadArray = (IndexedQuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0, n = quadArray.getIndexCount(); i < n; i += 4) {
                        addIndexedQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof IndexedGeometryStripArray) {
                    IndexedGeometryStripArray geometryStripArray = (IndexedGeometryStripArray) geometryArray;
                    int[] stripIndexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripIndexCounts(stripIndexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof IndexedTriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addIndexedTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof IndexedTriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripIndexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripIndexCounts[strip] - 2; i < n; i++) {
                                addIndexedTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripIndexCounts[strip];
                        }
                    }
                }
            } else {
                if (geometryArray instanceof TriangleArray) {
                    TriangleArray triangleArray = (TriangleArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, triangleIndex = 0; i < vertexCount; i += 3) {
                        addTriangleToPath(triangleArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof QuadArray) {
                    QuadArray quadArray = (QuadArray) geometryArray;
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    for (int i = 0, quadrilateralIndex = 0; i < vertexCount; i += 4) {
                        addQuadrilateralToPath(quadArray, i, i + 1, i + 2, i + 3, vertices, geometryPath, quadrilateralIndex++, nodeArea);
                    }
                } else if (geometryArray instanceof GeometryStripArray) {
                    GeometryStripArray geometryStripArray = (GeometryStripArray) geometryArray;
                    int[] stripVertexCounts = new int[geometryStripArray.getNumStrips()];
                    geometryStripArray.getStripVertexCounts(stripVertexCounts);
                    geometryPath = new GeneralPath(GeneralPath.WIND_NON_ZERO, 1000);
                    int initialIndex = 0;
                    if (geometryStripArray instanceof TriangleStripArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2, j = 0; i < n; i++, j++) {
                                if (j % 2 == 0) {
                                    addTriangleToPath(geometryStripArray, i, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                                } else {
                                    // Vertices of odd triangles are in reverse order
                                    addTriangleToPath(geometryStripArray, i, i + 2, i + 1, vertices, geometryPath, triangleIndex++, nodeArea);
                                }
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    } else if (geometryStripArray instanceof TriangleFanArray) {
                        for (int strip = 0, triangleIndex = 0; strip < stripVertexCounts.length; strip++) {
                            for (int i = initialIndex, n = initialIndex + stripVertexCounts[strip] - 2; i < n; i++) {
                                addTriangleToPath(geometryStripArray, initialIndex, i + 1, i + 2, vertices, geometryPath, triangleIndex++, nodeArea);
                            }
                            initialIndex += stripVertexCounts[strip];
                        }
                    }
                }
            }
            if (geometryPath != null) {
                nodeArea.add(new Area(geometryPath));
            }
        }
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices.
     */
    private void addIndexedTriangleToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        addTriangleToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), vertices, geometryPath, triangleIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices.
     */
    private void addIndexedQuadrilateralToPath(IndexedGeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        addQuadrilateralToPath(geometryArray, geometryArray.getCoordinateIndex(vertexIndex1), geometryArray.getCoordinateIndex(vertexIndex2), geometryArray.getCoordinateIndex(vertexIndex3), geometryArray.getCoordinateIndex(vertexIndex4), vertices, geometryPath, quadrilateralIndex, nodeArea);
    }

    /**
     * Adds to <code>nodePath</code> the triangle joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3 indices,
     * only if the triangle has a positive orientation.
     */
    private void addTriangleToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, float[] vertices, GeneralPath geometryPath, int triangleIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (triangleIndex > 0 && triangleIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.closePath();
        }
    }

    /**
     * Adds to <code>nodePath</code> the quadrilateral joining vertices at
     * vertexIndex1, vertexIndex2, vertexIndex3, vertexIndex4 indices,
     * only if the quadrilateral has a positive orientation.
     */
    private void addQuadrilateralToPath(GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, float[] vertices, GeneralPath geometryPath, int quadrilateralIndex, Area nodeArea) {
        float xVertex1 = vertices[2 * vertexIndex1];
        float yVertex1 = vertices[2 * vertexIndex1 + 1];
        float xVertex2 = vertices[2 * vertexIndex2];
        float yVertex2 = vertices[2 * vertexIndex2 + 1];
        float xVertex3 = vertices[2 * vertexIndex3];
        float yVertex3 = vertices[2 * vertexIndex3 + 1];
        if ((xVertex2 - xVertex1) * (yVertex3 - yVertex2) - (yVertex2 - yVertex1) * (xVertex3 - xVertex2) > 0) {
            if (quadrilateralIndex > 0 && quadrilateralIndex % 1000 == 0) {
                // Add now current path to area otherwise area gets too slow
                nodeArea.add(new Area(geometryPath));
                geometryPath.reset();
            }
            geometryPath.moveTo(xVertex1, yVertex1);
            geometryPath.lineTo(xVertex2, yVertex2);
            geometryPath.lineTo(xVertex3, yVertex3);
            geometryPath.lineTo(vertices[2 * vertexIndex4], vertices[2 * vertexIndex4 + 1]);
            geometryPath.closePath();
        }
    }

    /**
     * Returns the convex polygon that surrounds the given <code>vertices</code>.
     * From Andrew's monotone chain 2D convex hull algorithm described at
     * http://softsurfer.com/Archive/algorithm%5F0109/algorithm%5F0109.htm
     */
    private float[][] getSurroundingPolygon(float[][] vertices) {
        Arrays.sort(vertices, new Comparator<float[]>() {

            public int compare(float[] vertex1, float[] vertex2) {
                if (vertex1[0] == vertex2[0]) {
                    return (int) Math.signum(vertex2[1] - vertex1[1]);
                } else {
                    return (int) Math.signum(vertex2[0] - vertex1[0]);
                }
            }
        });
        float[][] polygon = new float[vertices.length][];
        // The output array polygon [] will be used as the stack
        // indices for bottom and top of the stack
        int bottom = 0, top = -1;
        // array scan index
        int i;
        // Get the indices of points with min x-coord and min|max y-coord
        int minMin = 0, minMax;
        float xmin = vertices[0][0];
        for (i = 1; i < vertices.length; i++) {
            if (vertices[i][0] != xmin) {
                break;
            }
        }
        minMax = i - 1;
        if (minMax == vertices.length - 1) {
            // Degenerate case: all x-coords == xmin
            polygon[++top] = vertices[minMin];
            if (vertices[minMax][1] != vertices[minMin][1]) {
                // A nontrivial segment
                polygon[++top] = vertices[minMax];
            }
            // Add polygon end point
            polygon[++top] = vertices[minMin];
            float[][] surroundingPolygon = new float[top + 1][];
            System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        }
        // Get the indices of points with max x-coord and min|max y-coord
        int maxMin, maxMax = vertices.length - 1;
        float xMax = vertices[vertices.length - 1][0];
        for (i = vertices.length - 2; i >= 0; i--) {
            if (vertices[i][0] != xMax) {
                break;
            }
        }
        maxMin = i + 1;
        // Compute the lower hull on the stack polygon
        // push minmin point onto stack
        polygon[++top] = vertices[minMin];
        i = minMax;
        while (++i <= maxMin) {
            // The lower line joins points [minmin] with points [maxmin]
            if (isLeft(vertices[minMin], vertices[maxMin], vertices[i]) >= 0 && i < maxMin) {
                // ignore points [i] above or on the lower line
                continue;
            }
            while (// There are at least 2 points on the stack
            top > 0) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0)
                    // points [i] is a new hull vertex
                    break;
                else
                    // pop top point off stack
                    top--;
            }
            // push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        // Next, compute the upper hull on the stack polygon above the bottom hull
        // If distinct xmax points
        if (maxMax != maxMin) {
            // Push maxmax point onto stack
            polygon[++top] = vertices[maxMax];
        }
        // The bottom point of the upper hull stack
        bottom = top;
        i = maxMin;
        while (--i >= minMax) {
            // The upper line joins points [maxmax] with points [minmax]
            if (isLeft(vertices[maxMax], vertices[minMax], vertices[i]) >= 0 && i > minMax) {
                // Ignore points [i] below or on the upper line
                continue;
            }
            // At least 2 points on the upper stack
            while (top > bottom) {
                // Test if points [i] is left of the line at the stack top
                if (isLeft(polygon[top - 1], polygon[top], vertices[i]) > 0) {
                    // points [i] is a new hull vertex
                    break;
                } else {
                    // Pop top point off stack
                    top--;
                }
            }
            // Push points [i] onto stack
            polygon[++top] = vertices[i];
        }
        if (minMax != minMin) {
            // Push joining endpoint onto stack
            polygon[++top] = vertices[minMin];
        }
        float[][] surroundingPolygon = new float[top + 1][];
        System.arraycopy(polygon, 0, surroundingPolygon, 0, surroundingPolygon.length);
        return surroundingPolygon;
    }

    private float isLeft(float[] vertex0, float[] vertex1, float[] vertex2) {
        return (vertex1[0] - vertex0[0]) * (vertex2[1] - vertex0[1]) - (vertex2[0] - vertex0[0]) * (vertex1[1] - vertex0[1]);
    }

    /**
     * Returns the area on the floor of the given staircase.
     */
    public Area getAreaOnFloor(HomePieceOfFurniture staircase) {
        if (staircase.getStaircaseCutOutShape() == null) {
            throw new IllegalArgumentException(""No cut out shape associated to piece"");
        }
        Shape shape = parseShape(staircase.getStaircaseCutOutShape());
        Area staircaseArea = new Area(shape);
        if (staircase.isModelMirrored()) {
            staircaseArea = getMirroredArea(staircaseArea);
        }
        AffineTransform staircaseTransform = AffineTransform.getTranslateInstance(staircase.getX() - staircase.getWidth() / 2, staircase.getY() - staircase.getDepth() / 2);
        staircaseTransform.concatenate(AffineTransform.getRotateInstance(staircase.getAngle(), staircase.getWidth() / 2, staircase.getDepth() / 2));
        staircaseTransform.concatenate(AffineTransform.getScaleInstance(staircase.getWidth(), staircase.getDepth()));
        staircaseArea.transform(staircaseTransform);
        return staircaseArea;
    }

    /**
     * Returns the mirror area of the given <code>area</code>.
     */
    private Area getMirroredArea(Area area) {
        // As applying a -1 scale transform reverses the holes / non holes interpretation of the points,
        // we have to create a mirrored shape by parsing points
        GeneralPath mirrorPath = new GeneralPath();
        float[] point = new float[6];
        for (PathIterator it = area.getPathIterator(null); !it.isDone(); it.next()) {
            switch(it.currentSegment(point)) {
                case PathIterator.SEG_MOVETO:
                    mirrorPath.moveTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_LINETO:
                    mirrorPath.lineTo(1 - point[0], point[1]);
                    break;
                case PathIterator.SEG_QUADTO:
                    mirrorPath.quadTo(1 - point[0], point[1], 1 - point[2], point[3]);
                    break;
                case PathIterator.SEG_CUBICTO:
                    mirrorPath.curveTo(1 - point[0], point[1], 1 - point[2], point[3], 1 - point[4], point[5]);
                    break;
                case PathIterator.SEG_CLOSE:
                    mirrorPath.closePath();
                    break;
            }
        }
        return new Area(mirrorPath);
    }

    /**
     * Returns the AWT shape matching the given <a href=""http://www.w3.org/TR/SVG/paths.html"">SVG path shape</a>.
     */
    private Shape parseShape(String svgPathShape) {
        Shape shape = parsedShapes.get(svgPathShape);
        if (shape == null) {
            try {
                shape = SVGPathSupport.parsePathShape(svgPathShape);
            } catch (LinkageError ex) {
                // Fallback to default square shape if batik classes aren't in classpath
                shape = new Rectangle2D.Float(0, 0, 1, 1);
            }
            parsedShapes.put(svgPathShape, shape);
        }
        return shape;
    }

    /**
     * Separated static class to be able to exclude Batik library from classpath.
     */
    private static class SVGPathSupport {

        public static Shape parsePathShape(String svgPathShape) {
            try {
                AWTPathProducer pathProducer = new AWTPathProducer();
                PathParser pathParser = new PathParser();
                pathParser.setPathHandler(pathProducer);
                pathParser.parse(svgPathShape);
                return pathProducer.getShape();
            } catch (ParseException ex) {
                // Fallback to default square shape if shape is incorrect
                return new Rectangle2D.Float(0, 0, 1, 1);
            }
        }
    }

    /**
     * An observer that receives model loading notifications.
     */
    public static interface ModelObserver {

        public void modelUpdated(BranchGroup modelRoot);

        public void modelError(Exception ex);
    }
}
","// ModelManager_8Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#loadModel(Content)} method.
*/
class ModelManager_8Test {","// ModelManager_8Test.java
package com.eteks.sweethome3d.j3d;

import java.awt.EventQueue;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.media.j3d.Appearance;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.Bounds;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Geometry;
import javax.media.j3d.GeometryArray;
import javax.media.j3d.GeometryStripArray;
import javax.media.j3d.Group;
import javax.media.j3d.IndexedGeometryArray;
import javax.media.j3d.IndexedGeometryStripArray;
import javax.media.j3d.IndexedQuadArray;
import javax.media.j3d.IndexedTriangleArray;
import javax.media.j3d.IndexedTriangleFanArray;
import javax.media.j3d.IndexedTriangleStripArray;
import javax.media.j3d.Light;
import javax.media.j3d.Link;
import javax.media.j3d.Material;
import javax.media.j3d.Node;
import javax.media.j3d.QuadArray;
import javax.media.j3d.RenderingAttributes;
import javax.media.j3d.Shape3D;
import javax.media.j3d.SharedGroup;
import javax.media.j3d.Texture;
import javax.media.j3d.TextureAttributes;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.TransparencyAttributes;
import javax.media.j3d.TriangleArray;
import javax.media.j3d.TriangleFanArray;
import javax.media.j3d.TriangleStripArray;
import javax.vecmath.Color3f;
import javax.vecmath.Matrix3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.apache.batik.parser.AWTPathProducer;
import org.apache.batik.parser.ParseException;
import org.apache.batik.parser.PathParser;
import com.eteks.sweethome3d.model.Content;
import com.eteks.sweethome3d.model.HomePieceOfFurniture;
import com.eteks.sweethome3d.tools.TemporaryURLContent;
import com.eteks.sweethome3d.tools.URLContent;
import com.microcrowd.loader.java3d.max3ds.Loader3DS;
import com.sun.j3d.loaders.IncorrectFormatException;
import com.sun.j3d.loaders.Loader;
import com.sun.j3d.loaders.ParsingErrorException;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.loaders.lw3d.Lw3dLoader;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModelManager}.
* It contains one unit test case for the {@link ModelManager#loadModel(Content)} method.
*/
class ModelManager_8Test {
"
