ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
9624c751-bb1e-461c-b717-2943608a9350,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// DefaultFSPath.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 *  The default implementation of the FSPath interface.
 *  This class uses the JDK's XPath implementation as the basis for
 *  FSPath queries.
 *  On instantiation, a DOM is created of the filesystem metadata starting form the <code>rootDirectory</code>.
 *  This DOM can then be queried using standard XML tools.
 *  <br/>
 *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.
 *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.
 *  <br/>
 *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc
 *
 * @author keith
 *  $Id$
 */
public class DefaultFSPath implements FSPath {

    /**
     *  Escape characters, we must escape any characters that are
     *  illegal in XML attribute text.
     *
     *  i.e. &amp; "" < >
     */
    private Map escapeChars;

    private DocumentBuilder documentBuilder;

    private XPath xpath;

    private Document dom;

    /**
     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd'T'HH:mm:ss.SSS
     */
    private DateFormat format;

    private File rootDirectory;

    public DefaultFSPath() {
        //used for unit test instantiation
        this.xpath = XPathFactory.newInstance().newXPath();
        //this.xpath.setNamespaceContext(new FSNamespaceContext());
        //this effectively enables the user of our custom XPath function
        //fs:match()
        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());
        this.escapeChars = this.createEscapeCharsMap();
        this.format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
    }

    /**
     * Creates a new instance of DefaultFSPath, based on the directory supplied
     */
    public DefaultFSPath(File currentDir) {
        this();
        this.rootDirectory = currentDir;
        //check if file is a directory
        if (!currentDir.isDirectory()) {
            throw new InstantiationError(""the java.io.File specified must be a Directory"");
        }
        try {
            this.createDocumentBuilder();
            //build DOM representation
            this.dom = this.buildDOM(currentDir);
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw new InstantiationError(""FSDom threw a ParserConfigurationException : "" + pce.getMessage());
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new InstantiationError(""FSDom threw an IOException : "" + ioe.getMessage());
        }
    }

    protected Map createEscapeCharsMap() {
        Map<String, String> escapeChars = new HashMap<String, String>();
        escapeChars.put(""&"", ""&#26;"");
        escapeChars.put(""<"", ""&#3c;"");
        escapeChars.put("">"", ""&#3e;"");
        escapeChars.put(""\"""", ""&#22;"");
        return escapeChars;
    }

    protected void createDocumentBuilder() throws ParserConfigurationException {
        try {
            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw pce;
        }
    }

    protected Document buildDOM(File currentDir) throws IOException {
        Document dom = this.documentBuilder.newDocument();
        dom.appendChild(this.createChildElement(dom, currentDir));
        return dom;
    }

    private Element createChildElement(Document dom, File currentFile) throws IOException {
        Element currentElement = null;
        if (currentFile.isDirectory()) {
            currentElement = dom.createElement(FSPathAttributes.dir.name());
            //recurse and create child elements for all its children
            File[] children = currentFile.listFiles();
            if (children != null) {
                for (int i = 0; i < children.length; i++) {
                    currentElement.appendChild(this.createChildElement(dom, children[i]));
                }
            }
        } else {
            currentElement = dom.createElement(FSPathAttributes.file.name());
        }
        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());
        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));
        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));
        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));
        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));
        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));
        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));
        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));
        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));
        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());
        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());
        return currentElement;
    }

    /**
     *  Calls this.query(expression, XPathConstants.NODESET)
     *
     *  Note : This method MUST be passed an expression which returns a nodeset.
     *
     *  @param expression the FSPath expression to execute.
     *  @returns <code>FSPathResultList</code> the FSPathResult objects contained
     *  in this list will be of type <code>java.io.File</code>,
     *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,
     *  <code>java.lang.String</code>
     */
    public FSPathResultList query(String expression) {
        return this.query(expression, XPathConstants.NODESET);
    }

    /**
     */
    public FSPathResultList query(String expression, QName returnType) {
        FSPathResultList results = new FSPathResultListImpl();
        try {
            if (XPathConstants.NODESET.equals(returnType)) {
                NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);
                if (nodelist.getLength() > 0) {
                    for (int i = 0; i < nodelist.getLength(); i++) {
                        processNode(nodelist.item(i), results);
                    }
                }
                return results;
            }
            if (XPathConstants.NODE.equals(returnType)) {
                Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);
                processNode(node, results);
                return results;
            }
            if (XPathConstants.BOOLEAN.equals(returnType)) {
                Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.NUMBER.equals(returnType)) {
                Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.STRING.equals(returnType)) {
                String result = (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);
                results.add(new FSPathResult(result));
                return results;
            }
        } catch (XPathExpressionException xpee) {
            System.out.println(""Invalid FSPath expression : "" + xpee.getCause().getMessage());
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
            System.out.println(""IllegalArgumentException"");
        } catch (ParseException pe) {
            pe.printStackTrace();
            System.out.println(""ParseException"");
        }
        return results;
    }

    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {
        //as the only elements in our dom are files or directories we will try to
        //create File objects of those nodes.
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();
            //System.out.println(""Filename : "" + fileName);
            results.add(new FSPathResult(new File(fileName)));
            return;
        }
        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
            Attr attr = (Attr) node;
            //now work out which attirutes were Dates, Longs and Strings
            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {
                results.add(new FSPathResult(attr.getValue()));
                return;
            }
            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {
                results.add(new FSPathResult(new Boolean(attr.getValue())));
                return;
            }
            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {
                results.add(new FSPathResult(this.format.parse(attr.getValue())));
                return;
            }
            if (FSPathAttributes.length.name().equals(attr.getName())) {
                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));
                return;
            }
        }
    }

    public File getRootDirectory() {
        return this.rootDirectory;
    }
}
","// DefaultFSPath_0Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains one unit test case for the {@link DefaultFSPath#query(String)} method.
*/
class DefaultFSPath_0Test {","// DefaultFSPath_0Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains one unit test case for the {@link DefaultFSPath#query(String)} method.
*/
class DefaultFSPath_0Test {
"
39cdd9fc-6405-4911-9ba2-d008fda7a7ce,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FSPathFactory.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;

/**
 * @author kbishop
 */
public class FSPathFactory {

    /**
     * Creates a new instance of FSPathFactory
     */
    public FSPathFactory() {
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(""user.dir"")) to search from.
     */
    public static FSPath newFSPath() {
        return new DefaultFSPath(new File(System.getProperty(""user.dir"")));
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.
     */
    public static FSPath newFSPath(File file) {
        return new DefaultFSPath(file);
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.
     */
    public static FSPath newFSPath(String path) {
        return new DefaultFSPath(new File(path));
    }
}
","// FSPathFactory_0Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains one unit test case for the {@link FSPathFactory#newFSPath()} method.
*/
class FSPathFactory_0Test {","// FSPathFactory_0Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains one unit test case for the {@link FSPathFactory#newFSPath()} method.
*/
class FSPathFactory_0Test {
"
7aebbcae-f8a4-41b0-8aa2-694ef812867d,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_0Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_0Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains one unit test case for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_0Test {","// FSPathResultListImpl_0Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains one unit test case for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_0Test {
"
797c83af-fbec-4baa-9a77-ce1e49cd1667,/EvoSuiteBenchmark/original/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_1Test.java,-1,"ERROR - CUDA error: device-side assert triggered
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.","// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains one unit test case for the {@link FSPathResultListImpl#delete()} method.
*/
class FSPathResultListImpl_1Test {","// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains one unit test case for the {@link FSPathResultListImpl#delete()} method.
*/
class FSPathResultListImpl_1Test {
"
