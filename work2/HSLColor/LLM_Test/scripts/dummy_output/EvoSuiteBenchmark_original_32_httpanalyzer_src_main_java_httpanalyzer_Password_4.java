// PasswordTest.java
package httpanalyzer;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Password}.
* It contains one unit test case for the {@link Password#crypt(String, String)} method.
*/
class PasswordTest {
		
//	Tests for the crypt method
	/**
	 * Returns a String containing the encrypted passwd
	 *
	 * @param strpw A String containing the un-encrypted password.
	 * @returns String containing encrypted password.
	 */
	private static String crypt(String strpw) {
		return crypt(strpw, "");
	}

	/**
	 * Tests the creation of crypt when strpw == the password to be hashed
	 */
	@Test
	public void crypt() {
		final String strpw = ""
		+ "abcdef123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ12345678ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		String strpwHashed = crypt(strpw);
		assertTrue(sc == 1);
		//System.out.println("Password: "+strpw+ " with hashed password: "+strpwHashed);
		assertTrue("A password cannot be an empty string.",!"".matches(strpw) == false);
		assertTrue("A password cannot be an empty string.",!""".matches(strpwHashed) == false);
		assertTrue("A password with salt cannot be an empty string.",!"".matches(strpw) == false);
	}

	/**
	 * Tests that the hashed password string does not contain the salt part
	 */
	@Test
	public void saltShouldNotContainTheSalt() {
		final String strpwHashed = crypt("abcde123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz");
		assertTrue("The string containing the salt can not be hashed.",!strpwHashed.matches("abcde123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"));
	}

	/**
	 * Tests that the hashed password password does not contain the salt part
	 */
	@Test
	public void passwordWithoutSaltDoesNotContainTheSalt() {
		final String strpw = crypt("abcde123456789abcdefghijklmnopqrstuvwxyz");
		assertTrue("The password string containing the salt part cannot be hashed.", strpw.matches("abcde123456789") == false);
	}

	/**
	 * Test method for {@link Password#crypt(String, String)}.
	 */
	@Test
	public void testCript() {
		String pw = crypt("abcde123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz");
		assertTrue(sc == 1);
		assertTrue("The password string with hashed password is the same as the original.", pw.matches("abcde123456789") == true);
	}

	/**
	 * Checks whether the output generated by the encryption has a leading 0.
	 *
	 * @throws NoSuchAlgorithmException The exception thrown if there is
	 * 						any problem with the
	 * 						{@link MessageDigest#getInstance(java.lang.String, java.lang.String) getInstance}.
	 */
	@Test
	public void testMessageDigestInit() throws NoSuchAlgorithmException {
		String pw = crypt("abcde123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789");
		assertTrue("The password string constructed in the MessageDigest can not match the original.", pw.matches("12345678ABCDEFGHIJKLMNOPQRSTUVWXYZ") == true);
	}

	/**
	 * Checks whether the output generated by the encryption has a leading 0.
	 */
	@Test
	public void testMessageDigestInit2() {
		String pw = crypt("12345678ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ12345678");
		assertTrue("The password string constructed in the MessageDigest can not match the original.", pw.matches("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ") == true);
	}

	/**
	 * Checks whether the hash is correct
	 */
	@Test
	public void testMessageDigest() throws NoSuchAlgorithmException {
		String pw = crypt("12345678ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ12345678ABCDEFGHIJKLMNOPQRSTUVWXYZ");
		assertTrue("The hash of the password string as generated by the MessageDigest can not match the original.", pw.matches("12345678abcdefghijklmnopqqrstuvwxyzabcdefghijklmnopqrstuvo") == true);
	}
}