[
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_0Test.java",
    "test_prompt": "// TimeStamp_0Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#ntpValue()} method.\n*/\nclass TimeStamp_0Test {",
    "method_signature": "ntpValue()",
    "suffix": "0"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_1Test.java",
    "test_prompt": "// TimeStamp_1Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getSeconds()} method.\n*/\nclass TimeStamp_1Test {",
    "method_signature": "getSeconds()",
    "suffix": "1"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_2Test.java",
    "test_prompt": "// TimeStamp_2Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getFraction()} method.\n*/\nclass TimeStamp_2Test {",
    "method_signature": "getFraction()",
    "suffix": "2"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_3Test.java",
    "test_prompt": "// TimeStamp_3Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getTime()} method.\n*/\nclass TimeStamp_3Test {",
    "method_signature": "getTime()",
    "suffix": "3"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_4Test.java",
    "test_prompt": "// TimeStamp_4Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getDate()} method.\n*/\nclass TimeStamp_4Test {",
    "method_signature": "getDate()",
    "suffix": "4"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_5Test.java",
    "test_prompt": "// TimeStamp_5Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getTime(long)} method.\n*/\nclass TimeStamp_5Test {",
    "method_signature": "getTime(long)",
    "suffix": "5"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_6Test.java",
    "test_prompt": "// TimeStamp_6Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getNtpTime(long)} method.\n*/\nclass TimeStamp_6Test {",
    "method_signature": "getNtpTime(long)",
    "suffix": "6"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_7Test.java",
    "test_prompt": "// TimeStamp_7Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#getCurrentTime()} method.\n*/\nclass TimeStamp_7Test {",
    "method_signature": "getCurrentTime()",
    "suffix": "7"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_8Test.java",
    "test_prompt": "// TimeStamp_8Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#parseNtpString(String)} method.\n*/\nclass TimeStamp_8Test {",
    "method_signature": "parseNtpString(String)",
    "suffix": "8"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_9Test.java",
    "test_prompt": "// TimeStamp_9Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#hashCode()} method.\n*/\nclass TimeStamp_9Test {",
    "method_signature": "hashCode()",
    "suffix": "9"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_10Test.java",
    "test_prompt": "// TimeStamp_10Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#equals(Object)} method.\n*/\nclass TimeStamp_10Test {",
    "method_signature": "equals(Object)",
    "suffix": "10"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_11Test.java",
    "test_prompt": "// TimeStamp_11Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#toString()} method.\n*/\nclass TimeStamp_11Test {",
    "method_signature": "toString()",
    "suffix": "11"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_12Test.java",
    "test_prompt": "// TimeStamp_12Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#toString(long)} method.\n*/\nclass TimeStamp_12Test {",
    "method_signature": "toString(long)",
    "suffix": "12"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_13Test.java",
    "test_prompt": "// TimeStamp_13Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#toDateString()} method.\n*/\nclass TimeStamp_13Test {",
    "method_signature": "toDateString()",
    "suffix": "13"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_14Test.java",
    "test_prompt": "// TimeStamp_14Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#toUTCString()} method.\n*/\nclass TimeStamp_14Test {",
    "method_signature": "toUTCString()",
    "suffix": "14"
  },
  {
    "numberTests": "ten",
    "original_code": "// TimeStamp.java\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\n/**\r\n * TimeStamp class represents the Network Time Protocol (NTP) timestamp\r\n * as defined in RFC-1305 and SNTP (RFC-2030). It is represented as a\r\n * 64-bit unsigned fixed-point number in seconds relative to 0-hour on 1-January-1900.\r\n * The 32-bit low-order bits are the fractional seconds whose precision is\r\n * about 200 picoseconds. Assumes overflow date when date passes MAX_LONG\r\n * and reverts back to 0 is 2036 and not 1900. Test for most significant\r\n * bit: if MSB\u003d0 then 2036 basis is used otherwise 1900 if MSB\u003d1.\r\n *\r\n * Methods exist to convert NTP timestamps to and from the equivalent Java date\r\n * representation, which is the number of milliseconds since the standard base\r\n * time known as \"the epoch\", namely January 1, 1970, 00:00:00 GMT.\r\n */\r\npublic class TimeStamp implements java.io.Serializable, Comparable\u003cTimeStamp\u003e {\r\n\r\n    private static final long serialVersionUID \u003d 8139806907588338737L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d0 is 7-Feb-2036 @ 06:28:16 UTC\r\n     */\r\n    protected static final long msb0baseTime \u003d 2085978496000L;\r\n\r\n    /**\r\n     * baseline NTP time if bit-0\u003d1 is 1-Jan-1900 @ 01:00:00 UTC\r\n     */\r\n    protected static final long msb1baseTime \u003d -2208988800000L;\r\n\r\n    /**\r\n     * Default NTP date string format. E.g. Fri, Sep 12 2003 21:06:23.860.\r\n     * See java.text.SimpleDateFormat for code descriptions.\r\n     */\r\n    public static final String NTP_DATE_FORMAT \u003d \"EEE, MMM dd yyyy HH:mm:ss.SSS\";\r\n\r\n    /**\r\n     * NTP timestamp value: 64-bit unsigned fixed-point number as defined in RFC-1305\r\n     * with high-order 32 bits the seconds field and the low-order 32-bits the\r\n     * fractional field.\r\n     */\r\n    private final long ntpTime;\r\n\r\n    private DateFormat simpleFormatter;\r\n\r\n    private DateFormat utcFormatter;\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the native 64-bit long argument.\r\n     * @param ntpTime the timestamp\r\n     */\r\n    public TimeStamp(long ntpTime) {\r\n        this.ntpTime \u003d ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the value represented by the string\r\n     * in hexdecimal form (e.g. \"c1a089bd.fc904f6d\").\r\n     * @param hexStamp the hex timestamp\r\n     *\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public TimeStamp(String hexStamp) throws NumberFormatException {\r\n        ntpTime \u003d decodeNtpHexString(hexStamp);\r\n    }\r\n\r\n    /**\r\n     * Constructs a newly allocated NTP timestamp object\r\n     * that represents the Java Date argument.\r\n     *\r\n     * @param d - the Date to be represented by the Timestamp object.\r\n     */\r\n    public TimeStamp(Date d) {\r\n        ntpTime \u003d (d \u003d\u003d null) ? 0 : toNtpTime(d.getTime());\r\n    }\r\n\r\n    /**\r\n     * Returns the value of this Timestamp as a long value.\r\n     *\r\n     * @return the 64-bit long value represented by this object.\r\n     */\r\n    public long ntpValue() {\r\n        return ntpTime;\r\n    }\r\n\r\n    /**\r\n     * Returns high-order 32-bits representing the seconds of this NTP timestamp.\r\n     *\r\n     * @return seconds represented by this NTP timestamp.\r\n     */\r\n    public long getSeconds() {\r\n        return (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Returns low-order 32-bits representing the fractional seconds.\r\n     *\r\n     * @return fractional seconds represented by this NTP timestamp.\r\n     */\r\n    public long getFraction() {\r\n        return ntpTime \u0026 0xffffffffL;\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java standard time.\r\n     *\r\n     * @return NTP Timestamp in Java time\r\n     */\r\n    public long getTime() {\r\n        return getTime(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp to Java Date object.\r\n     *\r\n     * @return NTP Timestamp in Java Date\r\n     */\r\n    public Date getDate() {\r\n        long time \u003d getTime(ntpTime);\r\n        return new Date(time);\r\n    }\r\n\r\n    /**\r\n     * Convert 64-bit NTP timestamp to Java standard time.\r\n     *\r\n     * Note that java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting NTP timestamp to java time and back\r\n     * to NTP timestamp loses precision. For example, Tue, Dec 17 2002 09:07:24.810 EST\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values ranging from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     *\r\n     * @param ntpTimeValue the input time\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 GMT\r\n     * represented by this NTP timestamp value.\r\n     */\r\n    public static long getTime(long ntpTimeValue) {\r\n        // high-order 32-bits\r\n        long seconds \u003d (ntpTimeValue \u003e\u003e\u003e 32) \u0026 0xffffffffL;\r\n        // low-order 32-bits\r\n        long fraction \u003d ntpTimeValue \u0026 0xffffffffL;\r\n        // Use round-off on fractional part to preserve going to lower precision\r\n        fraction \u003d Math.round(1000D * fraction / 0x100000000L);\r\n        /*\r\n         * If the most significant bit (MSB) on the seconds field is set we use\r\n         * a different time base. The following text is a quote from RFC-2030 (SNTP v4):\r\n         *\r\n         *  If bit 0 is set, the UTC time is in the range 1968-2036 and UTC time\r\n         *  is reckoned from 0h 0m 0s UTC on 1 January 1900. If bit 0 is not set,\r\n         *  the time is in the range 2036-2104 and UTC time is reckoned from\r\n         *  6h 28m 16s UTC on 7 February 2036.\r\n         */\r\n        long msb \u003d seconds \u0026 0x80000000L;\r\n        if (msb \u003d\u003d 0) {\r\n            // use base: 7-Feb-2036 @ 06:28:16 UTC\r\n            return msb0baseTime + (seconds * 1000) + fraction;\r\n        } else {\r\n            // use base: 1-Jan-1900 @ 01:00:00 UTC\r\n            return msb1baseTime + (seconds * 1000) + fraction;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to convert Java time to NTP timestamp object.\r\n     * Note that Java time (milliseconds) by definition has less precision\r\n     * then NTP time (picoseconds) so converting Ntptime to Javatime and back\r\n     * to Ntptime loses precision. For example, Tue, Dec 17 2002 09:07:24.810\r\n     * is represented by a single Java-based time value of f22cd1fc8a, but its\r\n     * NTP equivalent are all values from c1a9ae1c.cf5c28f5 to c1a9ae1c.cf9db22c.\r\n     * @param   date   the milliseconds since January 1, 1970, 00:00:00 GMT.\r\n     * @return NTP timestamp object at the specified date.\r\n     */\r\n    public static TimeStamp getNtpTime(long date) {\r\n        return new TimeStamp(toNtpTime(date));\r\n    }\r\n\r\n    /**\r\n     * Constructs a NTP timestamp object and initializes it so that\r\n     * it represents the time at which it was allocated, measured to the\r\n     * nearest millisecond.\r\n     * @return NTP timestamp object set to the current time.\r\n     * @see     java.lang.System#currentTimeMillis()\r\n     */\r\n    public static TimeStamp getCurrentTime() {\r\n        return getNtpTime(System.currentTimeMillis());\r\n    }\r\n\r\n    /**\r\n     * Convert NTP timestamp hexstring (e.g. \"c1a089bd.fc904f6d\") to the NTP\r\n     * 64-bit unsigned fixed-point number.\r\n     * @param hexString the string to convert\r\n     *\r\n     * @return NTP 64-bit timestamp value.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    protected static long decodeNtpHexString(String hexString) throws NumberFormatException {\r\n        if (hexString \u003d\u003d null) {\r\n            throw new NumberFormatException(\"null\");\r\n        }\r\n        int ind \u003d hexString.indexOf(\u0027.\u0027);\r\n        if (ind \u003d\u003d -1) {\r\n            if (hexString.length() \u003d\u003d 0) {\r\n                return 0;\r\n            }\r\n            // no decimal\r\n            return Long.parseLong(hexString, 16) \u003c\u003c 32;\r\n        }\r\n        return Long.parseLong(hexString.substring(0, ind), 16) \u003c\u003c 32 | Long.parseLong(hexString.substring(ind + 1), 16);\r\n    }\r\n\r\n    /**\r\n     * Parses the string argument as a NTP hexidecimal timestamp representation string\r\n     * (e.g. \"c1a089bd.fc904f6d\").\r\n     *\r\n     * @param s - hexstring.\r\n     * @return the Timestamp represented by the argument in hexidecimal.\r\n     * @throws NumberFormatException - if the string does not contain a parsable timestamp.\r\n     */\r\n    public static TimeStamp parseNtpString(String s) throws NumberFormatException {\r\n        return new TimeStamp(decodeNtpHexString(s));\r\n    }\r\n\r\n    /**\r\n     * Converts Java time to 64-bit NTP time representation.\r\n     *\r\n     * @param t Java time\r\n     * @return NTP timestamp representation of Java time value.\r\n     */\r\n    protected static long toNtpTime(long t) {\r\n        // time \u003c Feb-2036\r\n        boolean useBase1 \u003d t \u003c msb0baseTime;\r\n        long baseTime;\r\n        if (useBase1) {\r\n            // dates \u003c\u003d Feb-2036\r\n            baseTime \u003d t - msb1baseTime;\r\n        } else {\r\n            // if base0 needed for dates \u003e\u003d Feb-2036\r\n            baseTime \u003d t - msb0baseTime;\r\n        }\r\n        long seconds \u003d baseTime / 1000;\r\n        long fraction \u003d ((baseTime % 1000) * 0x100000000L) / 1000;\r\n        if (useBase1) {\r\n            // set high-order bit if msb1baseTime 1900 used\r\n            seconds |\u003d 0x80000000L;\r\n        }\r\n        long time \u003d seconds \u003c\u003c 32 | fraction;\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Computes a hashcode for this Timestamp. The result is the exclusive\r\n     * OR of the two halves of the primitive long value\r\n     * represented by this TimeStamp object. That is, the hashcode\r\n     * is the value of the expression:\r\n     *\r\n     * {@code (int)(this.ntpValue()^(this.ntpValue() \u003e\u003e\u003e 32))}\r\n     *\r\n     * @return a hash code value for this object.\r\n     */\r\n    @Override\r\n    public int hashCode() {\r\n        return (int) (ntpTime ^ (ntpTime \u003e\u003e\u003e 32));\r\n    }\r\n\r\n    /**\r\n     * Compares this object against the specified object.\r\n     * The result is true if and only if the argument is\r\n     * not null and is a Long object that\r\n     * contains the same long value as this object.\r\n     *\r\n     * @param   obj   the object to compare with.\r\n     * @return true if the objects are the same;\r\n     *          false otherwise.\r\n     */\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj instanceof TimeStamp) {\r\n            return ntpTime \u003d\u003d ((TimeStamp) obj).ntpValue();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String.\r\n     * The NTP timestamp 64-bit long value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return toString(ntpTime);\r\n    }\r\n\r\n    /**\r\n     * Left-pad 8-character hex string with 0\u0027s\r\n     *\r\n     * @param buf - StringBuilder which is appended with leading 0\u0027s.\r\n     * @param l - a long.\r\n     */\r\n    private static void appendHexString(StringBuilder buf, long l) {\r\n        String s \u003d Long.toHexString(l);\r\n        for (int i \u003d s.length(); i \u003c 8; i++) {\r\n            buf.append(\u00270\u0027);\r\n        }\r\n        buf.append(s);\r\n    }\r\n\r\n    /**\r\n     * Converts 64-bit NTP timestamp value to a String.\r\n     * The NTP timestamp value is represented as hex string with\r\n     * seconds separated by fractional seconds by a decimal point;\r\n     * e.g. c1a089bd.fc904f6d \u003d\u003d Tue, Dec 10 2002 10:41:49.986\r\n     * @param ntpTime the 64 bit timestamp\r\n     *\r\n     * @return NTP timestamp 64-bit long value as hex string with seconds\r\n     * separated by fractional seconds.\r\n     */\r\n    public static String toString(long ntpTime) {\r\n        StringBuilder buf \u003d new StringBuilder();\r\n        // high-order second bits (32..63) as hexstring\r\n        appendHexString(buf, (ntpTime \u003e\u003e\u003e 32) \u0026 0xffffffffL);\r\n        // low-order fractional seconds bits (0..31) as hexstring\r\n        buf.append(\u0027.\u0027);\r\n        appendHexString(buf, ntpTime \u0026 0xffffffffL);\r\n        return buf.toString();\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date.\r\n     */\r\n    public String toDateString() {\r\n        if (simpleFormatter \u003d\u003d null) {\r\n            simpleFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT, Locale.US);\r\n            simpleFormatter.setTimeZone(TimeZone.getDefault());\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return simpleFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Converts this TimeStamp object to a String\r\n     * of the form:\r\n     *\r\n     * EEE, MMM dd yyyy HH:mm:ss.SSS UTC\r\n     * See java.text.SimpleDataFormat for code descriptions.\r\n     *\r\n     * @return a string representation of this date in UTC.\r\n     */\r\n    public String toUTCString() {\r\n        if (utcFormatter \u003d\u003d null) {\r\n            utcFormatter \u003d new SimpleDateFormat(NTP_DATE_FORMAT + \" \u0027UTC\u0027\", Locale.US);\r\n            utcFormatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\r\n        }\r\n        Date ntpDate \u003d getDate();\r\n        return utcFormatter.format(ntpDate);\r\n    }\r\n\r\n    /**\r\n     * Compares two Timestamps numerically.\r\n     *\r\n     * @param   anotherTimeStamp - the TimeStamp to be compared.\r\n     * @return the value 0 if the argument TimeStamp is equal to\r\n     *          this TimeStamp; a value less than 0 if this TimeStamp\r\n     *          is numerically less than the TimeStamp argument; and a\r\n     *          value greater than 0 if this TimeStamp is\r\n     *          numerically greater than the TimeStamp argument\r\n     *          (signed comparison).\r\n     */\r\n    @Override\r\n    public int compareTo(TimeStamp anotherTimeStamp) {\r\n        long thisVal \u003d this.ntpTime;\r\n        long anotherVal \u003d anotherTimeStamp.ntpTime;\r\n        return (thisVal \u003c anotherVal ? -1 : (thisVal \u003d\u003d anotherVal ? 0 : 1));\r\n    }\r\n}\r\n",
    "package": "",
    "classname": "TimeStamp",
    "id": "\\TimeStampSourceCode\\original\\TimeStamp_15Test.java",
    "test_prompt": "// TimeStamp_15Test.java\n\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimeStamp}.\n* It contains ten unit test cases for the {@link TimeStamp#compareTo(TimeStamp)} method.\n*/\nclass TimeStamp_15Test {",
    "method_signature": "compareTo(TimeStamp)",
    "suffix": "15"
  }
]